#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Module pour les v√©rifications de l'environnement de d√©veloppement et d'ex√©cution.

Ce module fournit des fonctions pour v√©rifier la configuration correcte
de divers composants essentiels de l'environnement, tels que Java, JPype,
et les d√©pendances Python.
"""

import os
import logging
import subprocess
from pathlib import Path
import importlib.metadata # Ajout√© pour la v√©rification des versions
try:
    import pkg_resources # Pour parser les requirements
except ImportError:
    # pkg_resources est d√©pr√©ci√© et peut ne pas √™tre disponible dans les nouvelles installations de setuptools.
    # Tenter une alternative ou logguer une erreur si n√©cessaire pour le parsing des requirements.
    # Pour l'instant, on suppose qu'il est disponible ou que le code g√©rera son absence.
    logger.warning("pkg_resources n'a pas pu √™tre import√©. Le parsing des requirements pourrait √©chouer.")
    pkg_resources = None
from typing import List, Tuple, Optional

# Configuration du logging pour ce module
logger = logging.getLogger(__name__)
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] [%(name)s] %(message)s', datefmt='%H:%M:%S')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

def _run_command(cmd: List[str], cwd: Optional[Path] = None) -> Tuple[int, str, str]:
    """
    Ex√©cute une commande et retourne le code de retour, stdout, et stderr.
    Fonction utilitaire interne.
    """
    try:
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=cwd
        )
        stdout, stderr = process.communicate(timeout=30)  # Ajout d'un timeout
        return process.returncode, stdout, stderr
    except subprocess.TimeoutExpired:
        logger.error(f"Timeout lors de l'ex√©cution de {cmd}")
        return -1, "", "TimeoutExpired"
    except FileNotFoundError:
        logger.error(f"Commande non trouv√©e: {cmd[0]}")
        return -1, "", f"FileNotFoundError: {cmd[0]}"
    except Exception as e:
        logger.error(f"Erreur lors de l'ex√©cution de {cmd}: {e}")
        return -1, "", str(e)

def check_java_environment() -> bool:
    """
    V√©rifie la pr√©sence et la configuration correcte de l'environnement d'ex√©cution Java.

    Cette fonction v√©rifie :
    1. Si la variable d'environnement JAVA_HOME est d√©finie et pointe vers un r√©pertoire Java valide.
    2. Si la commande 'java -version' peut √™tre ex√©cut√©e et retourne des informations de version.

    Elle loggue des messages informatifs sur la version de Java trouv√©e et le chemin JAVA_HOME,
    ou des messages d'erreur/avertissement si des probl√®mes sont d√©tect√©s.
    La configuration est consid√©r√©e comme correcte si `java -version` fonctionne et si `JAVA_HOME`
    est d√©fini et valide.

    :return: True si l'environnement Java est consid√©r√© comme correctement configur√©, False sinon.
    :rtype: bool
    """
    logger.info("‚òï V√©rification de l'environnement Java...")
    java_ok = True
    java_home_valid = False

    # 1. V√©rifier JAVA_HOME
    java_home = os.environ.get("JAVA_HOME")
    if java_home:
        logger.info(f"    JAVA_HOME est d√©fini : {java_home}")
        java_home_path = Path(java_home)
        if java_home_path.is_dir():
            # V√©rifier si java.exe (ou java pour non-Windows) existe dans JAVA_HOME/bin
            java_exe_in_home = java_home_path / "bin" / ("java.exe" if os.name == 'nt' else "java")
            if java_exe_in_home.exists() and java_exe_in_home.is_file():
                logger.info(f"    JAVA_HOME pointe vers un r√©pertoire Java valide ({java_exe_in_home}).")
                java_home_valid = True
            else:
                logger.warning(f"    JAVA_HOME ({java_home}) ne semble pas contenir une installation Java valide (ex√©cutable non trouv√© √† {java_exe_in_home}).")
                java_ok = False
        else:
            logger.warning(f"    JAVA_HOME ({java_home}) n'est pas un r√©pertoire valide.")
            java_ok = False
    else:
        logger.warning("    JAVA_HOME n'est pas d√©fini. Cette variable est souvent n√©cessaire pour les outils bas√©s sur Java.")
        # Ne pas mettre java_ok √† False ici, car java peut √™tre dans le PATH.
        # Cependant, pour de nombreux outils, JAVA_HOME est crucial.

    # 2. V√©rifier 'java -version'
    returncode, stdout, stderr = _run_command(["java", "-version"])

    if returncode == 0:
        # stderr contient souvent la version pour 'java -version'
        version_info = stderr.strip() if stderr else stdout.strip()
        if version_info:
            first_line_version = version_info.split('\n')[0]
            logger.info(f"    Commande 'java -version' ex√©cut√©e avec succ√®s. Version d√©tect√©e : {first_line_version}")
        else:
            logger.warning("    Commande 'java -version' ex√©cut√©e, mais n'a retourn√© aucune information de version.")
            java_ok = False # Si pas d'info de version, c'est un probl√®me
    else: # returncode != 0
        logger.error(f"    √âchec de l'ex√©cution de 'java -version'. Code de retour : {returncode}")
        if stderr: # Log stderr s'il y a quelque chose
            logger.error(f"    Stderr: {stderr.strip()}")
        #else: # Optionnel: log si stderr est vide mais il y a une erreur
            #logger.info("    Stderr √©tait vide pour l'√©chec de 'java -version'.")
        if stdout: # Log stdout s'il y a quelque chose
            logger.error(f"    Stdout: {stdout.strip()}")
        #else: # Optionnel: log si stdout est vide
            #logger.info("    Stdout √©tait vide pour l'√©chec de 'java -version'.")

        if returncode == -1 and "FileNotFoundError" in stderr: # Cas sp√©cifique de _run_command
            logger.warning("    Java n'est pas trouv√© dans le PATH (FileNotFoundError).")
        elif returncode != 0 : # Autres erreurs d'ex√©cution o√π java a √©t√© trouv√© mais a √©chou√©
             logger.warning("    La commande 'java -version' a √©chou√© (voir logs ci-dessus), bien que Java semble √™tre dans le PATH.")
        # Si returncode est 0, on ne devrait pas √™tre dans ce bloc 'else'

        java_ok = False

    if not java_home_valid and java_ok : # Si JAVA_HOME n'est pas bon mais java -version fonctionne
        logger.info("    Java est accessible via le PATH, mais JAVA_HOME n'est pas (correctement) d√©fini.")
        # Selon les exigences strictes, cela pourrait √™tre un False.
        # Pour l'instant, si `java -version` fonctionne, on consid√®re que c'est un minimum.
        # Mais on a d√©j√† loggu√© un warning pour JAVA_HOME.

    if java_ok:
        logger.info("‚úÖ L'environnement Java semble correctement configur√© (au moins 'java -version' fonctionne).")
    else:
        logger.error("‚ùå Des probl√®mes ont √©t√© d√©tect√©s avec l'environnement Java.")

    # La fonction doit retourner un bool√©en global.
    # Si `java -version` √©choue, c'est un √©chec.
    # Si `JAVA_HOME` n'est pas valide, c'est un avertissement mais pas un √©chec bloquant si `java -version` fonctionne.
    # La description demande "Retourner un bool√©en indiquant si l'environnement Java est consid√©r√© comme correctement configur√©."
    # La configuration est consid√©r√©e comme "correctement configur√©e" si `java -version` fonctionne
    # ET que `JAVA_HOME` est valide.
    final_status = java_ok and java_home_valid

    if java_ok and not java_home_valid:
        logger.warning("    Bien que 'java -version' fonctionne, JAVA_HOME n'est pas d√©fini ou est invalide. "
                       "Cela peut causer des probl√®mes avec certains outils qui d√©pendent de JAVA_HOME.")
        # La fonction retourne False si JAVA_HOME n'est pas valide, m√™me si 'java -version' fonctionne,
        # car une configuration "correcte" implique g√©n√©ralement un JAVA_HOME valide.

    if final_status:
        logger.info("‚úÖ L'environnement Java est jug√© correctement configur√© (java -version OK et JAVA_HOME valide).")
    else:
        logger.error("‚ùå L'environnement Java n'est pas consid√©r√© comme correctement configur√©.")
        
    return final_status

def check_jpype_config() -> bool:
    """
    V√©rifie si la biblioth√®que JPype est correctement install√©e et capable de d√©marrer la JVM.

    Cette fonction effectue les v√©rifications suivantes :
    1. Tente d'importer le module `jpype`.
    2. Si l'import r√©ussit, v√©rifie si la JVM est d√©j√† d√©marr√©e.
    3. Si la JVM n'est pas d√©marr√©e, tente de la d√©marrer avec `jpype.startJVM()`.
    4. Loggue des messages informatifs sur le statut de JPype et de la JVM.
    5. S'assure que la JVM est arr√™t√©e si elle a √©t√© d√©marr√©e par cette fonction,
       en utilisant `jpype.shutdownJVM()` dans un bloc `finally`.
       Attention : Ne tente pas d'arr√™ter une JVM qui √©tait d√©j√† d√©marr√©e avant l'appel.

    :return: True si JPype semble correctement configur√© et fonctionnel (importable et JVM g√©rable), False sinon.
    :rtype: bool
    :raises ImportError: Si le module `jpype` ne peut pas √™tre import√©.
                         Bien que l'exception soit g√©r√©e en interne et loggu√©e,
                         elle indique un √©chec de la configuration de JPype.
    :raises Exception: Diverses exceptions peuvent √™tre lev√©es par `jpype.startJVM()` ou
                       `jpype.shutdownJVM()` si la JVM rencontre des probl√®mes.
                       Ces exceptions sont g√©r√©es en interne et m√®nent √† un retour de `False`.
    """
    logger.info("üêç V√©rification de la configuration de JPype...")
    jpype_ok = False
    jvm_started_by_this_function = False

    try:
        import jpype
        import jpype.imports
        logger.info("    Module JPype import√© avec succ√®s.")

        if jpype.isJVMStarted():
            logger.info("    La JVM est d√©j√† d√©marr√©e.")
            # Si la JVM est d√©j√† d√©marr√©e par une autre partie du code,
            # on consid√®re que JPype est fonctionnel pour cette v√©rification.
            # On ne la red√©marre pas et on ne l'arr√™tera pas.
            jpype_ok = True
        else:
            logger.info("    La JVM n'est pas d√©marr√©e. Tentative de d√©marrage...")
            try:
                # Utiliser le chemin par d√©faut de la JVM.
                # convertStrings=False est souvent recommand√© pour √©viter les conversions automatiques
                # qui peuvent parfois causer des probl√®mes ou des surcharges.
                jpype.startJVM(jpype.getDefaultJVMPath(), convertStrings=False)
                jvm_started_by_this_function = True
                logger.info("    JVM d√©marr√©e avec succ√®s par cette fonction.")
                jpype_ok = True
            except Exception as e:
                logger.error(f"    √âchec du d√©marrage de la JVM : {e}")
                logger.error("    V√©rifiez votre installation Java et la configuration de JPype (JAVA_HOME, etc.).")
                jpype_ok = False

        if jpype_ok:
            # Tentative d'importer une classe Java simple pour confirmer la communication
            try:
                # jpype.JClass("java.lang.String") # D√©commenter pour un test plus pouss√©
                logger.info("    Test d'acc√®s √† une classe Java de base (java.lang.String) via JPype r√©ussi (implicitement).")
            except Exception as e:
                logger.warning(f"    Avertissement : Impossible de v√©rifier l'acc√®s √† une classe Java de base : {e}")
                # Ne pas marquer jpype_ok √† False pour cela, le d√©marrage de la JVM est le principal.
                pass


    except ImportError:
        logger.error("    √âchec de l'import du module JPype. JPype n'est probablement pas install√©.")
        logger.error("    Veuillez installer JPype1 (par exemple, via 'pip install JPype1').")
        jpype_ok = False
    except Exception as e:
        logger.error(f"    Une erreur inattendue est survenue lors de la v√©rification de JPype : {e}")
        jpype_ok = False
    finally:
        if jvm_started_by_this_function and jpype.isJVMStarted():
            logger.info("    Arr√™t de la JVM d√©marr√©e par cette fonction...")
            try:
                jpype.shutdownJVM()
                logger.info("    JVM arr√™t√©e avec succ√®s.")
            except Exception as e:
                logger.error(f"    Erreur lors de l'arr√™t de la JVM : {e}")
                # Cela pourrait indiquer un probl√®me plus profond.
                jpype_ok = False # Si on ne peut pas arr√™ter proprement, c'est un souci.

    if jpype_ok:
        logger.info("‚úÖ JPype semble correctement configur√© et la JVM est g√©rable.")
    else:
        logger.error("‚ùå Des probl√®mes ont √©t√© d√©tect√©s avec la configuration de JPype ou la gestion de la JVM.")

    return jpype_ok
def check_python_dependencies(requirements_file_path: Path) -> bool:
    """
    V√©rifie si les d√©pendances Python sp√©cifi√©es dans un fichier de requirements
    sont pr√©sentes et satisfont aux contraintes de version.

    Utilise `importlib.metadata` pour obtenir les versions install√©es et
    `pkg_resources` (si disponible) pour parser les sp√©cificateurs de version
    du fichier de requirements.

    :param requirements_file_path: Chemin vers le fichier de d√©pendances (ex: requirements.txt).
    :type requirements_file_path: pathlib.Path
    :return: True si toutes les d√©pendances sont satisfaites, False sinon.
    :rtype: bool
    :raises FileNotFoundError: Si le fichier de requirements sp√©cifi√© n'est pas trouv√© (g√©r√© en interne, retourne False).
    :raises Exception: Diverses exceptions peuvent survenir lors de la lecture ou du parsing
                       du fichier de requirements, ou lors de la v√©rification des versions
                       des packages (g√©r√©es en interne, m√®nent √† un retour de False).
    """
    logger.info(f"üêç V√©rification des d√©pendances Python depuis {requirements_file_path}...")
    all_ok = True
    
    if not requirements_file_path.is_file():
        logger.error(f"    Le fichier de d√©pendances {requirements_file_path} n'a pas √©t√© trouv√©.")
        return False

    # S'assurer que pkg_resources a √©t√© import√©
    if pkg_resources is None:
        logger.error("    pkg_resources n'est pas disponible. Impossible de parser le fichier de d√©pendances.")
        return False

    try:
        with open(requirements_file_path, 'r', encoding='utf-8') as f:
            requirements_content = f.read()
        
        # Filtrer les lignes vides et les commentaires avant de parser
        valid_lines = [
            line for line in requirements_content.splitlines()
            if line.strip() and not line.strip().startswith('#')
        ]
        
        if not valid_lines:
            logger.info(f"    Le fichier de d√©pendances {requirements_file_path} est vide ou ne contient que des commentaires.")
            return True # Un fichier vide est consid√©r√© comme "satisfait"

        # pkg_resources.parse_requirements ne g√®re pas bien les options comme --hash
        # Nous allons parser manuellement pour extraire nom et specifiers
        # Ceci est une simplification; une librairie d√©di√©e comme 'packaging' ou 'requirements-parser' serait plus robuste.
        
        parsed_requirements = []
        for line in valid_lines:
            # Tentative de parser avec pkg_resources, mais √™tre pr√™t √† g√©rer les erreurs pour les lignes complexes
            try:
                # pkg_resources.Requirement.parse peut g√©rer des lignes plus simples
                # ex: "package", "package==1.0", "package>=1.0,<2.0"
                # Il ne g√®re pas les options comme -r, -e, ou les URLs directes de la m√™me mani√®re que parse_requirements
                # Pour une analyse plus robuste, il faudrait une logique de parsing plus d√©taill√©e.
                # Ici, on se concentre sur les d√©pendances nomm√©es avec sp√©cificateurs.
                if line.startswith('-e') or line.startswith('git+') or '.git@' in line:
                    logger.info(f"    Ligne ignor√©e (d√©pendance √©ditable/VCS) : {line}")
                    continue
                if line.startswith('-r'):
                    logger.info(f"    Ligne ignor√©e (inclusion d'un autre fichier) : {line}")
                    continue
                
                # Supprimer les hashes et autres options non support√©es par Requirement.parse
                line_parts = line.split('#')[0].split(';')[0].strip() # Enlever commentaires et marqueurs d'environnement
                
                # Tenter de parser la ligne nettoy√©e
                parsed_req = pkg_resources.Requirement.parse(line_parts)
                parsed_requirements.append(parsed_req)
            except ValueError as ve: # Erreur de parsing de pkg_resources
                 # Essayer d'extraire le nom du package au cas o√π.
                 # Ceci est une heuristique et peut ne pas √™tre pr√©cis.
                # D'abord, nettoyer les commentaires et marqueurs d'environnement comme pour line_parts
                clean_line_for_heuristic = line.split('#')[0].split(';')[0].strip()
                # Ensuite, essayer d'isoler le nom du package avant un crochet ou un op√©rateur de version
                potential_name = clean_line_for_heuristic.split('[')[0].split("==")[0].split(">=")[0].split("<=")[0].split("!=")[0].split("~=")[0].strip()
                
                if potential_name and not any(c in potential_name for c in "[](),"): # Simple v√©rification que le nom est "propre"
                    logger.warning(f"    Impossible de parser compl√®tement la ligne '{line}' avec pkg_resources: {ve}. Tentative avec nom '{potential_name}'.")
                    # Cr√©er un requirement sans specifier si le parsing √©choue mais qu'on a un nom
                    parsed_requirements.append(pkg_resources.Requirement.parse(potential_name))
                else:
                    logger.error(f"    Impossible de parser la ligne de d√©pendance '{line}': {ve}")
                    all_ok = False # Marquer comme √©chec si une ligne ne peut √™tre pars√©e

        if not all_ok: # Si une ligne n'a pas pu √™tre pars√©e, on arr√™te l√† pour cette partie.
            return False

        for req in parsed_requirements:
            req_name = req.project_name 
            try:
                installed_version_str = importlib.metadata.version(req_name)
                installed_version = pkg_resources.parse_version(installed_version_str)
                
                # Si req.specifier est vide (ex: juste "package_name"), on consid√®re que la pr√©sence suffit.
                if not req.specs: # Pas de sp√©cificateur de version
                    logger.info(f"    ‚úÖ {req_name}: Version {installed_version_str} install√©e (aucune version sp√©cifique requise).")
                elif req.specifier.contains(installed_version_str, prereleases=True): # Autoriser les pr√©-releases
                    logger.info(f"    ‚úÖ {req_name}: Version {installed_version_str} install√©e satisfait {req.specifier}")
                else:
                    logger.warning(f"    ‚ùå {req_name}: Version {installed_version_str} install√©e ne satisfait PAS {req.specifier}")
                    all_ok = False
            except importlib.metadata.PackageNotFoundError:
                logger.warning(f"    ‚ùå {req_name}: Non install√© (requis: {req.specifier if req.specs else 'any version'})")
                all_ok = False
            except Exception as e:
                logger.error(f"    ‚ùì Erreur lors de la v√©rification de {req_name}: {e}")
                all_ok = False
                
    except Exception as e:
        logger.error(f"    Erreur lors de la lecture ou du parsing du fichier {requirements_file_path}: {e}")
        return False

    if all_ok:
        logger.info("‚úÖ Toutes les d√©pendances Python du fichier sont satisfaites.")
    else:
        logger.warning("‚ö†Ô∏è  Certaines d√©pendances Python du fichier ne sont pas satisfaites ou sont manquantes.")
        
    return all_ok
if __name__ == '__main__':
    # Pour des tests rapides
    logging.basicConfig(level=logging.INFO)
    logger.info("Test direct de check_java_environment():")
    result = check_java_environment()
    logger.info(f"R√©sultat du test: {result}")