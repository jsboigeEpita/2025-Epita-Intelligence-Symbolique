#!/usr/bin/env python3
"""
üßπ Nettoyage des Scripts Obsol√®tes - Architecture Centralis√©e EPITA

Ce script identifie et archive les scripts obsol√®tes apr√®s la migration
vers l'architecture centralis√©e (3 scripts + pipeline unifi√©).

Auteur: Roo
Date: 10/06/2025
"""

import os
import shutil
import json
from pathlib import Path
from typing import List, Dict, Set
from datetime import datetime

class ObsoleteScriptsCleaner:
    def __init__(self, base_path: str = "scripts"):
        self.base_path = Path(base_path)
        self.archive_path = Path("archived_scripts/obsolete_migration_2025")
        self.report = {
            "timestamp": datetime.now().isoformat(),
            "migration_context": "Architecture Centralis√©e - 42+ scripts ‚Üí 3 scripts consolid√©s",
            "preserved_scripts": [],
            "archived_scripts": [],
            "preserved_directories": [],
            "archived_directories": [],
            "total_files_archived": 0,
            "space_freed_mb": 0
        }
        
        # Scripts consolid√©s √† PR√âSERVER (notre architecture cible)
        self.preserved_scripts = {
            "scripts/consolidated/unified_production_analyzer.py",
            "scripts/consolidated/educational_showcase_system.py", 
            "scripts/consolidated/comprehensive_workflow_processor.py",
            "scripts/consolidated/universal_rhetorical_analyzer.py",  # Legacy mais fonctionnel
            "scripts/consolidated/migration_guide.py"
        }
        
        # R√©pertoires critiques √† PR√âSERVER
        self.preserved_directories = {
            "scripts/consolidated",      # Notre architecture cible
            "scripts/setup",            # Installation et configuration
            "scripts/maintenance",      # Maintenance syst√®me
            "scripts/testing",          # Tests et validation
            "scripts/utils",           # Utilitaires n√©cessaires
            "scripts/setup_core"       # Configuration core
        }
        
        # Scripts utilitaires √† PR√âSERVER au niveau racine
        self.preserved_root_scripts = {
            "migrate_to_unified.py",
            "unified_utilities.py",
            "validation_finale_success_demonstration.py",
            "orchestration_validation.py"
        }

    def analyze_obsolete_structure(self) -> Dict:
        """Analyse la structure pour identifier les scripts obsol√®tes."""
        obsolete_analysis = {
            "obsolete_directories": [],
            "obsolete_scripts": [],
            "size_analysis": {}
        }
        
        print(">>> Analyse de la structure obsolete...")
        
        # Analyse des r√©pertoires obsol√®tes
        for item in self.base_path.iterdir():
            if item.is_dir():
                relative_path = str(item.relative_to(Path(".")))
                
                if relative_path not in self.preserved_directories:
                    # R√©pertoires identifi√©s comme obsol√®tes apr√®s migration
                    obsolete_directories = {
                        "analysis", "apps", "archived", "core", "data_processing",
                        "demo", "diagnostic", "execution", "fix", "legacy_root",
                        "main", "reporting", "sherlock_watson", "test", "validation",
                        "webapp"
                    }
                    
                    if item.name in obsolete_directories:
                        size_mb = self._calculate_directory_size(item)
                        obsolete_analysis["obsolete_directories"].append({
                            "path": relative_path,
                            "size_mb": size_mb,
                            "reason": "Fonctionnalit√©s int√©gr√©es dans pipeline unifi√©"
                        })
                        obsolete_analysis["size_analysis"][relative_path] = size_mb
        
        # Analyse des scripts obsol√®tes au niveau racine
        for item in self.base_path.iterdir():
            if item.is_file() and item.suffix == ".py":
                relative_path = str(item.relative_to(Path(".")))
                
                if item.name not in self.preserved_root_scripts:
                    size_mb = item.stat().st_size / (1024 * 1024)
                    obsolete_analysis["obsolete_scripts"].append({
                        "path": relative_path,
                        "size_mb": size_mb,
                        "reason": "Remplac√© par scripts consolid√©s"
                    })
        
        return obsolete_analysis

    def _calculate_directory_size(self, directory: Path) -> float:
        """Calcule la taille d'un r√©pertoire en MB."""
        total_size = 0
        try:
            for file_path in directory.rglob("*"):
                if file_path.is_file():
                    total_size += file_path.stat().st_size
        except (PermissionError, FileNotFoundError):
            pass
        return total_size / (1024 * 1024)

    def create_archive_structure(self):
        """Cr√©e la structure d'archivage."""
        self.archive_path.mkdir(parents=True, exist_ok=True)
        
        # Cr√©er sous-r√©pertoires d'archivage
        (self.archive_path / "directories").mkdir(exist_ok=True)
        (self.archive_path / "scripts").mkdir(exist_ok=True)
        (self.archive_path / "metadata").mkdir(exist_ok=True)

    def archive_obsolete_directories(self, obsolete_analysis: Dict):
        """Archive les r√©pertoires obsol√®tes."""
        print(">>> Archivage des repertoires obsoletes...")
        
        for dir_info in obsolete_analysis["obsolete_directories"]:
            source_path = Path(dir_info["path"])
            target_path = self.archive_path / "directories" / source_path.name
            
            try:
                if source_path.exists():
                    print(f"  >>> Archivage: {source_path} -> {target_path}")
                    shutil.move(str(source_path), str(target_path))
                    
                    self.report["archived_directories"].append({
                        "source": str(source_path),
                        "target": str(target_path),
                        "size_mb": dir_info["size_mb"],
                        "reason": dir_info["reason"]
                    })
                    self.report["space_freed_mb"] += dir_info["size_mb"]
                    
            except Exception as e:
                print(f"  ERREUR archivage {source_path}: {e}")

    def archive_obsolete_scripts(self, obsolete_analysis: Dict):
        """Archive les scripts obsol√®tes au niveau racine."""
        print(">>> Archivage des scripts obsoletes...")
        
        for script_info in obsolete_analysis["obsolete_scripts"]:
            source_path = Path(script_info["path"])
            target_path = self.archive_path / "scripts" / source_path.name
            
            try:
                if source_path.exists():
                    print(f"  >>> Archivage: {source_path} -> {target_path}")
                    shutil.move(str(source_path), str(target_path))
                    
                    self.report["archived_scripts"].append({
                        "source": str(source_path),
                        "target": str(target_path),
                        "size_mb": script_info["size_mb"],
                        "reason": script_info["reason"]
                    })
                    self.report["space_freed_mb"] += script_info["size_mb"]
                    
            except Exception as e:
                print(f"  ERREUR archivage {source_path}: {e}")

    def update_preserved_inventory(self):
        """Met √† jour l'inventaire des √©l√©ments pr√©serv√©s."""
        print(">>> Inventaire des elements preserves...")
        
        # Scripts pr√©serv√©s
        for script_path in self.preserved_scripts:
            if Path(script_path).exists():
                self.report["preserved_scripts"].append(script_path)
                print(f"  >>> Preserve: {script_path}")
        
        # R√©pertoires pr√©serv√©s
        for dir_path in self.preserved_directories:
            if Path(dir_path).exists():
                self.report["preserved_directories"].append(dir_path)
                print(f"  >>> Preserve: {dir_path}")

    def generate_cleanup_report(self):
        """G√©n√®re le rapport de nettoyage."""
        report_path = self.archive_path / "metadata" / "cleanup_report.json"
        
        # Statistiques finales
        self.report["total_files_archived"] = len(self.report["archived_scripts"]) + \
                                            len(self.report["archived_directories"])
        
        # Sauvegarde rapport JSON
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(self.report, f, indent=2, ensure_ascii=False)
        
        # Rapport Markdown
        self.generate_markdown_report()
        
        print(f"\n>>> Rapport de nettoyage genere: {report_path}")

    def generate_markdown_report(self):
        """G√©n√®re un rapport Markdown lisible."""
        report_md_path = self.archive_path / "metadata" / "RAPPORT_NETTOYAGE_FINAL.md"
        
        content = f"""# üßπ Rapport de Nettoyage Final - Architecture Centralis√©e

**Date**: {self.report['timestamp']}
**Contexte**: {self.report['migration_context']}

## üìä R√©sum√© Ex√©cutif

- **Fichiers archiv√©s**: {self.report['total_files_archived']}
- **Espace lib√©r√©**: {self.report['space_freed_mb']:.2f} MB
- **Scripts pr√©serv√©s**: {len(self.report['preserved_scripts'])}
- **R√©pertoires pr√©serv√©s**: {len(self.report['preserved_directories'])}

## ‚úÖ Scripts Consolid√©s Pr√©serv√©s

"""
        
        for script in self.report['preserved_scripts']:
            content += f"- ‚úÖ `{script}`\n"
        
        content += "\n## üìÅ R√©pertoires Critiques Pr√©serv√©s\n\n"
        
        for directory in self.report['preserved_directories']:
            content += f"- ‚úÖ `{directory}/`\n"
        
        content += "\n## üì¶ R√©pertoires Archiv√©s\n\n"
        
        for dir_info in self.report['archived_directories']:
            content += f"- üìÅ `{dir_info['source']}` ‚Üí `{dir_info['target']}` ({dir_info['size_mb']:.2f} MB)\n"
            content += f"  - **Raison**: {dir_info['reason']}\n"
        
        content += "\n## üìú Scripts Archiv√©s\n\n"
        
        for script_info in self.report['archived_scripts']:
            content += f"- üìÑ `{script_info['source']}` ‚Üí `{script_info['target']}`\n"
        
        content += f"""

## üéØ Architecture Finale

Apr√®s le nettoyage, la structure finale est:

```
scripts/
‚îú‚îÄ‚îÄ consolidated/           ‚úÖ ARCHITECTURE CIBLE
‚îÇ   ‚îú‚îÄ‚îÄ unified_production_analyzer.py
‚îÇ   ‚îú‚îÄ‚îÄ educational_showcase_system.py  
‚îÇ   ‚îî‚îÄ‚îÄ comprehensive_workflow_processor.py
‚îú‚îÄ‚îÄ setup/                 ‚úÖ Configuration syst√®me
‚îú‚îÄ‚îÄ maintenance/           ‚úÖ Maintenance
‚îú‚îÄ‚îÄ testing/              ‚úÖ Tests
‚îú‚îÄ‚îÄ utils/                ‚úÖ Utilitaires
‚îî‚îÄ‚îÄ setup_core/           ‚úÖ Configuration core
```

## ‚úÖ Mission Accomplie

L'architecture centralis√©e est maintenant **propre et finalis√©e** avec :
- 3 scripts consolid√©s op√©rationnels
- Pipeline unifi√© central
- Nettoyage complet des redondances
- {self.report['space_freed_mb']:.2f} MB d'espace lib√©r√©
"""
        
        with open(report_md_path, 'w', encoding='utf-8') as f:
            f.write(content)

    def execute_cleanup(self):
        """Ex√©cute le nettoyage complet."""
        print(">>> Demarrage du nettoyage des scripts obsoletes...")
        print("=" * 60)
        
        # Analyse
        obsolete_analysis = self.analyze_obsolete_structure()
        
        # Cr√©ation structure d'archivage
        self.create_archive_structure()
        
        # Archivage
        self.archive_obsolete_directories(obsolete_analysis)
        self.archive_obsolete_scripts(obsolete_analysis)
        
        # Inventaire pr√©serv√©
        self.update_preserved_inventory()
        
        # Rapport
        self.generate_cleanup_report()
        
        print("=" * 60)
        print(">>> Nettoyage termine avec succes!")
        print(f">>> {self.report['total_files_archived']} elements archives")
        print(f">>> {self.report['space_freed_mb']:.2f} MB liberes")
        print(">>> Architecture centralisee finalisee!")

if __name__ == "__main__":
    cleaner = ObsoleteScriptsCleaner()
    cleaner.execute_cleanup()