#!/usr/bin/env python3
"""
Tests Playwright pour l'Interface Simple d'Analyse Argumentative EPITA
====================================================================

Tests end-to-end de l'interface web simple avec int√©gration ServiceManager r√©el.
Adapt√© des patterns Jest existants de l'interface React vers Playwright.

Architecture identifi√©e :
- Framework: Jest + React Testing Library ‚Üí Playwright (Flask)
- S√©lecteurs: data-testid ‚Üí s√©lecteurs CSS/ID appropri√©s
- Patterns: √âtats de chargement, gestion d'erreurs, exemples pr√©d√©finis
- Service API: Mock patterns ‚Üí ServiceManager r√©el

Version: 1.0.0
Auteur: Intelligence Symbolique EPITA
Date: 09/06/2025
"""

import pytest
import asyncio
import json
import time
from playwright.async_api import async_playwright, Page, Browser, BrowserContext
from pathlib import Path
import logging

# Configuration des chemins
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
INTERFACE_URL = "http://localhost:3000"

# S√©lecteurs adapt√©s de l'interface React vers l'interface simple
SELECTORS = {
    "text_input": "#textInput",
    "analysis_type": "#analysisType",
    "analyze_button": 'button[type="submit"]',
    "status_indicator": "#statusIndicator",
    "results_section": "#resultsSection",
    "char_count": "#charCount",
    "example_buttons": ".example-btn",
    "system_status": "#systemStatus",
    "loading_spinner": "#loadingSpinner",
    "results_content": "#resultsContent",
    "footer_status": "#footerStatus",
    "form": "#analysisForm",
}

# Donn√©es de test avec texte utilisateur contenant des sophismes
TEST_DATA = {
    "user_text_with_fallacies": """
        Les vaccins sont dangereux car mon ami a eu une r√©action apr√®s sa vaccination.
        De plus, si les vaccins √©taient vraiment efficaces, pourquoi y aurait-il encore des maladies ?
        Tous les experts qui soutiennent la vaccination sont pay√©s par les compagnies pharmaceutiques.
        C'est un complot √©vident contre la population.
    """.strip(),
    "simple_logic": "Si il pleut, alors la route est mouill√©e. Il pleut. Donc la route est mouill√©e.",
    "modal_logic": "Il est n√©cessaire que tous les hommes soient mortels. Socrate est un homme.",
    "complex_argument": "L'intelligence artificielle repr√©sente une opportunit√© et un d√©fi majeurs pour notre soci√©t√©.",
    "paradox": "Cette phrase est fausse. Si elle est vraie, alors elle est fausse.",
}

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TestInterfaceSimplePlaywright:
    """
    Tests Playwright pour l'interface simple - Adapt√©s des patterns Jest existants.

    Tests impl√©ment√©s (adapt√©s des 5 composants originaux) :
    - Test de chargement page : Titre, statut syst√®me, aide
    - Test saisie texte : Textarea, compteur caract√®res, types d'analyse
    - Test des exemples : Boutons exemples pr√©d√©finis
    - Test analyse compl√®te : Soumission du texte utilisateur avec sophismes
    - Test gestion √©tats : Loading, erreurs, succ√®s avec ServiceManager r√©el
    """

    @pytest.fixture(scope="class")
    async def browser_context(self):
        """Initialise le contexte du navigateur en mode headed pour d√©monstration."""
        async with async_playwright() as playwright:
            # Mode headed pour d√©monstration visuelle demand√©e
            browser = await playwright.chromium.launch(
                headless=False,  # Mode headed explicite
                slow_mo=1000,  # Ralentissement pour visualisation
                args=["--start-maximized"],
            )

            context = await browser.new_context(
                viewport={"width": 1280, "height": 1024}, locale="fr-FR"
            )

            # Configuration des timeouts adapt√©s pour l'analyse r√©elle
            context.set_default_timeout(30000)  # 30s pour l'analyse ServiceManager

            yield context
            await browser.close()

    @pytest.fixture
    async def page(self, browser_context):
        """Cr√©e une nouvelle page pour chaque test."""
        page = await browser_context.new_page()

        # Navigation vers l'interface simple
        await page.goto(INTERFACE_URL)

        # Attendre que la page soit enti√®rement charg√©e
        await page.wait_for_load_state("networkidle")

        yield page
        await page.close()

    @pytest.mark.asyncio
    async def test_page_loading_complete(self, page: Page):
        """
        Test de chargement page - Adapt√© de "affiche composants initiaux".

        V√©rifie :
        - Titre principal de l'application
        - Indicateur de statut syst√®me
        - Section d'aide et instructions
        - Formulaire d'analyse pr√©sent
        """
        logger.info("üß™ Test: Chargement complet de la page")

        # V√©rification du titre principal (adapt√© de l'interface React)
        title = await page.locator("h1").inner_text()
        assert "Analyse Argumentative EPITA" in title
        logger.info(f"‚úÖ Titre trouv√©: {title}")

        # V√©rification de la pr√©sence de l'indicateur de statut
        status_indicator = page.locator(SELECTORS["status_indicator"])
        await expect(status_indicator).to_be_visible()
        logger.info("‚úÖ Indicateur de statut visible")

        # V√©rification de la section d'aide
        help_section = page.locator("text=Aide")
        await expect(help_section).to_be_visible()
        logger.info("‚úÖ Section d'aide pr√©sente")

        # V√©rification du formulaire d'analyse
        form = page.locator(SELECTORS["form"])
        await expect(form).to_be_visible()
        logger.info("‚úÖ Formulaire d'analyse pr√©sent")

        # Screenshot pour d√©monstration
        await page.screenshot(path="test_page_loading.png")

    @pytest.mark.asyncio
    async def test_text_input_functionality(self, page: Page):
        """
        Test saisie texte - Adapt√© de "gestion des inputs utilisateur".

        V√©rifie :
        - Saisie dans la textarea
        - Compteur de caract√®res fonctionnel
        - S√©lection du type d'analyse
        - Limites de caract√®res
        """
        logger.info("üß™ Test: Fonctionnalit√© de saisie de texte")

        text_input = page.locator(SELECTORS["text_input"])
        char_count = page.locator(SELECTORS["char_count"])
        analysis_type = page.locator(SELECTORS["analysis_type"])

        # Test de saisie de texte
        test_text = TEST_DATA["user_text_with_fallacies"]
        await text_input.fill(test_text)
        logger.info(f"‚úÖ Texte saisi ({len(test_text)} caract√®res)")

        # V√©rification du compteur de caract√®res
        await page.wait_for_timeout(500)  # Attendre la mise √† jour du compteur
        count_text = await char_count.inner_text()
        expected_count = str(len(test_text))
        assert expected_count in count_text
        logger.info(f"‚úÖ Compteur de caract√®res correct: {count_text}")

        # Test de s√©lection du type d'analyse
        await analysis_type.select_option("fallacy")
        selected_value = await analysis_type.input_value()
        assert selected_value == "fallacy"
        logger.info("‚úÖ Type d'analyse 'fallacy' s√©lectionn√©")

        # Screenshot pour d√©monstration
        await page.screenshot(path="test_text_input.png")

    @pytest.mark.asyncio
    async def test_example_buttons_functionality(self, page: Page):
        """
        Test des exemples - Adapt√© de "boutons d'exemples pr√©d√©finis".

        V√©rifie :
        - Boutons d'exemples pr√©sents et cliquables
        - Chargement correct des exemples (Logique Simple, Modale, etc.)
        - Mise √† jour automatique du type d'analyse
        """
        logger.info("üß™ Test: Fonctionnalit√© des boutons d'exemples")

        text_input = page.locator(SELECTORS["text_input"])
        analysis_type = page.locator(SELECTORS["analysis_type"])

        # Test de chaque bouton d'exemple
        examples_to_test = [
            ("Logique Simple", "propositional"),
            ("Logique Modale", "modal"),
            ("Argumentation Complexe", "comprehensive"),
            ("Paradoxe", "comprehensive"),
        ]

        for example_name, expected_type in examples_to_test:
            logger.info(f"üìù Test de l'exemple: {example_name}")

            # Cliquer sur le bouton d'exemple (s√©lecteur sp√©cifique aux boutons)
            example_button = page.locator(
                f'button.example-btn:has-text("{example_name}")'
            )
            await expect(example_button).to_be_visible()
            await example_button.click()

            # Attendre la mise √† jour
            await page.wait_for_timeout(500)

            # V√©rifier que le texte a √©t√© charg√©
            input_value = await text_input.input_value()
            assert len(input_value) > 0
            logger.info(f"‚úÖ Exemple '{example_name}' charg√©: {input_value[:50]}...")

            # V√©rifier le type d'analyse (si automatiquement mis √† jour)
            current_type = await analysis_type.input_value()
            logger.info(f"‚úÖ Type d'analyse: {current_type}")

        # Screenshot pour d√©monstration
        await page.screenshot(path="test_examples.png")

    @pytest.mark.asyncio
    async def test_system_status_check(self, page: Page):
        """
        Test du statut syst√®me - Adapt√© de "v√©rification API health".

        V√©rifie :
        - Chargement du statut syst√®me
        - Indicateurs de sant√© des services
        - √âtat op√©rationnel ou d√©grad√©
        """
        logger.info("üß™ Test: V√©rification du statut syst√®me")

        # Attendre le chargement du statut syst√®me
        system_status = page.locator(SELECTORS["system_status"])
        await expect(system_status).to_be_visible()

        # Attendre que le statut soit charg√© (ne plus afficher "Chargement...")
        await page.wait_for_function(
            """() => {
                const status = document.querySelector('#systemStatus');
                return status && !status.textContent.includes('Chargement...');
            }""",
            timeout=10000,
        )

        # V√©rifier le contenu du statut
        status_text = await system_status.inner_text()

        # Le statut doit indiquer soit "Op√©rationnel" soit "Mode D√©grad√©" soit "Hors Ligne"
        status_found = any(
            status in status_text
            for status in [
                "Op√©rationnel",
                "Mode D√©grad√©",
                "Hors Ligne",
                "ServiceManager",
            ]
        )
        assert status_found, f"Statut non reconnu: {status_text}"
        logger.info(f"‚úÖ Statut syst√®me: {status_text[:100]}...")

        # V√©rifier l'indicateur visuel de statut
        footer_status = page.locator(SELECTORS["footer_status"])
        footer_text = await footer_status.inner_text()
        logger.info(f"‚úÖ Statut footer: {footer_text}")

        # Screenshot pour d√©monstration
        await page.screenshot(path="test_system_status.png")

    @pytest.mark.asyncio
    async def test_complete_analysis_with_fallacies(self, page: Page):
        """
        Test analyse compl√®te - Adapt√© de "soumission et r√©sultats ServiceManager".

        V√©rifie :
        - Soumission du texte utilisateur avec sophismes
        - √âtats de chargement (loading spinner)
        - Affichage des r√©sultats d'analyse r√©els
        - Gestion des erreurs si ServiceManager indisponible
        """
        logger.info("üß™ Test: Analyse compl√®te avec sophismes")

        text_input = page.locator(SELECTORS["text_input"])
        analysis_type = page.locator(SELECTORS["analysis_type"])
        analyze_button = page.locator(SELECTORS["analyze_button"])
        loading_spinner = page.locator(SELECTORS["loading_spinner"])
        results_section = page.locator(SELECTORS["results_section"])

        # Saisie du texte avec sophismes
        test_text = TEST_DATA["user_text_with_fallacies"]
        await text_input.fill(test_text)
        await analysis_type.select_option("fallacy")
        logger.info("üìù Texte avec sophismes saisi")

        # Screenshot avant soumission
        await page.screenshot(path="test_before_analysis.png")

        # Cliquer sur le bouton d'analyse
        await analyze_button.click()
        logger.info("üöÄ Analyse lanc√©e")

        # V√©rifier l'√©tat de chargement (peut √™tre tr√®s rapide avec ServiceManager optimis√©)
        try:
            await expect(loading_spinner).to_be_visible(timeout=1000)
            logger.info("‚úÖ Spinner de chargement affich√©")
            # Attendre que l'analyse soit termin√©e
            await expect(loading_spinner).to_be_hidden(timeout=30000)
            logger.info("‚úÖ Chargement termin√©")
        except:
            # L'analyse peut √™tre si rapide que le spinner n'appara√Æt pas
            logger.info("‚úÖ Analyse tr√®s rapide - pas de spinner visible")

        # V√©rifier l'affichage des r√©sultats
        await expect(results_section).to_be_visible()

        # Attendre que le contenu soit charg√©
        await page.wait_for_timeout(1000)

        results_content = page.locator(SELECTORS["results_content"])
        results_text = await results_content.inner_text()

        # V√©rifier que l'analyse a produit des r√©sultats
        success_indicators = [
            "Analyse termin√©e avec succ√®s",
            "R√©sultats d'analyse",
            "analysis_id",
            "D√©tails de l'analyse",
            "ServiceManager",
        ]

        results_valid = any(
            indicator in results_text for indicator in success_indicators
        )

        if results_valid:
            logger.info("‚úÖ Analyse r√©ussie avec ServiceManager")
            logger.info(f"üìä R√©sultats: {results_text[:200]}...")
        else:
            # Mode d√©grad√© accept√© si ServiceManager indisponible
            logger.info("‚ö†Ô∏è Analyse en mode d√©grad√© (ServiceManager indisponible)")
            logger.info(f"üìä R√©sultats d√©grad√©s: {results_text[:200]}...")

        # Screenshot des r√©sultats
        await page.screenshot(path="test_analysis_results.png")

        # V√©rifier les m√©triques affich√©es
        metrics_found = any(
            metric in results_text
            for metric in ["Mots", "Phrases", "Complexit√©", "Temps", "caract√®res"]
        )
        assert metrics_found, "Aucune m√©trique trouv√©e dans les r√©sultats"
        logger.info("‚úÖ M√©triques d'analyse affich√©es")

    @pytest.mark.asyncio
    async def test_error_handling_and_states(self, page: Page):
        """
        Test gestion √©tats - Adapt√© de "gestion d'erreurs et √©tats de chargement".

        V√©rifie :
        - Gestion des erreurs (texte vide, trop long)
        - √âtats de chargement coh√©rents
        - Messages d'erreur appropri√©s
        - R√©cup√©ration apr√®s erreur
        """
        logger.info("üß™ Test: Gestion des erreurs et √©tats")

        text_input = page.locator(SELECTORS["text_input"])
        analyze_button = page.locator(SELECTORS["analyze_button"])

        # Test 1: Soumission avec texte vide
        logger.info("üìù Test: Texte vide")
        await text_input.fill("")
        await analyze_button.click()

        # Attendre et v√©rifier l'alerte (g√©r√©e par JavaScript)
        await page.wait_for_timeout(1000)
        logger.info("‚úÖ Gestion du texte vide v√©rifi√©e")

        # Test 2: Texte trop long (simulation)
        logger.info("üìù Test: Limitation de caract√®res")
        long_text = "A" * 10001  # D√©passe la limite de 10000
        await text_input.fill(long_text)

        # V√©rifier que la limitation est appliqu√©e
        actual_value = await text_input.input_value()
        assert (
            len(actual_value) <= 10000
        ), f"Texte trop long accept√©: {len(actual_value)}"
        logger.info("‚úÖ Limitation de caract√®res fonctionnelle")

        # Test 3: R√©cup√©ration normale apr√®s erreur
        logger.info("üìù Test: R√©cup√©ration apr√®s erreur")
        normal_text = TEST_DATA["simple_logic"]
        await text_input.fill(normal_text)
        await analyze_button.click()

        # Attendre l'analyse
        await page.wait_for_timeout(5000)

        results_section = page.locator(SELECTORS["results_section"])
        is_visible = await results_section.is_visible()

        if is_visible:
            logger.info("‚úÖ R√©cup√©ration r√©ussie apr√®s erreur")
        else:
            logger.info("‚ö†Ô∏è R√©cup√©ration en cours ou mode d√©grad√©")

        # Screenshot final
        await page.screenshot(path="test_error_handling.png")


def expect(locator):
    """Helper function pour les assertions Playwright."""
    from playwright.async_api import expect as playwright_expect

    return playwright_expect(locator)


@pytest.mark.asyncio
async def test_run_all_playwright_tests():
    """
    Point d'entr√©e principal pour ex√©cuter tous les tests Playwright.

    Configure le mode headed et ex√©cute la suite compl√®te de tests.
    """
    logger.info("üöÄ D√©marrage des tests Playwright - Interface Simple")
    logger.info("üìã Tests adapt√©s de l'architecture Jest/React vers Playwright/Flask")

    # Cr√©er une instance de test
    test_instance = TestInterfaceSimplePlaywright()

    async with async_playwright() as playwright:
        # Mode headed pour d√©monstration visuelle
        browser = await playwright.chromium.launch(
            headless=False,
            slow_mo=1500,  # Ralentissement pour d√©monstration
            args=["--start-maximized"],
        )

        context = await browser.new_context(
            viewport={"width": 1280, "height": 1024}, locale="fr-FR"
        )
        context.set_default_timeout(30000)

        page = await context.new_page()

        try:
            # Navigation initiale
            await page.goto(INTERFACE_URL)
            await page.wait_for_load_state("networkidle")

            logger.info("üåê Page charg√©e avec succ√®s")

            # Ex√©cution des tests en s√©quence pour d√©monstration
            await test_instance.test_page_loading_complete(page)
            await page.wait_for_timeout(2000)

            await test_instance.test_text_input_functionality(page)
            await page.wait_for_timeout(2000)

            await test_instance.test_example_buttons_functionality(page)
            await page.wait_for_timeout(2000)

            await test_instance.test_system_status_check(page)
            await page.wait_for_timeout(2000)

            await test_instance.test_complete_analysis_with_fallacies(page)
            await page.wait_for_timeout(2000)

            await test_instance.test_error_handling_and_states(page)

            logger.info("‚úÖ Tous les tests Playwright termin√©s avec succ√®s")

        except Exception as e:
            logger.error(f"‚ùå Erreur lors des tests: {e}")
            await page.screenshot(path="test_error.png")
            raise
        finally:
            await context.close()
            await browser.close()


if __name__ == "__main__":
    """
    Ex√©cution directe des tests Playwright en mode headed.

    Usage:
        python test_interface_simple_playwright.py
    """
    logger.info("üé≠ Tests Playwright - Interface Simple d'Analyse Argumentative")
    logger.info("üîÑ Adapt√© de l'architecture Jest/React vers Playwright/Flask")
    logger.info("üéØ Mode headed activ√© pour d√©monstration visuelle")

    # V√©rifier que l'interface est accessible
    import requests

    try:
        response = requests.get(INTERFACE_URL, timeout=5)
        if response.status_code == 200:
            logger.info(f"‚úÖ Interface simple accessible sur {INTERFACE_URL}")
        else:
            logger.error(f"‚ùå Interface non accessible: HTTP {response.status_code}")
            exit(1)
    except requests.exceptions.RequestException as e:
        logger.error(f"‚ùå Impossible de contacter l'interface: {e}")
        logger.error(
            "üí° Assurez-vous que l'interface simple est d√©marr√©e sur le port 3000"
        )
        exit(1)

    # Ex√©cution des tests
    asyncio.run(test_run_all_playwright_tests())
