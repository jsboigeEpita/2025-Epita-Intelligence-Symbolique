Présence de ressources binaires sur le dépôt TweetyProject pour éventuellement les télécharger:
https://github.com/TweetyProjectTeam/TweetyProject/raw/refs/heads/main/org-tweetyproject-arg-adf/src/main/resources/picosat.so
org-tweetyproject-arg-adf/src/main/resources/picosat.dll
org-tweetyproject-arg-adf/src/main/resources/lingeling.dll
org-tweetyproject-arg-adf/src/main/resources/lingeling.so
org-tweetyproject-arg-adf/src/main/resources/minisat.dll
org-tweetyproject-arg-adf/src/main/resources/minisat.so

org-tweetyproject-arg-aba/src/main/resources/smp_fol.aba

{Pair(a,c);Pair(a,d);Pair(b,c);Pair(b,d)}

ContraryPair(A,B) <- MPrefers(A,D,B); Pair(A,D)
ContraryPair(A,B) <- WPrefers(B,E,A); Pair(E,B)
MPrefers(a,d,c) <-
MPrefers(b,c,d) <-
WPrefers(c,a,b) <-
WPrefers(d,b,a) <-

not Pair(A,B) = ContraryPair(A,B)

org-tweetyproject-arg-aba/src/main/resources/example5.aba

p<-a
p<-b
c<-
{a,b,c,d}
not a =  b
not b = a
not c = d
not d = p


org-tweetyproject-arg-aba/src/main/resources/example1.aba

% example

{a, b}
c 

a <- b
z <- y, b
y <-
x <- c

org-tweetyproject-arg-adf/src/main/java/org/tweetyproject/arg/adf/examples/ADFExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.adf.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

import org.tweetyproject.arg.adf.io.KppADFFormatParser;
import org.tweetyproject.arg.adf.reasoner.AdmissibleReasoner;
import org.tweetyproject.arg.adf.reasoner.CompleteReasoner;
import org.tweetyproject.arg.adf.reasoner.GroundReasoner;
import org.tweetyproject.arg.adf.reasoner.ModelReasoner;
import org.tweetyproject.arg.adf.reasoner.PreferredReasoner;
import org.tweetyproject.arg.adf.reasoner.StableReasoner;
import org.tweetyproject.arg.adf.sat.solver.NativeMinisatSolver;
import org.tweetyproject.arg.adf.semantics.interpretation.Interpretation;
import org.tweetyproject.arg.adf.semantics.link.LinkStrategy;
import org.tweetyproject.arg.adf.semantics.link.SatLinkStrategy;
import org.tweetyproject.arg.adf.syntax.Argument;
import org.tweetyproject.arg.adf.syntax.acc.AcceptanceCondition;
import org.tweetyproject.arg.adf.syntax.adf.AbstractDialecticalFramework;

/**
 *  Example code illustrating Abstract Dialectical Frameworks (ADFs) with different semantics.
 *  
 * @author Jonas Schumacher
 *
 */
public class ADFExample {

	/**
	 * 
	 * @param args args
	 * @throws FileNotFoundException File Not Found Exception
	 * @throws IOException IO Exception
	 */
	public static void main(String[] args) throws FileNotFoundException, IOException {
		
		// Parse ADF from text file
		NativeMinisatSolver solver = new NativeMinisatSolver();
		LinkStrategy strat = new SatLinkStrategy(solver);
		KppADFFormatParser parser = new KppADFFormatParser(strat, true);
		AbstractDialecticalFramework adf = parser.parse(new File("src/main/resources/adf_example.txt"));

		Set<Argument> arguments = adf.getArguments();
		System.out.println("Arguments contained in ADF: " + arguments);
		System.out.println("------------------------------------------");
		
		// Print all arguments and corresponding acceptance conditions 
		Iterator<Argument> arg_iterator = arguments.iterator();
		Argument ar;
		AcceptanceCondition ac;
		while(arg_iterator.hasNext()) {
			ar = arg_iterator.next();
			System.out.println("Argument: \t\t\t " + ar);
			ac = adf.getAcceptanceCondition(ar);
			System.out.println("Acceptance Condition (" + ar + ") \t" + ac);
		}
		System.out.println("------------------------------------------");
		
		// Calculate and print different types of semantics
		
		// Admissible interpretations
		AdmissibleReasoner adm_reasoner = new AdmissibleReasoner(solver);
		System.out.println("Admissible interpretations: ");
		Collection<Interpretation> extensions = adm_reasoner.getModels(adf);
		System.out.println(extensions);
		
		// Complete interpretations
		CompleteReasoner comp_reasoner = new CompleteReasoner(solver);
		System.out.println("Complete interpretations: ");
		extensions = comp_reasoner.getModels(adf);
		System.out.println(extensions);
		
		// Grounded interpretations
		GroundReasoner ground_reasoner = new GroundReasoner(solver);
		System.out.println("Grounded interpretation: ");
		extensions = ground_reasoner.getModels(adf);
		System.out.println(extensions);	
		
		// Preferred interpretations
		PreferredReasoner pref_reasoner = new PreferredReasoner(solver);
		System.out.println("Preferred interpretations: ");
		extensions = pref_reasoner.getModels(adf);
		System.out.println(extensions);	
		
		// 2-valued interpretations
		ModelReasoner model_reasoner = new ModelReasoner(solver);
		System.out.println("2-valued interpretations: ");
		Collection<Interpretation> extensions_2val = model_reasoner.getModels(adf);
		System.out.println(extensions_2val);
		
		// Stable interpretation
		StableReasoner stab_reasoner = new StableReasoner(solver);
		System.out.println("Stable interpretations: ");
		extensions = stab_reasoner.getModels(adf);
		System.out.println(extensions);
	}
}

org-tweetyproject-arg-aba/src/main/java/org/tweetyproject/arg/aba/examples/AbaExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.aba.examples;

import java.io.FileNotFoundException;
import java.io.IOException;

import org.tweetyproject.arg.aba.parser.AbaParser;
import org.tweetyproject.arg.aba.reasoner.FlatAbaReasoner;
import org.tweetyproject.arg.aba.reasoner.PreferredReasoner;
import org.tweetyproject.arg.aba.syntax.AbaTheory;
import org.tweetyproject.arg.aba.syntax.Assumption;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.commons.ParserException;
import org.tweetyproject.logics.fol.parser.FolParser;
import org.tweetyproject.logics.fol.syntax.FolFormula;
import org.tweetyproject.logics.fol.syntax.FolSignature;
import org.tweetyproject.logics.pl.parser.PlParser;
import org.tweetyproject.logics.pl.sat.Sat4jSolver;
import org.tweetyproject.logics.pl.sat.SatSolver;
import org.tweetyproject.logics.pl.syntax.Proposition;
import org.tweetyproject.logics.pl.syntax.PlFormula;

/**
 * Shows some simple code for working with ABA, including how to parse an ABA file and how to ask queries.
 *
 * @author Matthias Thimm
 *
 */
public class AbaExample {


	    /**
     * Default constructor for the {@code AbaExample} class.
     * This constructor initializes the class without any specific setup.
     */
    public AbaExample() {
        // Default constructor
    }

    /**
     * Main method that demonstrates parsing and reasoning with Assumption-Based Argumentation (ABA)
     * using both propositional logic and first-order logic.
     *
     * @param args command line arguments (not used)
     * @throws FileNotFoundException if the input file is not found
     * @throws ParserException if there is an error during parsing
     * @throws IOException if there is an error reading the file
     */
	public static void main(String[] args) throws FileNotFoundException, ParserException, IOException{
		//PL Example
		SatSolver.setDefaultSolver(new Sat4jSolver());
		AbaParser<PlFormula> parser1 = new AbaParser<PlFormula>(new PlParser());
		AbaTheory<PlFormula> abat1 = parser1.parseBeliefBaseFromFile(AbaExample.class.getResource("/example2.aba").getFile());
		System.out.println("Parsed belief base: " + abat1);
		FlatAbaReasoner<PlFormula> r1 = new FlatAbaReasoner<PlFormula>(Semantics.PREFERRED_SEMANTICS);
		PreferredReasoner<PlFormula> r2 = new PreferredReasoner<PlFormula>();
		Assumption<PlFormula> a = new Assumption<>(new Proposition("a"));
		System.out.println("query " + a + ": " + r1.query(abat1,a));
		System.out.println("query " + a + ": " + r2.query(abat1,a));
		System.out.println("as graph: " + abat1.asDungTheory());

		//FOL Example
		FolParser folparser = new FolParser();
		FolSignature sig = folparser.parseSignature("Male = {a,b}\n"
				+ "Female = {c,d}\n" +
				"type(Pair(Male,Female))\n" +
				"type(ContraryPair(Male,Female))\n" +
				"type(MPrefers(Male,Female,Female))\n"
				+ "type(WPrefers(Female,Male,Male))");
		folparser.setSignature(sig);
		AbaParser<FolFormula> parser2 = new AbaParser<FolFormula>(folparser);
		parser2.setSymbolComma(";");
		AbaTheory<FolFormula> abat2 = parser2.parseBeliefBaseFromFile(AbaExample.class.getResource("/smp_fol.aba").getFile());
		FlatAbaReasoner<FolFormula> r4 = new FlatAbaReasoner<FolFormula>(Semantics.STABLE_SEMANTICS);
		System.out.println(r4.getModels(abat2));
		PreferredReasoner<FolFormula> r5 = new PreferredReasoner<FolFormula>();
		Assumption<FolFormula> a2 = new Assumption<>(folparser.parseFormula("Pair(a,d)"));
		System.out.println("query " + a2 + ": " + r5.query(abat2,a2));
	}
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/ApproximateJustificationAnalysisExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.analysis.AnalysisResult;
import org.tweetyproject.arg.bipolar.analysis.ApproxAnalysis;
import org.tweetyproject.arg.bipolar.analysis.ExactAnalysis;
import org.tweetyproject.arg.dung.reasoner.SimplePreferredReasoner;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Demonstrates the use of exact and approximate justification analysis on a PEAFTheory.
 * <p>
 * This example sets up a PEAFTheory with a number of arguments, defines supports and attacks among them,
 * and then performs exact and approximate analyses to justify a specific argument.
 * </p>
 */
public class ApproximateJustificationAnalysisExample {

    /**
     * Example
     * @param args the args
     */
    public static void main(String[] args) {
        int numOfArgs = 7;  // Number of arguments to add to the PEAFTheory
        PEAFTheory peafTheory = new PEAFTheory();

        // Add arguments to the theory
        for (int i = 0; i < numOfArgs; i++) {
            peafTheory.addArgument(i);
        }

        // Define supports among arguments with associated probabilities
        peafTheory.addSupport(
            new HashSet<>(),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            1.0
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(2))),
            0.6
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1))),
            0.7
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(3))),
            0.9
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(4))),
            0.3
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(3))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5))),
            0.5
        );

        // Define supports involving multiple arguments
        Set<BArgument> argSet = new HashSet<>();
        argSet.add(peafTheory.getArguments().get(3));
        argSet.add(peafTheory.getArguments().get(4));
        peafTheory.addSupport(
            argSet,
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(6))),
            0.9
        );

        // Define attack relationships among arguments
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(2)))
        );
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1)))
        );
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5)))
        );
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(6)))
        );

        // Define the query for analysis
        Set<BArgument> query = new HashSet<>();
        query.add(peafTheory.getArguments().get(0));

        // Perform exact analysis
        ExactAnalysis exactAnalysis = new ExactAnalysis(peafTheory, new SimplePreferredReasoner());
        AnalysisResult exactResult = exactAnalysis.query(query);
        exactResult.print();

        // Perform approximate analysis
        ApproxAnalysis approxAnalysis = new ApproxAnalysis(peafTheory, new SimplePreferredReasoner(), 0.1);
        AnalysisResult approxResult = approxAnalysis.query(query);
        approxResult.print();
    }

    /** Default Constructor */
    public ApproximateJustificationAnalysisExample() {}
}


org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/AllPEAFInducerExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.inducers.LiExactPEAFInducer;
import org.tweetyproject.arg.bipolar.io.EdgeListWriter;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.concurrent.atomic.AtomicInteger;


/**
 * Example class demonstrating the use of the PEAF (Preference-based Argumentation Framework) inducer.
 * <p>
 * This example sets up a PEAF theory with a specified number of arguments, adds various support and attack relationships
 * between the arguments, and then uses the `LiExactPEAFInducer` to induce new EAF (Argumentation Framework) theories from the
 * given PEAF theory. The results are printed and saved to files.
 * </p>
 */
public class AllPEAFInducerExample {
       /**
     * Main method to run the example.
     * <p>
     * This method initializes a PEAF theory with a set number of arguments, defines support and attack relationships,
     * and uses the `LiExactPEAFInducer` to induce new EAF theories. It prints each induced EAF and saves it to a file.
     * </p>
     *
     * @param args Command line arguments (not used in this example).
     */
    public static void main(String[] args) {
        int numOfArgs = 8;


        PEAFTheory peafTheory = new PEAFTheory();

        for (int i = 0; i < numOfArgs; i++) {
            peafTheory.addArgument(i);
        }

        peafTheory.addSupport(new HashSet<BArgument>(), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), 1.0);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), 0.3);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), 0.8);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), 0.9);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(4)))), 0.85);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))), 0.5);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(6)))), 0.6);
        HashSet<BArgument> myArgs = new HashSet<BArgument>();
        myArgs.add(peafTheory.getArguments().get(5));
        myArgs.add(peafTheory.getArguments().get(4));
        peafTheory.addSupport(myArgs, new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(7)))), 0.4);

        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(4)))));
        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(6)))));

        peafTheory.prettyPrint();

        EdgeListWriter.write("0.peaf", peafTheory);

        AtomicInteger i = new AtomicInteger();
        LiExactPEAFInducer inducer = new LiExactPEAFInducer(peafTheory);

        inducer.induce(ind -> {
            int n = i.getAndIncrement();
            System.out.println(ind);
            EdgeListWriter.write(n + ".eaf", ind.toNewEAFTheory());

        });

    }

    /** Default Constructor */
    public AllPEAFInducerExample(){}
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/OrenEtAl2010Figure2Example.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.dung.reasoner.SimplePreferredReasoner;
import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.syntax.DungTheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.EAFTheory;

/**
 * OrenEtAl2010Figure2Example class
 */
public class OrenEtAl2010Figure2Example {
    /**
     * Example
     * @param args args
     */
    public static void main(String[] args) {
        EAFTheory eafTheory = new EAFTheory();
        for(int i = 0; i< 4 ; i++) {
        	eafTheory.addArgument(i);
        }


        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(1)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))));
        eafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(1)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(3)))));

        DungTheory dungTheory = eafTheory.convertToDAFNaively();

        System.out.println("EAF Theory Pretty Print:");
        eafTheory.prettyPrint();

        System.out.println("DAF Theory Pretty Print:");
        System.out.println(dungTheory.prettyPrint());

        System.out.println("SimplePreferredReasoner:");
        SimplePreferredReasoner reasoner1 = new SimplePreferredReasoner();
        for (Extension model : reasoner1.getModels(dungTheory)) {
            System.out.println(model);
        }
    }
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/NecessityArgumentation.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2020 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import java.util.HashSet;

import org.tweetyproject.arg.bipolar.reasoner.necessity.*;
import org.tweetyproject.arg.bipolar.syntax.*;

/**
 * Examples for necessity argumentation frameworks.
 */
public class NecessityArgumentation {

    /**
     * Example
     * @param args args
     */
    public static void main(String[] args) {
        // Example from Polberg, Oren. Revisiting Support in Abstract Argumentation Systems. 2014
        NecessityArgumentationFramework nt = new NecessityArgumentationFramework();
        BArgument a = new BArgument("a");
        BArgument b = new BArgument("b");
        BArgument c = new BArgument("c");
        BArgument d = new BArgument("d");
        BArgument e = new BArgument("e");
        nt.add(a);
        nt.add(b);
        nt.add(c);
        nt.add(d);
        nt.add(e);

        ArgumentSet aS1 = new ArgumentSet();
        aS1.add(b);
        aS1.add(d);
        Attack att1 = new BinaryAttack(b, a);
        Attack att2 = new BinaryAttack(e, a);
        Attack att3 = new BinaryAttack(c, d);
        Support supp1 = new BinarySupport(a, c);
        Support supp2 = new BinarySupport(b, b);
        HashSet<BArgument> eSet = new HashSet<BArgument>();
        eSet.add(e);
        Support supp3 = new SetSupport(aS1, eSet);
        nt.add(att1);
        nt.add(att2);
        nt.add(att3);
        nt.add(supp1);
        nt.add(supp2);
        nt.add(supp3);

        System.out.println(nt.prettyPrint());

        System.out.println("Admissible extensions: " + new AdmissibleReasoner().getModels(nt));
        System.out.println("Grounded extensions: " + new GroundedReasoner().getModels(nt));
        System.out.println("Complete extensions: " + new CompleteReasoner().getModels(nt));
        System.out.println("Preferred extensions: " + new PreferredReasoner().getModels(nt));
        System.out.println("Stable extensions: " + new StableReasoner().getModels(nt));
    }
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/MeetingPEAFExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.inducers.ExactPEAFInducer;
import org.tweetyproject.arg.bipolar.inducers.LiExactPEAFInducer;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;

import java.util.HashSet;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * MeetingPEAFExample class
 */
public class MeetingPEAFExample {

    /** total */
    static double total = 0;

    /**
     * Example
     * @param s args
     */
    public static void main(String[] s) {
        int numOfArgs = 7;


        PEAFTheory peafTheory = new PEAFTheory();

        for (int i = 0; i < numOfArgs; i++) {
            peafTheory.addArgument(i);
        }
        HashSet<BArgument> arg0 = new HashSet<BArgument>();
        arg0.add(peafTheory.getArguments().get(0));
        HashSet<BArgument> arg1 = new HashSet<BArgument>();
        arg1.add(peafTheory.getArguments().get(1));
        HashSet<BArgument> arg2 = new HashSet<BArgument>();
        arg2.add(peafTheory.getArguments().get(2));
        HashSet<BArgument> arg3 = new HashSet<BArgument>();
        arg3.add(peafTheory.getArguments().get(3));
        HashSet<BArgument> arg4 = new HashSet<BArgument>();
        arg4.add(peafTheory.getArguments().get(4));
        HashSet<BArgument> arg5 = new HashSet<BArgument>();
        arg5.add(peafTheory.getArguments().get(5));
        HashSet<BArgument> arg6 = new HashSet<BArgument>();
        arg6.add(peafTheory.getArguments().get(6));

        peafTheory.addSupport(new HashSet<BArgument>(), arg0 , 1.0);
        peafTheory.addSupport(arg0, arg2, 1.0);
        peafTheory.addSupport(arg0, arg1, 1.0);
        peafTheory.addSupport(arg0, arg3, 1.0);
        peafTheory.addSupport(arg0, arg4, 1.0);
        peafTheory.addSupport(arg3, arg5, 1.0);
//        peafTheory.addSupport(new int[]{3, 4}, new int[]{6}, 0.9);

        peafTheory.addAttack(arg5, arg2);
        peafTheory.addAttack(arg5, arg1);
        peafTheory.addAttack(arg1, arg5);
        peafTheory.addAttack(arg1, arg6);


        List<BArgument> args = peafTheory.getArguments();
        args.get(0).setName("eta");
        args.get(1).setName("b");
        args.get(2).setName("d");
        args.get(3).setName("e");
        args.get(4).setName("f");
        args.get(5).setName("a");
        args.get(6).setName("c");
        peafTheory.prettyPrint();
//        EdgeListWriter.write("/Users/tdgunes/Projects/DrawPrEAF/input/0.peaf", peafTheory);

        System.out.println("LiExactPEAFInducer: ");
        AtomicInteger i = new AtomicInteger();
        LiExactPEAFInducer inducer = new LiExactPEAFInducer(peafTheory);
        total = 0;
        inducer.induce(ind -> {
            int n = i.getAndIncrement();
            System.out.println(n + ". " + ind);
            String probability = String.format("%.04f", ind.getInducePro());
            probability = probability.replace(".", "_");
//            EdgeListWriter.write("/Users/tdgunes/Projects/DrawPrEAF/input/" + n + "" + "_" + result + ".eaf", ind.toNewEAFTheory());
            total += ind.getInducePro();
        });
        System.out.println("Total result: " + total);

        System.out.println();
        System.out.println("The ExactPEAFInducer:");
        System.out.println();
        AtomicInteger i1 = new AtomicInteger();
        ExactPEAFInducer inducer2 = new ExactPEAFInducer(peafTheory);
        total = 0;
        inducer2.induce(ind -> {
            int n = i1.getAndIncrement();
            System.out.println(n + ". " + ind);
            String probability = String.format("%.04f", ind.getInducePro());
            probability = probability.replace(".", "_");
//            EdgeListWriter.write("/Users/tdgunes/Projects/DrawPrEAF/input/" + n + "" + "_" + result + ".eaf", ind.toNewEAFTheory());
            total += ind.getInducePro();
        });
        System.out.println("Total result: " + total);

    }
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/LiThesisPage21EAFExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.dung.reasoner.SimplePreferredReasoner;
import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.bipolar.syntax.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

/**
 * LiThesisPage21EAFExample class
 */
public class LiThesisPage21EAFExample {

    /**
     * Example
     * @param args the args
     */
    public static void main(String[] args) {
        EAFTheory eafTheory = new EAFTheory();
        for(int i = 0; i< 9; i++) {
        	eafTheory.addArgument(i);
        }

        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(1)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(3)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(4)))));
        HashSet<BArgument> arg3And4 = new HashSet<BArgument>();
        arg3And4.add(eafTheory.getArguments().get(3));
        arg3And4.add(eafTheory.getArguments().get(4));
        eafTheory.addSupport(arg3And4, new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(7)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(5)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(5)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(8)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(6)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(6)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(8)))));

        eafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(5)))));
        eafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(6)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(3)))));


        DungTheory dungTheory = eafTheory.convertToDAFNaively();

        System.out.println("EAF Theory Pretty Print:");
        eafTheory.prettyPrint();

        System.out.println("DAF Theory Pretty Print:");
        System.out.println(dungTheory.prettyPrint());

        System.out.println("SimplePreferredReasoner:");
        SimplePreferredReasoner reasoner1 = new SimplePreferredReasoner();
        for (Extension model : reasoner1.getModels(dungTheory)) {
            System.out.println(model);
        }
    }
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/JustificationAnalysisExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.analysis.AnalysisResult;
import org.tweetyproject.arg.bipolar.analysis.ExactAnalysis;
import org.tweetyproject.arg.dung.reasoner.SimplePreferredReasoner;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
/**
 * JustificationAnalysisExample class
 */
public class JustificationAnalysisExample {
    /**
     * Example
     * @param s string array
     */
    public static void main(String[] s) {
        int numOfArgs = 7;
        PEAFTheory peafTheory = new PEAFTheory();

        for (int i = 0; i < numOfArgs; i++) {
            peafTheory.addArgument(i);
        }


        peafTheory.addSupport(new HashSet<BArgument>(), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), 1.0);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), 0.6);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), 0.7);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), 0.9);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(4)))), 0.3);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))), 0.5);
        HashSet<BArgument> arg3And4 = new HashSet<BArgument>();
        arg3And4.add(peafTheory.getArguments().get(3));
        arg3And4.add(peafTheory.getArguments().get(4));
        peafTheory.addSupport(arg3And4, new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(6)))), 0.9);
        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))));
        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))));
        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))));
        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(6)))));

        List<BArgument> args = peafTheory.getArguments();
//        args.get(0).setName("eta");
//        args.get(1).setName("b");
//        args.get(2).setName("d");
//        args.get(3).setName("e");
//        args.get(4).setName("f");
//        args.get(5).setName("a");
//
//
//        args.get(6).setName("c");

        Set<BArgument> query = new HashSet<>();
//        query.add(args.get(0));
        query.add(args.get(1));
        query.add(args.get(6));

        ExactAnalysis analysis = new ExactAnalysis(peafTheory, new SimplePreferredReasoner());
        AnalysisResult result = analysis.query(query);
        result.print();


    }

}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/ExpandMCExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

import org.tweetyproject.arg.bipolar.inducers.ExactPEAFInducer;
import org.tweetyproject.arg.bipolar.inducers.LiExactPEAFInducer;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;

/**
 * Demonstrates the use of various PEAF (Probabilistic Evidential Argumentation Framework)
 * inducers to compute and display argumentation frameworks and their associated probabilities.
 * <p>
 * This example constructs a {@link PEAFTheory} with a set of arguments and support relationships,
 * prints the framework, and uses different inducers to process the framework and output the results.
 */
public class ExpandMCExample {

    /**
     * The entry point of the example program. Constructs a {@link PEAFTheory} instance,
     * adds arguments and support relationships, and utilizes two types of inducers to process
     * the framework. It prints the framework and the results obtained from using the
     * {@link LiExactPEAFInducer} and {@link ExactPEAFInducer}.
     * <p>
     * The following steps are performed in the main method:
     * <ol>
     *  <li>Create an instance of {@link PEAFTheory}.</li>
     *  <li>Add four arguments to the framework.</li>
     *  <li>Define and add support relationships between the arguments with associated probabilities.</li>
     *  <li>Print the framework using {@link PEAFTheory#prettyPrint()}.</li>
     *  <li>Create an instance of {@link LiExactPEAFInducer} and use it to induce and print the
     *  results along with the accumulated probability.</li>
     *  <li>Reset the probability and repeat the induction process with {@link ExactPEAFInducer},
     *  printing the results and the accumulated probability.</li>
     * </ol>
     *
     * @param args command-line arguments (not used in this example)
     */
    public static void main(String[] args) {
        PEAFTheory peafTheory = new PEAFTheory();
        for(int i = 0; i < 4; i++) {
        	peafTheory.addArgument(i);
        }

        peafTheory.addSupport(new HashSet<BArgument>(), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), 1.0);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), 0.8);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), 0.9);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), 0.9);

        peafTheory.prettyPrint();

        System.out.println("The LiExactPEAFInducer:");
        System.out.println();
        final double[] p = {0.0};
        LiExactPEAFInducer inducer = new LiExactPEAFInducer(peafTheory);
        inducer.induce(inducibleEAF -> {
            System.out.println(inducibleEAF);
            p[0] += inducibleEAF.getInducePro();
        });

        System.out.println("The result is: " + p[0]);
        p[0] = 0.0;

        System.out.println();
        System.out.println("The ExactPEAFInducer:");
        System.out.println();
        ExactPEAFInducer inducer2 = new ExactPEAFInducer(peafTheory);
        inducer2.induce(inducibleEAF -> {
            System.out.println(inducibleEAF);
            p[0] += inducibleEAF.getInducePro();
        });

        System.out.println("The result is: " + p[0]);
    }

    /** Default Constructor */
    public ExpandMCExample(){}
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/EvidentialArgumentation.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */


package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.reasoner.evidential.*;
import org.tweetyproject.arg.bipolar.syntax.*;

/**
 * More examples for evidential argumentation frameworks.
 */
public class EvidentialArgumentation {

    /**
     * Example
     * @param args the args
     */
    public static void main(String[] args) {
        // Example from Polberg, Oren. Revisiting Support in Abstract Argumentation Systems. 2014
        EvidentialArgumentationFramework et = new EvidentialArgumentationFramework();
        BArgument a = new BArgument("a");
        BArgument b = new BArgument("b");
        BArgument c = new BArgument("c");
        BArgument d = new BArgument("d");
        BArgument e = new BArgument("e");
        BArgument f = new BArgument("f");
        et.add(a);
        et.add(b);
        et.add(c);
        et.add(d);
        et.add(e);
        et.add(f);

        SetAttack att1 = new SetAttack(b, a);
        SetAttack att2 = new SetAttack(b, c);
        SetAttack att3 = new SetAttack(c, b);
        SetAttack att4 = new SetAttack(c, d);
        SetAttack att5 = new SetAttack(d, f);
        SetAttack att6 = new SetAttack(f, f);
        et.add(att1);
        et.add(att2);
        et.add(att3);
        et.add(att4);
        et.add(att5);
        et.add(att6);

        SetSupport supp1 = new SetSupport(d, e);
        et.add(supp1);

        et.addPrimaFacie(b);
        et.addPrimaFacie(c);
        et.addPrimaFacie(d);
        et.addPrimaFacie(f);

        System.out.println("Self-Supporting extensions: " + new SelfSupportingReasoner().getModels(et));
        System.out.println("Conflict-Free extensions: " + new ConflictFreeReasoner().getModels(et));
        System.out.println("Admissible extensions: " + new AdmissibleReasoner().getModels(et));
        System.out.println("Grounded extensions: " + new GroundedReasoner().getModels(et));
        System.out.println("Complete extensions: " + new CompleteReasoner().getModels(et));
        System.out.println("Preferred extensions: " + new PreferredReasoner().getModels(et));
        System.out.println("Stable extensions: " + new StableReasoner().getModels(et));
    }

    /** Default Constructor */
    public EvidentialArgumentation(){}
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/EvidentialAcceptability.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */


package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.syntax.*;

import java.util.HashSet;
import java.util.Set;

/**
 * Demonstrates the use of evidential argumentation frameworks.
 * <p>
 * This example shows how to construct an instance of {@link EvidentialArgumentationFramework},
 * add arguments, support, and attack relationships, and check the acceptability of arguments
 * with respect to a given set of arguments.
 * It also prints the framework in a human-readable format.
 */
public class EvidentialAcceptability {

    /**
     * The entry point of the example program. Constructs an {@link EvidentialArgumentationFramework} instance,
     * adds arguments, defines support and attack relationships, specifies prima facie arguments, and checks
     * the acceptability of various arguments with respect to a specified set of arguments.
     *
     * @param args command-line arguments (not used in this example)
     */
    public static void main(String[] args) {
        EvidentialArgumentationFramework et = new EvidentialArgumentationFramework();
        BArgument a = new BArgument("a");
        BArgument b = new BArgument("b");
        BArgument c = new BArgument("c");
        BArgument d = new BArgument("d");
        BArgument e = new BArgument("e");
        BArgument f = new BArgument("f");
        et.add(a);
        et.add(b);
        et.add(c);
        et.add(d);
        et.add(e);
        et.add(f);
        SetAttack att1 = new SetAttack(a, f);
        SetAttack att2 = new SetAttack(b, e);
        SetAttack att3 = new SetAttack(d, c);
        SetAttack att4 = new SetAttack(c, e);
        SetSupport supp1 = new SetSupport(f, b);
        SetSupport supp2 = new SetSupport(d, e);
        et.add(att1);
        et.add(att2);
        et.add(att3);
        et.add(att4);
        et.add(supp1);
        et.add(supp2);


        et.addPrimaFacie(a);
        et.addPrimaFacie(c);
        et.addPrimaFacie(d);
        et.addPrimaFacie(f);


        System.out.println(et.prettyPrint());

        Set<BArgument> s1 = new HashSet<>();
        s1.add(et.getEta());
        s1.add(a);
        s1.add(d);

        System.out.println("Argument a is acceptable wrt. " + s1 + ": " + et.isAcceptable(a, s1));
        System.out.println("Argument b is acceptable wrt. " + s1 + ": " + et.isAcceptable(b, s1));
        System.out.println("Argument c is acceptable wrt. " + s1 + ": " + et.isAcceptable(c, s1));
        System.out.println("Argument d is acceptable wrt. " + s1 + ": " + et.isAcceptable(d, s1));
        System.out.println("Argument e is acceptable wrt. " + s1 + ": " + et.isAcceptable(e, s1));
        System.out.println("Argument f is acceptable wrt. " + s1 + ": " + et.isAcceptable(f, s1));

    }

    /** Default Constructor */
    public EvidentialAcceptability(){}
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/EasyPEAFExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

import org.tweetyproject.arg.bipolar.inducers.LiExactPEAFInducer;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;
/**
 * Provides an example of constructing a Probabilistic Argumentation Framework (PEAFTheory), adding support relationships,
 * and inducing extensions using a specific inducer.
 * <p>
 * This example demonstrates the creation of a PEAFTheory instance with two arguments, setting up support relationships
 * with specified probabilities, and then inducing extensions of the framework using the {@link LiExactPEAFInducer}.
 */
public class EasyPEAFExample {

    /**
     * The entry point of the example program. Constructs a {@link PEAFTheory} instance, adds arguments, defines support
     * relationships with associated probabilities, prints the framework, and induces extensions using the
     * {@link LiExactPEAFInducer}.
     * <p>
     * The following steps are performed in the main method:
     * <ol>
     *  <li>Create an instance of {@link PEAFTheory}.</li>
     *  <li>Add two arguments to the framework.</li>
     *  <li>Define support relationships between the arguments with specified probabilities.</li>
     *  <li>Print the framework in a human-readable format using {@link PEAFTheory#prettyPrint()}.</li>
     *  <li>Induce extensions of the framework using {@link LiExactPEAFInducer} and print each induced extension.</li>
     * </ol>
     *
     * @param args command-line arguments (not used in this example)
     */
    public static void main(String[] args) {
        PEAFTheory peafTheory = new PEAFTheory();
        peafTheory.addArgument(0);
        peafTheory.addArgument(1);


        peafTheory.addSupport(new HashSet<BArgument>(), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), 1.0);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), 0.3);


        peafTheory.prettyPrint();
        LiExactPEAFInducer inducer = new LiExactPEAFInducer(peafTheory);

        inducer.induce(ind -> {
            System.out.println(ind);


        });
    }

    /** Default Constructor */
    public EasyPEAFExample(){}
}

org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/EAFExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

import org.tweetyproject.arg.bipolar.io.EdgeListWriter;
import org.tweetyproject.arg.bipolar.syntax.*;

/**
 * Provides an example of constructing an Argumentation Framework (EAFTheory) and saving its representation to a file.
 * <p>
 * This example demonstrates the creation of an argumentation framework with eight arguments, setting up various support
 * and attack relationships between these arguments, and finally writing the resulting framework to a file.
 */
public class EAFExample {

    /**
     * The entry point of the example program. Constructs an {@link EAFTheory} instance, adds arguments, support, and attack
     * relationships, and writes the framework to a file.
     * <p>
     * The following steps are performed in the main method:
     * <ol>
     *  <li>Create an instance of {@link EAFTheory}.</li>
     *  <li>Add eight arguments to the framework.</li>
     *  <li>Define support relationships between various sets of arguments.</li>
     *  <li>Define attack relationships between specific arguments.</li>
     *  <li>Print the string representation of the framework to the console.</li>
     *  <li>Write the framework to a file named "eaf.txt" using {@link EdgeListWriter}.</li>
     * </ol>
     *
     * @param _args command-line arguments (not used in this example)
     */
    public static void main(String[] _args) {
        int numOfArgs = 8;

        EAFTheory eafTheory = new EAFTheory();

        for (int i = 0; i < numOfArgs; i++) {
            eafTheory.addArgument(i);
        }

        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(1)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(3)))));
        HashSet<BArgument> args1 = new HashSet<BArgument>();
        args1.add(eafTheory.getArguments().get(1));
        args1.add(eafTheory.getArguments().get(3));
        eafTheory.addSupport(args1, new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(3)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(5)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(6)))));
        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(6)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(7)))));
        HashSet<BArgument> args2 = new HashSet<BArgument>();
        args2.add(eafTheory.getArguments().get(5));
        args2.add(eafTheory.getArguments().get(7));
        eafTheory.addSupport(args2, new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(4)))));

        eafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(5)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(4)))));
        eafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(6)))));

        System.out.println(eafTheory.toString());

        EdgeListWriter.write("eaf.txt", eafTheory);
    }

    /**
     * Default constructor for the {@code EAFExample} class.
     * Initializes an instance of this class. This constructor does not perform any specific initialization.
     */
    public EAFExample() {}
}


org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/DeductiveArgumentation.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */


package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.reasoner.deductive.*;
import org.tweetyproject.arg.bipolar.syntax.*;
import org.tweetyproject.arg.dung.reasoner.SimpleCompleteReasoner;
import org.tweetyproject.arg.dung.reasoner.SimpleGroundedReasoner;
import org.tweetyproject.arg.dung.reasoner.SimplePreferredReasoner;
import org.tweetyproject.arg.dung.reasoner.SimpleStableReasoner;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.logics.pl.sat.Sat4jSolver;
import org.tweetyproject.logics.pl.sat.SatSolver;

/**
 * Demonstrates the construction of deductive argumentation frameworks and the computation of their extensions.
 * <p>
 * This example uses the Deductive Argumentation Framework to create an argumentation framework, add arguments and relationships,
 * and then compute various types of extensions. The example framework and its associated Dung theory are used to compute extensions
 * using different reasoners.
 * <p>
 * The example is based on the work by Cayrol and Lagasquie-Schiex on bipolarity in argumentation graphs.
 */
public class DeductiveArgumentation {

    /**
     * The entry point of the example program. Constructs a deductive argumentation framework, adds arguments, attacks, and supports,
     * and computes various types of extensions using different reasoners.
     * <p>
     * The following steps are performed in the main method:
     * <ol>
     *  <li>Create a {@link DeductiveArgumentationFramework} instance.</li>
     *  <li>Add four arguments to the framework.</li>
     *  <li>Add one attack and two support relationships between the arguments.</li>
     *  <li>Obtain the associated Dung theory and meta-framework for the deductive argumentation framework.</li>
     *  <li>Set the default SAT solver to {@link Sat4jSolver}.</li>
     *  <li>Compute and print the closed extensions and safe extensions using the {@link ClosureReasoner} and {@link SafetyReasoner}.</li>
     *  <li>Compute and print the preferred, grounded, and stable extensions for the Dung theory using the {@link SimplePreferredReasoner}, {@link SimpleGroundedReasoner}, and {@link SimpleStableReasoner}.</li>
     *  <li>Compute and print the complete extensions for both the Dung theory and the meta-framework using the {@link SimpleCompleteReasoner}.</li>
     * </ol>
     *
     * @param args command-line arguments (not used)
     */
    public static void main(String[] args) {
        // Example from Cayrol, Lagasquie-Schiex. Bipolarity in argumentation graphs: Towards a better understanding. 2013
        DeductiveArgumentationFramework at = new DeductiveArgumentationFramework();
        BArgument a = new BArgument("a");
        BArgument b = new BArgument("b");
        BArgument c = new BArgument("c");
        BArgument x = new BArgument("x");
        at.add(a);
        at.add(b);
        at.add(c);
        at.add(x);

        Attack att1 = new BinaryAttack(x, c);
        at.add(att1);

        Support supp1 = new BinarySupport(a, x);
        Support supp2 = new BinarySupport(b, c);
        at.add(supp1);
        at.add(supp2);

        DungTheory dt = at.getCompleteAssociatedDungTheory();
        DungTheory mt = at.getMetaFramework();

        SatSolver.setDefaultSolver(new Sat4jSolver());

        System.out.println("Closed extensions at: " + new ClosureReasoner().getModels(at));
        System.out.println("Safe extensions at: " + new SafetyReasoner().getModels(at));

        System.out.println("Preferred extensions: " + new SimplePreferredReasoner().getModels(dt));
        System.out.println("Grounded extensions: " + new SimpleGroundedReasoner().getModels(dt));
        System.out.println("Stable extensions: " + new SimpleStableReasoner().getModels(dt));

        System.out.println("Complete extensions dt: " + new SimpleCompleteReasoner().getModels(dt));
        System.out.println("Complete extensions mt: " + new SimpleCompleteReasoner().getModels(mt));
    }

    /**
     * Default constructor for the {@code DeductiveArgumentation} class.
     * Initializes an instance of this class, though it currently has no specific initialization logic.
     */
    public DeductiveArgumentation() {}
}


org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/CheckIfSelfSupportingExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.syntax.EAFTheory;
import org.tweetyproject.arg.bipolar.syntax.BArgument;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * This class demonstrates the use of the {@link EAFTheory} class to check for self-supporting sets of arguments.
 * <p>
 * In this example, an extended argumentation framework (EAF) is created with a set of arguments and supports/attacks between them.
 * The goal is to check whether certain sets of arguments are self-supporting using the {@code checkIsSelfSupporting} method
 * of the {@link EAFTheory} class.
 * <p>
 * @author Your Name
 */
public class CheckIfSelfSupportingExample {

    /**
     * The entry point of the example program that sets up an {@link EAFTheory} instance,
     * adds arguments, defines supports and attacks, and checks whether various sets of arguments
     * are self-supporting.
     *
     * @param args command-line arguments (not used)
     */
    public static void main(String[] args) {
        EAFTheory eafTheory = new EAFTheory();
        for (int i = 0; i < 4; i++) {
            eafTheory.addArgument(i);
        }

        // Arguments:
        // eta = 0, a = 1, b = 2, c = 3

        eafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(eafTheory.getArguments().get(0)))), new HashSet<BArgument>(Arrays.asList(eafTheory.getArguments().get(1))));
        eafTheory.addSupport(new HashSet<BArgument>(Arrays.asList(eafTheory.getArguments().get(0))), new HashSet<BArgument>(Arrays.asList(eafTheory.getArguments().get(2))));
        eafTheory.addAttack(new HashSet<BArgument>(Arrays.asList(eafTheory.getArguments().get(2))), new HashSet<BArgument>(Arrays.asList(eafTheory.getArguments().get(1))));
        eafTheory.addSupport(new HashSet<BArgument>(Arrays.asList(eafTheory.getArguments().get(1))), new HashSet<BArgument>(Arrays.asList(eafTheory.getArguments().get(3))));

        List<BArgument> eArguments = eafTheory.getArguments();
        Set<BArgument> selfSupported = new HashSet<>();

        // Various checks for self-supporting sets of arguments
        selfSupported.add(eArguments.get(0));
        System.out.println("{eta} is " + eafTheory.checkIsSelfSupporting(selfSupported) + ", but must be true");
        selfSupported.clear();

        selfSupported.add(eArguments.get(2));
        System.out.println("{b} is " + eafTheory.checkIsSelfSupporting(selfSupported) + ", but must be false");
        selfSupported.clear();

        selfSupported.add(eArguments.get(1));
        selfSupported.add(eArguments.get(2));
        System.out.println("{a, b} is " + eafTheory.checkIsSelfSupporting(selfSupported) + ", but must be false");
        selfSupported.clear();

        selfSupported.add(eArguments.get(0));
        selfSupported.add(eArguments.get(1));
        selfSupported.add(eArguments.get(3));
        System.out.println("{eta, a, c} is " + eafTheory.checkIsSelfSupporting(selfSupported) + ", but must be true");
        selfSupported.clear();

        selfSupported.add(eArguments.get(0));
        selfSupported.add(eArguments.get(2));
        System.out.println("{eta, b} is " + eafTheory.checkIsSelfSupporting(selfSupported) + ", but must be true");

        selfSupported.add(eArguments.get(0));
        selfSupported.add(eArguments.get(3));
        System.out.println("{eta, c} is " + eafTheory.checkIsSelfSupporting(selfSupported) + ", but must be false");
    }

    /**
     * Default constructor for the {@code CheckIfSelfSupportingExample} class.
     * Initializes an instance of this class, though it currently has no specific initialization logic.
     */
    public CheckIfSelfSupportingExample() {}
}


org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/ApproximateJustificationAnalysisExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.analysis.AnalysisResult;
import org.tweetyproject.arg.bipolar.analysis.ApproxAnalysis;
import org.tweetyproject.arg.bipolar.analysis.ExactAnalysis;
import org.tweetyproject.arg.dung.reasoner.SimplePreferredReasoner;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Demonstrates the use of exact and approximate justification analysis on a PEAFTheory.
 * <p>
 * This example sets up a PEAFTheory with a number of arguments, defines supports and attacks among them,
 * and then performs exact and approximate analyses to justify a specific argument.
 * </p>
 */
public class ApproximateJustificationAnalysisExample {

    /**
     * Example
     * @param args the args
     */
    public static void main(String[] args) {
        int numOfArgs = 7;  // Number of arguments to add to the PEAFTheory
        PEAFTheory peafTheory = new PEAFTheory();

        // Add arguments to the theory
        for (int i = 0; i < numOfArgs; i++) {
            peafTheory.addArgument(i);
        }

        // Define supports among arguments with associated probabilities
        peafTheory.addSupport(
            new HashSet<>(),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            1.0
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(2))),
            0.6
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1))),
            0.7
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(3))),
            0.9
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(0))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(4))),
            0.3
        );
        peafTheory.addSupport(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(3))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5))),
            0.5
        );

        // Define supports involving multiple arguments
        Set<BArgument> argSet = new HashSet<>();
        argSet.add(peafTheory.getArguments().get(3));
        argSet.add(peafTheory.getArguments().get(4));
        peafTheory.addSupport(
            argSet,
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(6))),
            0.9
        );

        // Define attack relationships among arguments
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(2)))
        );
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1)))
        );
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(5)))
        );
        peafTheory.addAttack(
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(1))),
            new HashSet<>(Arrays.asList(peafTheory.getArguments().get(6)))
        );

        // Define the query for analysis
        Set<BArgument> query = new HashSet<>();
        query.add(peafTheory.getArguments().get(0));

        // Perform exact analysis
        ExactAnalysis exactAnalysis = new ExactAnalysis(peafTheory, new SimplePreferredReasoner());
        AnalysisResult exactResult = exactAnalysis.query(query);
        exactResult.print();

        // Perform approximate analysis
        ApproxAnalysis approxAnalysis = new ApproxAnalysis(peafTheory, new SimplePreferredReasoner(), 0.1);
        AnalysisResult approxResult = approxAnalysis.query(query);
        approxResult.print();
    }

    /** Default Constructor */
    public ApproximateJustificationAnalysisExample() {}
}


org-tweetyproject-arg-bipolar/src/main/java/org/tweetyproject/arg/bipolar/examples/AllPEAFInducerExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.bipolar.examples;

import org.tweetyproject.arg.bipolar.inducers.LiExactPEAFInducer;
import org.tweetyproject.arg.bipolar.io.EdgeListWriter;
import org.tweetyproject.arg.bipolar.syntax.BArgument;
import org.tweetyproject.arg.bipolar.syntax.PEAFTheory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.concurrent.atomic.AtomicInteger;


/**
 * Example class demonstrating the use of the PEAF (Preference-based Argumentation Framework) inducer.
 * <p>
 * This example sets up a PEAF theory with a specified number of arguments, adds various support and attack relationships
 * between the arguments, and then uses the `LiExactPEAFInducer` to induce new EAF (Argumentation Framework) theories from the
 * given PEAF theory. The results are printed and saved to files.
 * </p>
 */
public class AllPEAFInducerExample {
       /**
     * Main method to run the example.
     * <p>
     * This method initializes a PEAF theory with a set number of arguments, defines support and attack relationships,
     * and uses the `LiExactPEAFInducer` to induce new EAF theories. It prints each induced EAF and saves it to a file.
     * </p>
     *
     * @param args Command line arguments (not used in this example).
     */
    public static void main(String[] args) {
        int numOfArgs = 8;


        PEAFTheory peafTheory = new PEAFTheory();

        for (int i = 0; i < numOfArgs; i++) {
            peafTheory.addArgument(i);
        }

        peafTheory.addSupport(new HashSet<BArgument>(), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), 1.0);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(0)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), 0.3);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), 0.8);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(1)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), 0.9);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(4)))), 0.85);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))), 0.5);
        peafTheory.addSupport(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(3)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(6)))), 0.6);
        HashSet<BArgument> myArgs = new HashSet<BArgument>();
        myArgs.add(peafTheory.getArguments().get(5));
        myArgs.add(peafTheory.getArguments().get(4));
        peafTheory.addSupport(myArgs, new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(7)))), 0.4);

        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(5)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(4)))));
        peafTheory.addAttack(new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(2)))), new HashSet<BArgument>(new ArrayList<BArgument>(Arrays.asList(peafTheory.getArguments().get(6)))));

        peafTheory.prettyPrint();

        EdgeListWriter.write("0.peaf", peafTheory);

        AtomicInteger i = new AtomicInteger();
        LiExactPEAFInducer inducer = new LiExactPEAFInducer(peafTheory);

        inducer.induce(ind -> {
            int n = i.getAndIncrement();
            System.out.println(ind);
            EdgeListWriter.write(n + ".eaf", ind.toNewEAFTheory());

        });

    }

    /** Default Constructor */
    public AllPEAFInducerExample(){}
}

org-tweetyproject-arg-aspic/src/main/resources/ex5_fol.aspic

=> snores(bob)
=> snores(alice)
=> professor(bob)

d0: accessDenied(X) => !accessAllowed(X)

d1: snores(X) => misbehaves(X)
d2: misbehaves(X) => accessDenied(X)
d3: professor(X) => accessAllowed(X)

d1 < d2 < d3



org-tweetyproject-arg-aspic/src/main/resources/ex1.aspic

d1: p => q
d2: s => t
d3: t => ! d1
d4: u => v
d5: v, x => ! t
d6: s => ! p
s1: p, q -> r
s2: v -> ! s

-> p
=> s
=> u
=> x

org-tweetyproject-arg-aspic/src/main/java/org/tweetyproject/arg/aspic/examples/DirectionalReasonerTest.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.aspic.examples;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.tweetyproject.arg.aspic.reasoner.DirectionalAspicReasoner;
import org.tweetyproject.arg.aspic.reasoner.ModuleBasedAspicReasoner;
import org.tweetyproject.arg.aspic.syntax.AspicArgumentationTheory;
import org.tweetyproject.arg.aspic.util.RandomAspicArgumentationTheoryGenerator;
import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.commons.InferenceMode;
import org.tweetyproject.commons.util.Pair;
import org.tweetyproject.logics.pl.syntax.Proposition;
import org.tweetyproject.logics.pl.syntax.PlFormula;

/**
 * Test runtime of module-based vs. directional reasoners.
 * 
 * Also checks if they give the same answers
 * 
 * @author Tjitze Rienstra
 *
 */
public class DirectionalReasonerTest {
	/**
	 * 
	 * @param args args
	 */
	public static void main(String[] args) {		 
		int repetitions = 5000;
		int numberAtoms = 65;
		int numberFormulas = 120;
		int maxLiteralsInPremises = 3;
		double percentageStrictRules = 0.2;
		
		ModuleBasedAspicReasoner<PlFormula> moduleReasoner = new ModuleBasedAspicReasoner<PlFormula>(AbstractExtensionReasoner.getSimpleReasonerForSemantics(Semantics.GR));
		DirectionalAspicReasoner<PlFormula> directionalReasoner = new DirectionalAspicReasoner<PlFormula>(AbstractExtensionReasoner.getSimpleReasonerForSemantics(Semantics.GR));
		
		long totalTimeModuleBased = 0;
		long totalTimeDirectional = 0;
		long totalArgsModuleBased = 0;
		long totalArgsDirectional = 0;
		long totalTrue = 0;
		RandomAspicArgumentationTheoryGenerator gen = new RandomAspicArgumentationTheoryGenerator(numberAtoms, numberFormulas, maxLiteralsInPremises, percentageStrictRules);		
		for(int i = 0; i < repetitions; i++) {
			AspicArgumentationTheory<PlFormula> theory = gen.next();
			System.out.println(i + "\t" + theory);
			PlFormula query = new Proposition("A1");
			
			// Skip instances taking longer than 10sec
			System.out.println("Module-based...");
			boolean answer1 = false;
			try {
				Pair<Long, Pair<Integer, Boolean>> res = runWithTimeout(new Callable<Pair<Long, Pair<Integer, Boolean>>>() {
					@Override
					public Pair<Long, Pair<Integer, Boolean>> call() throws Exception {
						long millis = System.currentTimeMillis();
						DungTheory af1 = moduleReasoner.getDungTheory(theory, query);
						boolean answer1 = moduleReasoner.query(af1, query, InferenceMode.CREDULOUS);
						return new Pair<Long, Pair<Integer, Boolean>>(millis, new Pair<Integer, Boolean>(af1.getNumberOfNodes(), answer1));
					}
				}, 10, TimeUnit.SECONDS);
				totalTimeModuleBased += System.currentTimeMillis()-res.getFirst();
				totalArgsModuleBased += res.getSecond().getFirst();
				answer1 = res.getSecond().getSecond();
				if (res.getSecond().getSecond()) totalTrue++;
			} catch (Exception e) {
				System.out.println("Timeout... skipping");
				continue;
			}
				
			System.out.println("Directional...");
			long millis = System.currentTimeMillis();
			DungTheory af2 = directionalReasoner.getDungTheory(theory, query);
			boolean answer2 = directionalReasoner.query(af2, query, InferenceMode.CREDULOUS);
			totalTimeDirectional += System.currentTimeMillis()-millis;
			totalArgsDirectional += af2.getNumberOfNodes();
			
			if (answer1 != answer2) {
				System.out.println("Module-based and directional reasoners gave different answers");
				System.out.println("Module-based answer: " + answer1 + " directional answer: " + answer2);
				System.out.println("Query: " + query);
				System.out.println("Theory: " + theory.toString());
				throw new RuntimeException();
			}
			millis = System.currentTimeMillis();
		}	
		System.out.println();
		System.out.println("Runtime module-based        : " + totalTimeModuleBased + "ms");
		System.out.println("Argument count module-based : " + totalArgsModuleBased);
		System.out.println("Runtime directional         : " + totalTimeDirectional+ "ms");
		System.out.println("Argument count directiona   : " + totalArgsDirectional);
		System.out.println("Queries returning accepted  : " + totalTrue + "/" + repetitions);
	}

//	private static void printAF(DungTheory af) {
//		for (Argument a: af) {
//			System.out.println("arg: " + a);
//		}
//		for (Attack a: af.getAttacks()) {
//			System.out.println("att: " + a);
//		}
//	}
  /**
   * 
   * @param <T> some callable object
   * @param callable callable object
   * @param timeout timeout for runtime
   * @param timeUnit unit for timeout
   * @return directional reasoner result
   * @throws Exception exception
   */
  public static <T> T runWithTimeout(Callable<T> callable, long timeout, TimeUnit timeUnit) throws Exception {
    final ExecutorService executor = Executors.newSingleThreadExecutor();
    final Future<T> future = executor.submit(callable);
    executor.shutdown(); // This does not cancel the already-scheduled task.
    try {
      return future.get(timeout, timeUnit);
    }
    catch (TimeoutException e) {
      //remove this if you do not want to cancel the job in progress
      //or set the argument to 'false' if you do not want to interrupt the thread
      future.cancel(true);
      throw e;
    }
    catch (ExecutionException e) {
      //unwrap the root cause
      Throwable t = e.getCause();
      if (t instanceof Error) {
        throw (Error) t;
      } else if (t instanceof Exception) {
        throw (Exception) t;
      } else {
        throw new IllegalStateException(t);
      }
    }
  }

	
}

org-tweetyproject-arg-aspic/src/main/java/org/tweetyproject/arg/aspic/examples/AspicGeneratorExample2.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.aspic.examples;

import java.io.File;
import java.io.IOException;

import org.tweetyproject.arg.aspic.syntax.AspicArgumentationTheory;
import org.tweetyproject.arg.aspic.util.RandomAspicArgumentationTheoryGenerator;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.dung.writer.ApxWriter;
import org.tweetyproject.arg.dung.writer.TgfWriter;
import org.tweetyproject.logics.pl.syntax.PlFormula;

/**
 * This code shows the use of the ASPIC theory generator. It generates some random ASPIC
 * theories, constructs the corresponding AF graphs, and writes them to a specific folder.
 * 
 * @author Matthias Thimm
 */
public class AspicGeneratorExample2 {
	/**
	 * 
	 * @param args command lien args
	 * @throws IOException exception
	 */
	public static void main(String[] args) throws IOException {
		int numberAtoms = 18;
		int numberFormulas = 80;
		int maxLiteralsInPremises = 2;
		double percentageStrictRules = 1;
		int numberOfAFs = 100;
		String pathToExportFolder = "/Users/mthimm/Desktop/aspic";
		ApxWriter apx = new ApxWriter();
		TgfWriter tgf = new TgfWriter();
		
		RandomAspicArgumentationTheoryGenerator gen = new RandomAspicArgumentationTheoryGenerator(numberAtoms, numberFormulas, maxLiteralsInPremises, percentageStrictRules);
		
		for(int i = 0; i < numberOfAFs; i++) {
			AspicArgumentationTheory<PlFormula> theory = gen.next();
			DungTheory aaf = theory.asDungTheory(true);
			System.out.println(aaf);
			apx.write(aaf, new File(pathToExportFolder + "/aspic_" + numberAtoms + "_" + numberFormulas + "_" + maxLiteralsInPremises + "_" + percentageStrictRules + "__" + i + ".apx" ));
			tgf.write(aaf, new File(pathToExportFolder + "/aspic_" + numberAtoms + "_" + numberFormulas + "_" + maxLiteralsInPremises + "_" + percentageStrictRules + "__" + i + ".tgf" ));			
		}		
	}
}

org-tweetyproject-arg-aspic/src/main/java/org/tweetyproject/arg/aspic/examples/AspicExampleFol.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.aspic.examples;

import java.io.IOException;

import org.tweetyproject.arg.aspic.parser.AspicParser;
import org.tweetyproject.arg.aspic.reasoner.SimpleAspicReasoner;
import org.tweetyproject.arg.aspic.ruleformulagenerator.FolFormulaGenerator;
import org.tweetyproject.arg.aspic.syntax.AspicArgumentationTheory;
import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.commons.InferenceMode;
import org.tweetyproject.commons.ParserException;
import org.tweetyproject.logics.fol.parser.FolParser;
import org.tweetyproject.logics.fol.syntax.FolFormula;
import org.tweetyproject.logics.fol.syntax.FolSignature;

/**
 * Example code for using ASPIC with first-order-logic formulas.
 * 
 * @author Anna Gessler
 *
 */
public class AspicExampleFol {
	/**
	 * 
	 * @param args command line arguments
	 * @throws ParserException exception
	 * @throws IOException exception
	 */
	public static void main(String[] args) throws ParserException, IOException {
		// FOL Example
		FolParser folparser = new FolParser();
		FolSignature sig = folparser.parseSignature("Person = {alice,bob}\n" + 
				"type(snores(Person))\n" + 
				"type(professor(Person))\n" + 
				"type(accessDenied(Person))\n" + 
				"type(accessAllowed(Person))\n" + 
				"type(misbehaves(Person))");
		folparser.setSignature(sig);
		AspicParser<FolFormula> parser2 = new AspicParser<FolFormula>(folparser, new FolFormulaGenerator());
		parser2.setSymbolComma(";");
		
		AspicArgumentationTheory<FolFormula> at = parser2.parseBeliefBaseFromFile(AspicExampleFol.class.getResource("/ex5_fol.aspic").getFile());		
		SimpleAspicReasoner<FolFormula> ar = new SimpleAspicReasoner<FolFormula>(AbstractExtensionReasoner.getSimpleReasonerForSemantics(Semantics.CONFLICTFREE_SEMANTICS));
		FolFormula pf = (FolFormula)folparser.parseFormula("accessDenied(bob)");	
		
		System.out.println(at.asDungTheory());
		System.out.println(pf + "\t" + ar.query(at,pf,InferenceMode.CREDULOUS));
	}
}

org-tweetyproject-arg-aspic/src/main/java/org/tweetyproject/arg/aspic/examples/AspicExample2.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.aspic.examples;

import java.io.FileNotFoundException;
import java.io.IOException;

import org.tweetyproject.arg.aspic.parser.AspicParser;
import org.tweetyproject.arg.aspic.reasoner.SimpleAspicReasoner;
import org.tweetyproject.arg.aspic.ruleformulagenerator.PlFormulaGenerator;
import org.tweetyproject.arg.aspic.syntax.AspicArgumentationTheory;
import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.commons.InferenceMode;
import org.tweetyproject.commons.ParserException;
import org.tweetyproject.logics.pl.parser.PlParser;
import org.tweetyproject.logics.pl.syntax.PlFormula;

/**
 * ASPIC example code that shows how to parse an ASPIC file and ask queries.
 * 
 * @author Matthias Thimm
 *
 */
public class AspicExample2 {
	/**
	 * 
	 * @param args command lone arguments
	 * @throws FileNotFoundException exception
	 * @throws ParserException exception
	 * @throws IOException exception
	 */
	public static void main(String[] args) throws FileNotFoundException, ParserException, IOException{
		PlParser plparser = new PlParser();
		AspicParser<PlFormula> parser = new AspicParser<>(plparser, new PlFormulaGenerator());
		AspicArgumentationTheory<PlFormula> at = parser.parseBeliefBaseFromFile(AspicExample2.class.getResource("/ex1.aspic").getFile());		
		SimpleAspicReasoner<PlFormula> ar = new SimpleAspicReasoner<PlFormula>(AbstractExtensionReasoner.getSimpleReasonerForSemantics(Semantics.CONFLICTFREE_SEMANTICS));
		PlFormula pf = (PlFormula)plparser.parseFormula("p");		
		System.out.println(at);
		System.out.println(pf + "\t" + ar.query(at,pf,InferenceMode.CREDULOUS));		
	}
}

org-tweetyproject-arg-aspic/src/main/java/org/tweetyproject/arg/aspic/examples/AspicExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.aspic.examples;

import org.tweetyproject.arg.aspic.ruleformulagenerator.PlFormulaGenerator;
import org.tweetyproject.arg.aspic.syntax.AspicArgumentationTheory;
import org.tweetyproject.arg.aspic.syntax.DefeasibleInferenceRule;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.logics.pl.syntax.Negation;
import org.tweetyproject.logics.pl.syntax.Proposition;
import org.tweetyproject.logics.pl.syntax.PlFormula;

/**
 * ASPIC example code that shows how to construct an ASPIC theory programmatically.
 * 
 * @author Matthias Thimm
 *
 */
public class AspicExample {
	/**
	 * 
	 * @param args command line arguments
	 */
	public static void main(String[] args){
		Proposition a = new Proposition("a");
		Proposition b = new Proposition("b");
		Proposition c = new Proposition("c");
		Proposition d = new Proposition("d");
		
		AspicArgumentationTheory<PlFormula> t = new AspicArgumentationTheory<>(new PlFormulaGenerator());
		t.setRuleFormulaGenerator(new PlFormulaGenerator());
		
		DefeasibleInferenceRule<PlFormula> r1 = new DefeasibleInferenceRule<>();
		r1.setConclusion(a);
		r1.addPremise(b);
		r1.addPremise(c);
		t.addRule(r1);
		
		r1 = new DefeasibleInferenceRule<>();
		r1.setConclusion(d);
		r1.addPremise(b);
		t.addRule(r1);
		
		r1 = new DefeasibleInferenceRule<>();
		r1.setConclusion(new Negation(d));
		r1.addPremise(a);
		t.addRule(r1);
		
		t.addAxiom(b);
		t.addAxiom(c);
		
		
		System.out.println(t);
		System.out.println();
		
		DungTheory aaf = t.asDungTheory();
		
		for(Argument arg: aaf)
			System.out.println(arg);
		
		System.out.println();
		
		for(Attack att: aaf.getAttacks())
			System.out.println(att);	
		
	}
}

org-tweetyproject-beliefdynamics/src/main/java/org/tweetyproject/beliefdynamics/examples/CrMasExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.beliefdynamics.examples;

import java.io.*;
import java.util.*;

import org.tweetyproject.agents.*;
import org.tweetyproject.beliefdynamics.*;
import org.tweetyproject.beliefdynamics.kernels.*;
import org.tweetyproject.beliefdynamics.mas.*;
import org.tweetyproject.beliefdynamics.operators.*;
import org.tweetyproject.commons.*;
import org.tweetyproject.logics.pl.parser.*;
import org.tweetyproject.logics.pl.reasoner.SimplePlReasoner;
import org.tweetyproject.logics.pl.syntax.*;
import org.tweetyproject.comparator.Order;

/**
 * Example code on using belief operators in multi-agent settings.
 * @author Matthias Thimm
 *
 */
public class CrMasExample {
	/** Default */
	public CrMasExample() {
	}

	/**
	 * Example method
	 * @param args the args
	 * @throws ParserException error
	 * @throws IOException error
	 */
	public static void main(String[] args) throws ParserException, IOException{

		PlParser parser = new PlParser();

		// some agents
		List<Agent> agents = new ArrayList<Agent>();
		agents.add(new DummyAgent("A1"));
		agents.add(new DummyAgent("A2"));
		agents.add(new DummyAgent("A3"));

		// some credibility order A3 < A2 < A1 (A1 is most credible)
		Order<Agent> credOrder = new Order<Agent>(agents);
		credOrder.setOrderedBefore(agents.get(0), agents.get(1));
		credOrder.setOrderedBefore(agents.get(1), agents.get(2));

		// a belief base (we use propositional logic)
		CrMasBeliefSet<PlFormula,PlSignature> bs = new CrMasBeliefSet<PlFormula,PlSignature>(credOrder, new PlSignature());
		bs.add(new InformationObject<PlFormula>((PlFormula) parser.parseFormula("!c"), agents.get(1)));
		bs.add(new InformationObject<PlFormula>((PlFormula) parser.parseFormula("b"), agents.get(2)));
		bs.add(new InformationObject<PlFormula>((PlFormula) parser.parseFormula("!b||!a"), agents.get(2)));

		// some new information
		Collection<InformationObject<PlFormula>> newInformation = new HashSet<InformationObject<PlFormula>>();
		newInformation.add(new InformationObject<PlFormula>((PlFormula) parser.parseFormula("a"), agents.get(2)));
		newInformation.add(new InformationObject<PlFormula>((PlFormula) parser.parseFormula("!a||c"), agents.get(2)));

		System.out.println(bs + " * " + newInformation);
		System.out.println();

		// simple prioritized revision (without considering credibilities)
		CrMasRevisionWrapper<PlFormula> rev = new CrMasRevisionWrapper<PlFormula>(
				new LeviMultipleBaseRevisionOperator<PlFormula>(
						new KernelContractionOperator<PlFormula>(new RandomIncisionFunction<PlFormula>(), new SimplePlReasoner()),
						new DefaultMultipleBaseExpansionOperator<PlFormula>()
						));
		System.out.println("PRIO       :\t " + rev.revise(bs, newInformation));

		// simple non-prioritized revision (with credibilities)
		CrMasSimpleRevisionOperator rev2 = new CrMasSimpleRevisionOperator();
		System.out.println("N-PRIO CRED:\t " + rev2.revise(bs, newInformation));

		// credibility-based argumentative revision
		CrMasArgumentativeRevisionOperator theRevision = new CrMasArgumentativeRevisionOperator();
		System.out.println("ARG        :\t " + theRevision.revise(bs, newInformation));

	}
}

org-tweetyproject-action/src/main/resources/monkey.desc

:- signature
LOCATION = {l1,l2,l3}
OBJECT = {monkey, bananas, box}

fluent at(OBJECT,LOCATION)
fluent hasBananas
fluent onBox
action walk(LOCATION)
action pushBox(LOCATION)
action climbOn
action climbOff
action graspBananas

:- rules
inertial at(X,Y)
inertial !at(X,Y)
inertial hasBananas
inertial !hasBananas
inertial onBox
inertial !onBox

% every object is at exactly one location
caused - if !at(O,l1) && !at(O,l2) && !at(O,l3)
caused !at(O,L) if at(O, L1) requires L <> L1

caused at(bananas,L) if hasBananas && at(monkey,L)
caused at(monkey,L) if onBox && at(box,L)

% walking-effects
walk(L) causes at(monkey,L)
nonexecutable walk(L) if at(monkey,L)
nonexecutable walk(L) && climbOn
nonexecutable walk(L) && climbOff

% climbing effects
climbOn causes onBox
nonexecutable climbOn if onBox
nonexecutable climbOn if at(monkey,L) && !at(box,L)

climbOff causes !onBox
nonexecutable climbOff if !onBox
nonexecutable climbOff && graspBananas

%grasping effects
graspBananas causes hasBananas

nonexecutable graspBananas if hasBananas
nonexecutable graspBananas if !onBox
nonexecutable graspBananas if at(monkey,L) && !at(bananas,L)
nonexecutable pushBox(L) if at(box,L)
nonexecutable pushBox(L) if onBox
nonexecutable pushBox(L) if at(monkey,L1) && !at(box,L1)
nonexecutable pushBox(L) && climbOn
nonexecutable walk(L1) && pushBox(L2) requires L1 <> L2

% box-pushing effects
caused at(box,L) if at(monkey,L) after pushBox(L)
caused - if !at(monkey,L) after pushBox(L)

org-tweetyproject-beliefdynamics/src/main/java/org/tweetyproject/beliefdynamics/examples/AbstractArgumentationExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.beliefdynamics.examples;

import org.tweetyproject.arg.dung.reasoner.SatCompleteReasoner;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.beliefdynamics.DefaultMultipleBaseExpansionOperator;
import org.tweetyproject.beliefdynamics.LeviMultipleBaseRevisionOperator;
import org.tweetyproject.beliefdynamics.MultipleBaseRevisionOperator;
import org.tweetyproject.beliefdynamics.kernels.KernelContractionOperator;
import org.tweetyproject.beliefdynamics.kernels.RandomIncisionFunction;
import org.tweetyproject.logics.pl.reasoner.SimplePlReasoner;
import org.tweetyproject.logics.pl.sat.SatSolver;
import org.tweetyproject.logics.pl.semantics.PossibleWorld;
import org.tweetyproject.logics.pl.syntax.PlBeliefSet;
import org.tweetyproject.logics.pl.syntax.Proposition;
import org.tweetyproject.logics.pl.syntax.PlFormula;
import org.tweetyproject.logics.pl.syntax.PlSignature;

/**
 * Example code for applying belief dynamics on abstract argumentation frameworks.
 *
 * @author Matthias Thimm
 *
 */
public class AbstractArgumentationExample {
	    /**
     * Default constructor for the {@code AbstractArgumentationExample} class.
     * This constructor initializes the class and provides an example of
     * reasoning with an argumentation framework and belief revision.
     */
    public AbstractArgumentationExample() {
        // Default constructor
    }

    /**
     * Main method that demonstrates the usage of argumentation frameworks
     * and belief revision techniques.
     *
     * @param args command line arguments (not used)
     */
	public static void main(String[] args){
		DungTheory theory = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		theory.add(a);
		theory.add(b);
		theory.add(c);
		theory.add(new Attack(a,b));
		theory.add(new Attack(b,c));
		theory.add(new Attack(c,b));
		theory.add(new Attack(c,a));

		SatCompleteReasoner reasoner = new SatCompleteReasoner(SatSolver.getDefaultSolver());

		System.out.println(reasoner.getModels(theory));
		System.out.println();

		PlBeliefSet beliefSet = reasoner.getPropositionalCharacterisation(theory);
		System.out.println(beliefSet);
		System.out.println();
		for(PossibleWorld w: PossibleWorld.getAllPossibleWorlds((PlSignature)beliefSet.getMinimalSignature())){
			if(w.satisfies(beliefSet))
				System.out.println(w);
		}

		MultipleBaseRevisionOperator<PlFormula> revise = new LeviMultipleBaseRevisionOperator<PlFormula>(
				new KernelContractionOperator<PlFormula>(new RandomIncisionFunction<PlFormula>(), new SimplePlReasoner()),
				new DefaultMultipleBaseExpansionOperator<PlFormula>());

		PlBeliefSet beliefSet2 = new PlBeliefSet(revise.revise(beliefSet, new Proposition("in_a")));

		System.out.println(beliefSet2);
		System.out.println();
		for(PossibleWorld w: PossibleWorld.getAllPossibleWorlds((PlSignature)beliefSet2.getMinimalSignature())){
			if(w.satisfies(beliefSet2))
				System.out.println(w);
		}


	}
}

org-tweetyproject-action/src/main/resources/conditioner.desc

:- signature
fluent oncondition
fluent cooling
action switchcondition
action switchheat

:- rules

inertial oncondition
inertial !oncondition
inertial cooling
inertial !cooling

caused !cooling if !oncondition

caused oncondition after switchcondition && !oncondition
caused !oncondition after switchcondition && oncondition 

caused cooling after switchheat && oncondition && !cooling
caused !cooling after switchheat && cooling

org-tweetyproject-agents-dialogues/src/main/java/org/tweetyproject/agents/dialogues/examples/LotteryDialogueTest.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.agents.dialogues.examples;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.tweetyproject.agents.ProtocolTerminatedException;
import org.tweetyproject.agents.dialogues.lotteries.AbstractLotteryAgent;
import org.tweetyproject.agents.dialogues.lotteries.LotteryGameSystem;
import org.tweetyproject.agents.dialogues.lotteries.sim.UtilityBasedAgentGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.DirectGameProtocol;
import org.tweetyproject.agents.dialogues.lotteries.sim.DirectGameProtocolGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.DummyAgentGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.ProbabilisticLotteryAgentGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.LotteryGameGenerator;
import org.tweetyproject.agents.sim.AgentGenerator;
import org.tweetyproject.agents.sim.GameSimulator;
import org.tweetyproject.agents.sim.MultiAgentSystemGenerator;
import org.tweetyproject.agents.sim.ProtocolGenerator;
import org.tweetyproject.agents.sim.SimulationResult;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;

/**
 *
 * Shows how a simulation of a multi-agent system can be set up. It defines a
 * dialogue game between different agents, in particular one based on an action
 * selection strategy using lotteries.
 *
 * @author Matthias Thimm
 *
 */
public class LotteryDialogueTest {

	// Global parameters for simulation

	/**
	 * The size of the argumentation framework being used in the simulation.
	 * Represents the number of arguments in the framework.
	 */
	public static int frameworkSize;

	/**
	 * The probability that an attack exists between any two arguments in the
	 * argumentation framework.
	 * The value should be between 0.0 and 1.0, where 0.0 means no attacks, and 1.0
	 * means all possible attacks are present.
	 */
	public static double attackProbability;

	/**
	 * A flag indicating whether the framework should enforce a tree shape
	 * structure.
	 * If true, the argumentation framework will be constructed as a tree (no
	 * cycles).
	 */
	public static boolean enforceTreeShape;

	/**
	 * The timeout duration for each simulation run in seconds.
	 * Default is set to 72 hours (259200 seconds).
	 */
	public static int timeout = 60 * 60 * 72; // 72 hours

	/**
	 * The number of simulation runs to be executed for each experiment.
	 * Default is set to 100 runs.
	 */
	public static int numberOfRunsEach = 100;

	/**
	 * The semantics to be used for evaluating the argumentation framework in the
	 * simulation.
	 * Default is set to GROUNDED_SEMANTICS.
	 */
	public static Semantics semantics = Semantics.GROUNDED_SEMANTICS;

	// Seeds for ensuring comparability between runs

	/**
	 * A fixed random seed to ensure comparability of simulation results.
	 */
	public static long RANDOM_SEED1 = 435844589l;

	/**
	 * A fixed random seed to ensure comparability of simulation results.
	 */
	public static long RANDOM_SEED2 = 96421389l;

	/**
	 * A fixed random seed to ensure comparability of simulation results.
	 */
	public static long RANDOM_SEED3 = 6477568l;

	/**
	 * A fixed random seed to ensure comparability of simulation results.
	 */
	public static long RANDOM_SEED4 = 2136455579l;

	/**
	 * Runs a simulation of the multi-agent system where agents engage in a dialogue
	 * game based on a Dung theory. The simulation is repeated for a number of runs
	 * and the results are aggregated. The simulation runs with a set timeout, and
	 * if it exceeds the timeout, it is aborted.
	 *
	 * @param baseline a flag to indicate whether the baseline agent
	 *                 (UtilityBasedAgent)
	 *                 or the probabilistic lottery agent
	 *                 (ProbabilisticLotteryAgent)
	 *                 should be used in the simulation.
	 *
	 * @throws ProtocolTerminatedException if the protocol ends prematurely during
	 *                                     the simulation.
	 */
	public static void runSimulation(boolean baseline) throws ProtocolTerminatedException {
		// We generate Dung theories with the given number of arguments and attack
		// probability.
		// In every theory, the argument under consideration is guaranteed to
		// be in the grounded extension (so under perfect information, the PRO
		// agent should always win)
		DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
		params.attackProbability = LotteryDialogueTest.attackProbability;
		params.numberOfArguments = LotteryDialogueTest.frameworkSize;
		params.enforceTreeShape = LotteryDialogueTest.enforceTreeShape;
		DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
		gen.setSeed(LotteryDialogueTest.RANDOM_SEED1);

		// MAS generator
		MultiAgentSystemGenerator<AbstractLotteryAgent, LotteryGameSystem> masGenerator = new LotteryGameGenerator(gen,
				semantics);
		masGenerator.setSeed(GroundedTest.RANDOM_SEED2);
		List<AgentGenerator<AbstractLotteryAgent, LotteryGameSystem>> agentGenerators = new ArrayList<AgentGenerator<AbstractLotteryAgent, LotteryGameSystem>>();

		if (baseline)
			agentGenerators.add(new UtilityBasedAgentGenerator("BASE"));
		else
			agentGenerators.add(new ProbabilisticLotteryAgentGenerator("PRO"));
		agentGenerators.add(new DummyAgentGenerator("AUDIENCE"));
		agentGenerators.get(0).setSeed(GroundedTest.RANDOM_SEED3);
		agentGenerators.get(1).setSeed(GroundedTest.RANDOM_SEED4);

		ProtocolGenerator<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem> protGenerator = new DirectGameProtocolGenerator();
		final GameSimulator<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem> sim = new GameSimulator<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem>(
				masGenerator, protGenerator, agentGenerators);
		// Run iterated simulations and show aggregated results (with timeout)
		Callable<String> callee = new Callable<String>() {
			@Override
			public String call() throws Exception {
				SimulationResult<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem> result = sim
						.run(LotteryDialogueTest.numberOfRunsEach);
				System.out.println(result.csvDisplay());
				return null;
			}
		};
		ExecutorService executor = Executors.newSingleThreadExecutor();
		Future<String> future = executor.submit(callee);
		try {
			future.get(LotteryDialogueTest.timeout, TimeUnit.SECONDS);
		} catch (Exception e) {
			System.out.println("Aborted...");
			e.printStackTrace();
		}
		executor.shutdownNow();
	}

	/**
	 * LotteryDialogue test main method
	 *
	 * @param args the args
	 * @throws ProtocolTerminatedException error
	 */
	public static void main(String[] args) throws ProtocolTerminatedException {
		LotteryDialogueTest.attackProbability = 0.3;
		LotteryDialogueTest.frameworkSize = 10;
		LotteryDialogueTest.enforceTreeShape = true;
		// baseline
		// LotteryDialogueTest.runSimulation(true);
		// actual agent
		LotteryDialogueTest.runSimulation(false);
	}

	/** Default Constructor */
	public LotteryDialogueTest() {
	}
}

org-tweetyproject-agents-dialogues/src/main/java/org/tweetyproject/agents/dialogues/examples/GroundedTest2.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.agents.dialogues.examples;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.tweetyproject.agents.Agent;
import org.tweetyproject.agents.ProtocolTerminatedException;
import org.tweetyproject.agents.dialogues.oppmodels.ArguingAgent;
import org.tweetyproject.agents.dialogues.oppmodels.BeliefState;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameProtocol;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameSystem;
import org.tweetyproject.agents.dialogues.oppmodels.T3BeliefState;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameProtocolGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT1AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT3AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T1Configuration;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T3Configuration;
import org.tweetyproject.agents.sim.MultiAgentSystemGenerator;
import org.tweetyproject.agents.sim.ProtocolGenerator;
import org.tweetyproject.agents.sim.SimulationParameters;
import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;

/**
 *
 * Shows how a simulation of a multi-agent system can be set up. It defines a
 * dialogue game between different agents with varying complexity of their
 * opponent models.
 *
 * @author Matthias Thimm
 *
 */
public class GroundedTest2 {

    /**
     * Timeout duration for each simulation run in seconds.
     * Default is set to 10 minutes (600 seconds).
     */
    public static int timeout = 60 * 10; // 10 minutes

    /**
     * Number of simulation runs to be executed for each experiment.
     * Default is set to 5000 runs.
     */
    public static int numberOfRunsEach = 5000;

    /**
     * The main method of the simulation. This sets up and runs the
     * multi-agent dialogue game simulation.
     *
     * @param args Command line arguments (not used in this simulation).
     * @throws ProtocolTerminatedException if the protocol terminates unexpectedly.
     */
	public static void main(String[] args) throws ProtocolTerminatedException {


		GroundedTest.attackProbability = 0.4;
		GroundedTest.frameworkSize = 10;
		GroundedTest.enforceTreeShape = false;

		DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
		params.attackProbability = GroundedTest.attackProbability;
		params.numberOfArguments = GroundedTest.frameworkSize;
		params.enforceTreeShape = GroundedTest.enforceTreeShape;
		DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
		// gen.setSeed(GroundedTest.RANDOM_SEED1);
		// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
		final MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
				0.5, 0.9);
		// masGenerator.setSeed(GroundedTest.RANDOM_SEED2);

		// The PRO agent has a T1 belief state without opponent model
		T1Configuration configPro = new T1Configuration();
		configPro.maxRecursionDepth = 0;
		configPro.probRecursionDecay = 0;
		configPro.oppModelCorrect = true;
		// The CONTRA agent
		T3Configuration configCon = new T3Configuration();
		configCon.maxRecursionDepth = 2;
		configCon.probRecursionDecay = 0.6;
		configCon.maxRecursionWidth = 3;
		configCon.percentageVirtualArguments = 0.3;
		configCon.percentageVirtualAttacks = 0.8;

		final GroundedGameT1AgentGenerator proGenerator = new GroundedGameT1AgentGenerator(
				GroundedGameSystem.AgentFaction.PRO, configPro);
		final GroundedGameT3AgentGenerator conGenerator = new GroundedGameT3AgentGenerator(
				GroundedGameSystem.AgentFaction.CONTRA, configCon);
		// proGenerator.setSeed(GroundedTest.RANDOM_SEED3);
		// conGenerator.setSeed(GroundedTest.RANDOM_SEED4);

		final ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();

		// 0 holds score for pro in pro vs. T3
		// 1 holds score for T3 in pro vs. T3
		// 2 holds score for pro in pro vs. T2
		// 3 holds score for T2 in pro vs. T2
		// 4 holds score for pro in pro vs. T1
		// 5 holds score for T1 in pro vs. T1
		final int[] results = { 0, 0, 0, 0, 0, 0 };

		for (int i = 0; i < GroundedTest2.numberOfRunsEach; i++) {
			final int k = i;
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationParameters sParams = new SimulationParameters();
					GroundedGameSystem mas = masGenerator.generate(sParams);
					// create agents for T3 test
					ArguingAgent proAgent = proGenerator.generate(mas, sParams);
					ArguingAgent conAgentT3 = conGenerator.generate(mas, sParams);
					// make backups
					ArguingAgent proBackup = new ArguingAgent(proAgent.getFaction(),
							(BeliefState) proAgent.getBeliefState().clone());
					ArguingAgent conBackup = new ArguingAgent(conAgentT3.getFaction(),
							(BeliefState) conAgentT3.getBeliefState().clone());
					mas.add(proAgent);
					mas.add(conAgentT3);
					GroundedGameProtocol prot = protGenerator.generate(mas, sParams);
					mas.execute(prot);
					if (prot.hasWinner()) {
						Agent winner = prot.getWinner();
						if (winner == proAgent)
							results[0]++;
						else
							results[1]++;
					}
					mas.remove(proAgent);
					mas.remove(conAgentT3);
					// create agents for T2 test
					mas.getEnvironment().reset();
					proAgent = new ArguingAgent(proBackup.getFaction(),
							(BeliefState) proBackup.getBeliefState().clone());
					ArguingAgent conAgentT2 = new ArguingAgent(conBackup.getFaction(),
							((T3BeliefState) conBackup.getBeliefState()).projectToT2BeliefState());
					mas.add(proAgent);
					mas.add(conAgentT2);
					prot = protGenerator.generate(mas, sParams);
					mas.execute(prot);
					if (prot.hasWinner()) {
						Agent winner = prot.getWinner();
						if (winner == proAgent)
							results[2]++;
						else
							results[3]++;
					}
					mas.remove(proAgent);
					mas.remove(conAgentT2);
					// create agents for T1 test
					mas.getEnvironment().reset();
					proAgent = new ArguingAgent(proBackup.getFaction(),
							(BeliefState) proBackup.getBeliefState().clone());
					ArguingAgent conAgentT1 = new ArguingAgent(conBackup.getFaction(),
							((T3BeliefState) conBackup.getBeliefState()).projectToT2BeliefState()
									.sampleT1BeliefState());
					mas.add(proAgent);
					mas.add(conAgentT1);
					prot = protGenerator.generate(mas, sParams);
					mas.execute(prot);
					if (prot.hasWinner()) {
						Agent winner = prot.getWinner();
						if (winner == proAgent)
							results[4]++;
						else
							results[5]++;
					}
					System.out.println(k + ":\t" + results[0] + "\t" + results[1] + "\t" + results[2] + "\t"
							+ results[3] + "\t" + results[4] + "\t" + results[5]);
					return "";
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest2.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
		}

	}

    /** Default Constructor */
    public GroundedTest2(){}
}

org-tweetyproject-agents-dialogues/src/main/java/org/tweetyproject/agents/dialogues/examples/GroundedTest.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.agents.dialogues.examples;

import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.tweetyproject.agents.ProtocolTerminatedException;
import org.tweetyproject.agents.dialogues.oppmodels.ArguingAgent;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameProtocol;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameSystem;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameProtocolGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT1AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT2AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT3AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T1Configuration;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T2Configuration;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T3Configuration;
import org.tweetyproject.agents.sim.AgentGenerator;
import org.tweetyproject.agents.sim.GameSimulator;
import org.tweetyproject.agents.sim.MultiAgentSystemGenerator;
import org.tweetyproject.agents.sim.ProtocolGenerator;
import org.tweetyproject.agents.sim.SimulationResult;
import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;

/**
 *
 * Shows how a simulation of a multi-agent system can be set up. It defines a
 * dialogue game between different agents with varying complexity of their
 * opponent models.
 *
 * @author Matthias Thimm
 *
 */
public class GroundedTest {

    /** The size of the argumentation framework in the simulation. */
    public static int frameworkSize;

    /** The probability of an attack between arguments in the framework (0.0 to 1.0). */
    public static double attackProbability;

    /**
     * Flag indicating whether the framework should enforce a tree-like structure.
     * If true, the argumentation framework will be forced to have a tree shape.
     */
    public static boolean enforceTreeShape;

    /** The timeout for the simulation in seconds (default: six hours). */
    public static int timeout = 60 * 60 * 6;

    /** The number of simulation runs to be executed for each experiment. */
    public static int numberOfRunsEach = 100;

    /** Random seed for ensuring reproducibility in the first configuration. */
    public static long RANDOM_SEED1 = 43589744589L;

    /** Random seed for ensuring reproducibility in the second configuration. */
    public static long RANDOM_SEED2 = 96498321389L;

    /** Random seed for ensuring reproducibility in the third configuration. */
    public static long RANDOM_SEED3 = 647597568L;

    /** Random seed for ensuring reproducibility in the fourth configuration. */
    public static long RANDOM_SEED4 = 213596455579L;

	/**
	 * This method shows that with increasing complexity of the T1-belief state of
	 * the CONTRA agent (and constant model of the PRO agent), the average utility
	 * of the CONTRA agent increases. NOTE: the simulation might take a while.
	 *
	 * @throws ProtocolTerminatedException if the protocol already terminated
	 */
	public static void runSimulationT1() throws ProtocolTerminatedException {
		// We run different simulations with increasing recursion depth
		// of the CON agent's belief state
		for (int i = 1; i < 4; i++) {
			// We generate Dung theories with the given number of arguments and attack
			// probability.
			// In every theory, the argument under consideration is guaranteed to
			// be in the grounded extension (so under perfect information, the PRO
			// agent should always win)
			DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
			params.attackProbability = GroundedTest.attackProbability;
			params.numberOfArguments = GroundedTest.frameworkSize;
			params.enforceTreeShape = GroundedTest.enforceTreeShape;
			DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
			gen.setSeed(GroundedTest.RANDOM_SEED1);
			// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
			MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
					0.5, 0.9);
			masGenerator.setSeed(GroundedTest.RANDOM_SEED2);
			List<AgentGenerator<ArguingAgent, GroundedGameSystem>> agentGenerators = new ArrayList<AgentGenerator<ArguingAgent, GroundedGameSystem>>();

			// The PRO agent has a T1 belief state without opponent model
			T1Configuration configPro = new T1Configuration();
			configPro.maxRecursionDepth = 0;
			configPro.probRecursionDecay = 0;
			configPro.oppModelCorrect = true;
			// The CONTRA agent has a T1 belief state of depth i,
			// every sub-model correctly and completely models the PRO agent
			T1Configuration configCon = new T1Configuration();
			configCon.maxRecursionDepth = i;
			configCon.probRecursionDecay = 0;
			configCon.oppModelCorrect = true;

			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.PRO, configPro));
			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.CONTRA, configCon));
			agentGenerators.get(0).setSeed(GroundedTest.RANDOM_SEED3);
			agentGenerators.get(1).setSeed(GroundedTest.RANDOM_SEED4);

			ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();
			final GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> sim = new GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem>(
					masGenerator, protGenerator, agentGenerators);
			final int j = i;
			// Run iterated simulations and show aggregated results (with timeout)
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationResult<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> result = sim
							.run(GroundedTest.numberOfRunsEach);
					System.out.print("T1;T1;" + GroundedTest.frameworkSize + ";" + GroundedTest.attackProbability + ";"
							+ (GroundedTest.enforceTreeShape ? ("tree") : ("no-tree")));
					System.out.print(";T1-" + j + ";");
					System.out.println(result.csvDisplay());
					return null;
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
		}
	}
//T1;T1;10;0.3;tree;T1-3;PRO;58;CONTRA;42;PRO;(0.14080000000000006, 0.9995124848484855);CONTRA;(-0.17920000000000003, 0.9693225858585856);
	/**
	 * Same as runSimulationT1()
	 *
	 * @throws ProtocolTerminatedException if the protocol already terminated
	 */
	public static void runSimulationT2() throws ProtocolTerminatedException {
		// We run different simulations with increasing complexity
		// of the CON agent's belief state
		int depth[] = { 2, 3, 4 }; // depth complexity
		double decay[] = { 0.4, 0.3, 0.2 }; // decay complexity
		int width[] = { 4, 3, 2 }; // width complexity
		int idx[] = new int[3];
		idx[0] = 0;
		idx[1] = 0;
		idx[2] = 0;
		for (int i = 0; i < 27; i++) {
			DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
			params.attackProbability = GroundedTest.attackProbability;
			params.numberOfArguments = GroundedTest.frameworkSize;
			params.enforceTreeShape = GroundedTest.enforceTreeShape;
			DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
			gen.setSeed(GroundedTest.RANDOM_SEED1);
			// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
			MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
					0.5, 0.9);
			masGenerator.setSeed(GroundedTest.RANDOM_SEED2);
			List<AgentGenerator<ArguingAgent, GroundedGameSystem>> agentGenerators = new ArrayList<AgentGenerator<ArguingAgent, GroundedGameSystem>>();

			// The PRO agent has a T1 belief state without opponent model
			T1Configuration configPro = new T1Configuration();
			configPro.maxRecursionDepth = 0;
			configPro.probRecursionDecay = 0;
			configPro.oppModelCorrect = true;
			// The CONTRA agent has a T2 belief state of complexity i
			T2Configuration configCon = new T2Configuration();
			configCon.maxRecursionDepth = depth[idx[0]];
			configCon.probRecursionDecay = decay[idx[1]];
			configCon.maxRecursionWidth = width[idx[2]];

			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.PRO, configPro));
			agentGenerators.add(new GroundedGameT2AgentGenerator(GroundedGameSystem.AgentFaction.CONTRA, configCon));
			agentGenerators.get(0).setSeed(GroundedTest.RANDOM_SEED3);
			agentGenerators.get(1).setSeed(GroundedTest.RANDOM_SEED4);

			ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();
			final GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> sim = new GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem>(
					masGenerator, protGenerator, agentGenerators);
			final int d1 = depth[idx[0]];
			final double d2 = decay[idx[1]];
			final int d3 = width[idx[2]];
			// Run iterated simulations and show aggregated results (with timeout)
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationResult<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> result = sim
							.run(GroundedTest.numberOfRunsEach);
					System.out.print("T1;T2;" + GroundedTest.frameworkSize + ";" + GroundedTest.attackProbability + ";"
							+ (GroundedTest.enforceTreeShape ? ("tree") : ("no-tree")));
					System.out.print(";T2-(" + d1 + "," + d2 + "," + d3 + ");");
					System.out.println(result.csvDisplay());
					return null;
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
			idx[2]++;
			if (idx[2] > 2) {
				idx[2] = 0;
				idx[1]++;
				if (idx[1] > 2) {
					idx[1] = 0;
					idx[0]++;
					if (idx[0] > 2)
						idx[0] = 0;
				}
			}
		}
	}

	/**
	 * Same as runSimulationT1()
	 *
	 * @throws ProtocolTerminatedException if the protocol already terminated
	 */
	public static void runSimulationT3() throws ProtocolTerminatedException {
		// We run different simulations with increasing complexity
		// of the CON agent's belief state
		int depth[] = { 2, 3, 4 }; // depth complexity
		double decay[] = { 0.4, 0.3, 0.2 }; // decay complexity
		int width[] = { 4, 3, 2 }; // width complexity
		double virtArg[] = { 0.3, 0.2, 0.1 }; // virtual arguments
		double virtAtt[] = { 0.7, 0.8, 0.9 }; // virtual attacks
		int idx[] = new int[5];
		idx[0] = 0;
		idx[1] = 0;
		idx[2] = 0;
		idx[3] = 0;
		idx[4] = 0;

		for (int i = 0; i < 243; i++) {
			DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
			params.attackProbability = GroundedTest.attackProbability;
			params.numberOfArguments = GroundedTest.frameworkSize;
			params.enforceTreeShape = GroundedTest.enforceTreeShape;
			DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
			gen.setSeed(GroundedTest.RANDOM_SEED1);
			// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
			MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
					0.5, 0.9);
			masGenerator.setSeed(GroundedTest.RANDOM_SEED2);
			List<AgentGenerator<ArguingAgent, GroundedGameSystem>> agentGenerators = new ArrayList<AgentGenerator<ArguingAgent, GroundedGameSystem>>();

			// The PRO agent has a T1 belief state without opponent model
			T1Configuration configPro = new T1Configuration();
			configPro.maxRecursionDepth = 0;
			configPro.probRecursionDecay = 0;
			configPro.oppModelCorrect = true;
			// The CONTRA agent has a T3 belief state
			T3Configuration configCon = new T3Configuration();
			configCon.maxRecursionDepth = depth[idx[0]];
			configCon.probRecursionDecay = decay[idx[1]];
			configCon.maxRecursionWidth = width[idx[2]];
			configCon.percentageVirtualArguments = virtArg[idx[3]];
			configCon.percentageVirtualAttacks = virtAtt[idx[4]];

			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.PRO, configPro));
			agentGenerators.add(new GroundedGameT3AgentGenerator(GroundedGameSystem.AgentFaction.CONTRA, configCon));
			agentGenerators.get(0).setSeed(GroundedTest.RANDOM_SEED3);
			agentGenerators.get(1).setSeed(GroundedTest.RANDOM_SEED4);

			ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();
			final GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> sim = new GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem>(
					masGenerator, protGenerator, agentGenerators);
			final int d1 = depth[idx[0]];
			final double d2 = decay[idx[1]];
			final int d3 = width[idx[2]];
			final double d4 = virtArg[idx[3]];
			final double d5 = virtAtt[idx[4]];
			// Run iterated simulations and show aggregated results (with timeout)
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationResult<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> result = sim
							.run(GroundedTest.numberOfRunsEach);
					System.out.print("T1;T3;" + GroundedTest.frameworkSize + ";" + GroundedTest.attackProbability + ";"
							+ (GroundedTest.enforceTreeShape ? ("tree") : ("no-tree")));
					System.out.print(";T3-(" + d1 + "," + d2 + "," + d3 + "," + d4 + "," + d5 + ");");
					System.out.println(result.csvDisplay());
					return null;
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
			idx[4]++;
			if (idx[4] > 2) {
				idx[4] = 0;
				idx[3]++;
				if (idx[3] > 2) {
					idx[3] = 0;
					idx[2]++;
					if (idx[2] > 2) {
						idx[2] = 0;
						idx[1]++;
						if (idx[1] > 2) {
							idx[1] = 0;
							idx[0]++;
							if (idx[0] > 2)
								idx[0] = 0;
						}
					}
				}
			}
		}
	}

	/**
	 * Grounded test method
	 * @param args the args
	 * @throws ProtocolTerminatedException error
	 */
	public static void main(String[] args) throws ProtocolTerminatedException {
		// set logging level to "TRACE" to get detailed descriptions

		GroundedTest.attackProbability = 0.3;
		GroundedTest.frameworkSize = 10;

		GroundedTest.enforceTreeShape = true;
		GroundedTest.runSimulationT1();
		// GroundedTest.enforceTreeShape = false;
		// GroundedTest.runSimulationT1();

		// GroundedTest.runSimulationT2();
		// GroundedTest.runSimulationT3();
		// GroundedTest.enforceTreeShape = false;
		// GroundedTest.runSimulationT1();
		// GroundedTest.runSimulationT2();
		// GroundedTest.runSimulationT3();
	}

    /** Default Constructor */
    public GroundedTest(){}
}

org-tweetyproject-arg-weighted/src/main/java/org/tweetyproject/arg/weighted/examples/WeightedReasonerExample.java

/*
* This file is part of "TweetyProject", a collection of Java libraries for
* logical aspects of artificial intelligence and knowledge representation.
*
* TweetyProject is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License version 3 as
* published by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2024 The TweetyProject Team <http://tweetyproject.org/contact/>
*/
package org.tweetyproject.arg.weighted.examples;


import java.util.Collection;
import java.util.Set;

import org.tweetyproject.arg.dung.reasoner.SimpleAdmissibleReasoner;
import org.tweetyproject.arg.dung.reasoner.SimpleCompleteReasoner;
import org.tweetyproject.arg.dung.reasoner.SimpleConflictFreeReasoner;
import org.tweetyproject.arg.dung.reasoner.SimpleGroundedReasoner;
import org.tweetyproject.arg.dung.reasoner.SimplePreferredReasoner;
import org.tweetyproject.arg.dung.reasoner.SimpleStableReasoner;
import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.weighted.reasoner.SimpleWeightedAdmissibleReasoner;
import org.tweetyproject.arg.weighted.reasoner.SimpleWeightedCompleteReasoner;
import org.tweetyproject.arg.weighted.reasoner.SimpleWeightedConflictFreeReasoner;
import org.tweetyproject.arg.weighted.reasoner.SimpleWeightedGroundedReasoner;
import org.tweetyproject.arg.weighted.reasoner.SimpleWeightedPreferredReasoner;
import org.tweetyproject.arg.weighted.reasoner.SimpleWeightedStableReasoner;
import org.tweetyproject.arg.weighted.syntax.WeightedArgumentationFramework;
import org.tweetyproject.math.algebra.BottleneckSemiring;
import org.tweetyproject.math.algebra.WeightedSemiring;

/**
 * WeightedReasonerExample class
 * @author Sandra Hoffmann
 *
 */
public class WeightedReasonerExample {

		/** Default */
		public WeightedReasonerExample(){

		}

	/**
	 * Example main method
	 * @param args the args
	 */
	public static void main(String[] args) {

		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		Argument e = new Argument("e");

		//construct weighted AF
		WeightedArgumentationFramework<Double> weightedDungAF = new WeightedArgumentationFramework<>(new WeightedSemiring());
		weightedDungAF.add(a);
		weightedDungAF.add(b);
		weightedDungAF.add(c);
		weightedDungAF.add(d);
		weightedDungAF.add(e);


		weightedDungAF.add(new Attack(a,b),7.0);
		weightedDungAF.add(new Attack(c,b),8.0);
		weightedDungAF.add(new Attack(d,c),8.0);
		weightedDungAF.add(new Attack(c,d),9.0);
		weightedDungAF.add(new Attack(d,e),5.0);
		weightedDungAF.add(new Attack(e,e),6.0);



		//Conflict Free Reasoner
		SimpleWeightedConflictFreeReasoner<Double> weightedCfReasoner = new SimpleWeightedConflictFreeReasoner<>();
		System.out.println("0 conflict free Sets: " +weightedCfReasoner.getModels(weightedDungAF, 0.0));
		System.out.println("15 conflict free Sets: " +weightedCfReasoner.getModels(weightedDungAF, 15.0));


		//Admissibility Reasoner
		SimpleAdmissibleReasoner admReasoner = new SimpleAdmissibleReasoner();
		SimpleWeightedAdmissibleReasoner<Double> weightedAdmReasoner = new SimpleWeightedAdmissibleReasoner<>();
		DungTheory dungTheory = new DungTheory(weightedDungAF);
		System.out.println("unweighted admissible Sets: " +admReasoner.getModels(dungTheory));
		System.out.println("0 alpha 0 gamma admissible Sets: " +weightedAdmReasoner.getModels(weightedDungAF, 0.0, 0.0));
		System.out.println("15 alpha 0 gamma admissible Sets: " +weightedAdmReasoner.getModels(weightedDungAF, 15.0, 0.0));
		System.out.println("11 alpha 1 gamma admissible Sets " +weightedAdmReasoner.getModels(weightedDungAF, 11.0, 1.0));

		//Complete Reasoner
		SimpleCompleteReasoner completeReasoner = new SimpleCompleteReasoner();
		SimpleWeightedCompleteReasoner<Double> weightedComReasoner = new SimpleWeightedCompleteReasoner<>();
		System.out.println("unweighted complete Sets: " +completeReasoner.getModels(dungTheory));
		System.out.println("0 alpha 0 gamma complete Sets: " +weightedComReasoner.getModels(weightedDungAF, 0.0, 0.0));
		System.out.println("0 alpha 1 gamma complete Sets: " +weightedComReasoner.getModels(weightedDungAF, 0.0, 1.0));
		System.out.println("11 alpha 1 gamma complete Sets: " +weightedComReasoner.getModels(weightedDungAF, 11.0, 1.0));

		//Preferred Reasoner
		SimplePreferredReasoner preferredReasoner = new SimplePreferredReasoner();
		SimpleWeightedPreferredReasoner<Double> weightedPrefReasoner = new SimpleWeightedPreferredReasoner<>();
		System.out.println("unweighted preferred Sets: " +preferredReasoner.getModels(dungTheory));
		System.out.println("0 alpha 0 gamma preferred Sets: " +weightedPrefReasoner.getModels(weightedDungAF, 0.0, 0.0));
		System.out.println("0 alpha 1 gamma preferred Sets: " +weightedPrefReasoner.getModels(weightedDungAF, 0.0, 1.0));

		//Stable Reasoner
		SimpleStableReasoner stableReasoner = new SimpleStableReasoner();
		SimpleWeightedStableReasoner<Double> weightedStabReasoner = new SimpleWeightedStableReasoner<>();
		System.out.println("unweighted stable Sets: " +stableReasoner.getModels(dungTheory));
		System.out.println("0 alpha 0 gamma stable Sets: " +weightedStabReasoner.getModels(weightedDungAF, 0.0, 0.0));
		System.out.println("0 alpha 1 gamma stable Sets: " +weightedStabReasoner.getModels(weightedDungAF, 0.0, 1.0));

		//grounded Reasoner
		SimpleGroundedReasoner groundedReasoner = new SimpleGroundedReasoner();
		SimpleWeightedGroundedReasoner<Double> weightedgrdReasoner = new SimpleWeightedGroundedReasoner<>();
		System.out.println("unweighted grounded Set: " +groundedReasoner.getModel(dungTheory));
		System.out.println("0 alpha 0 gamma grounded Set: " +weightedgrdReasoner.getModel(weightedDungAF, 0.0, 0.0));

	}


}

org-tweetyproject-arg-weighted/src/main/java/org/tweetyproject/arg/weighted/examples/WeightedDungTheoryGeneratorExample.java

/*
* This file is part of "TweetyProject", a collection of Java libraries for
* logical aspects of artificial intelligence and knowledge representation.
*
* TweetyProject is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License version 3 as
* published by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2023 The TweetyProject Team <http://tweetyproject.org/contact/>
*/
package org.tweetyproject.arg.weighted.examples;

import java.io.File;
import java.io.IOException;

import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.arg.dung.util.KwtDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.PodlaszewskiCaminadaDungTheoryGenerator;
import org.tweetyproject.arg.weighted.util.WeightedSemiringDungTheoryGenerator;
import org.tweetyproject.arg.weighted.writer.WeightedApxWriter;
import org.tweetyproject.math.algebra.BooleanSemiring;
import org.tweetyproject.math.algebra.FuzzySemiring;
import org.tweetyproject.math.algebra.NonNumericSemiring;
import org.tweetyproject.math.algebra.NonNumericSemiring.SemiringElement;
import org.tweetyproject.math.algebra.ProbabilisticSemiring;
import org.tweetyproject.math.algebra.WeightedSemiring;

/**
 * WeightedDungTheoryGeneratorExample class
 * @author Sandra Hoffmann
 *
 */
public class WeightedDungTheoryGeneratorExample {

	/** Default Constructor */
	public WeightedDungTheoryGeneratorExample(){

	}

	/**Example
	 * @param args the args
	 * @throws java.io.IOException error
	 */
	public static void main(String[] args) throws IOException{
		WeightedApxWriter writer = new WeightedApxWriter();
		String path = System.getProperty("user.home")
				+ File.separator + "Documents"
				+ File.separator + "TweetyProject"
				+ File.separator + "WeightedDungTheoryGeneratorExample";
		createDir(path);

		DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();

		//weighted Semiring with a max weight of 20
		WeightedSemiringDungTheoryGenerator<Double> genWeighted = new WeightedSemiringDungTheoryGenerator<>(new DefaultDungTheoryGenerator(params), new WeightedSemiring(20f));
		String pathSubFolder = path + File.separator + "Weighted";
		createDir(pathSubFolder);
		for (int i = 0; i < 20; i++) {
			File f = new File(pathSubFolder + File.separator +  "weighted" + i + ".dl");
			//write the weighted AF to file. The weights are rounded to the nearest integer value.
			writer.write(genWeighted.next(), f, 0);
		}


		//fuzzy Semiring and KwtDungTheoryGenerator
		int num_arguments = 150;
		int num_skept_arguments = 50;
		int size_ideal_extension = 20;
		int num_cred_arguments = 10;
		int num_pref_exts = 100;
		double p_ideal_attacked = 0.3;
		double p_ideal_attack_back = 0.2;
		double p_other_skept_args_attacked = 0.3;
		double p_other_skept_args_attack_back = 0.2;
		double p_cred_args_attacked = 0.3;
		double p_cred_args_attack_back = 0.2;
		double p_other_attacks = 0.2;

		WeightedSemiringDungTheoryGenerator<Double> genFuzzy = new WeightedSemiringDungTheoryGenerator<>(new KwtDungTheoryGenerator(num_arguments,
				num_skept_arguments,
				size_ideal_extension,
				num_cred_arguments,
				num_pref_exts,
				p_ideal_attacked,
				p_ideal_attack_back,
				p_other_skept_args_attacked,
				p_other_skept_args_attack_back,
				p_cred_args_attacked,
				p_cred_args_attack_back,
				p_other_attacks), new FuzzySemiring());
		pathSubFolder = path + File.separator + "Fuzzy";
		createDir(pathSubFolder);
		for (int i = 0; i < 20; i++) {
			File f = new File(pathSubFolder + File.separator +  "fuzzy" + i + ".dl");
			//write the weighted AF to file. The weights are rounded to 2 decimal places.
			writer.write(genFuzzy.next(), f, 2);
		}

		//probabilistic Semiring and PodlaszewskiCaminadaDungTheoryGenerator
		WeightedSemiringDungTheoryGenerator<Double> genProbabilistic = new WeightedSemiringDungTheoryGenerator<>(new PodlaszewskiCaminadaDungTheoryGenerator(3), new ProbabilisticSemiring());
		pathSubFolder = path + File.separator + "Probabilistic";
		createDir(pathSubFolder);
		for (int i = 0; i < 20; i++) {
			File f = new File(pathSubFolder + File.separator +  "probabilistic" + i + ".dl");
			//write the weighted AF to file. The weights are rounded to 2 decimal places.
			writer.write(genProbabilistic.next(), f, 2);
		}


		//boolean Semiring (Dung Style Framework) where the Boolean values are converted to doubles (false = 0.0, true = 1.0)
		WeightedSemiringDungTheoryGenerator<Boolean> genBoolean = new WeightedSemiringDungTheoryGenerator<>(new DefaultDungTheoryGenerator(params), new BooleanSemiring());
		pathSubFolder = path + File.separator + "Boolean";
		createDir(pathSubFolder);
		for (int i = 0; i < 20; i++) {
			File f = new File(pathSubFolder + File.separator +  "boolean" + i + ".dl");
			//write the weighted AF to file. The weights are converted to numerical values.
			writer.write(genBoolean.next(), f, true);
		}


		//NonNumeric Semiring with Elements Good, Fair, Bad where the weight values are converted to doubles (bad = 0.0, fair = 1.0, good = 2.0)
		WeightedSemiringDungTheoryGenerator<SemiringElement> genNonNumeric = new WeightedSemiringDungTheoryGenerator<>(new DefaultDungTheoryGenerator(params), new NonNumericSemiring());
		pathSubFolder = path + File.separator + "NonNumeric";
		createDir(pathSubFolder);
		for (int i = 0; i < 20; i++) {
			File f = new File(pathSubFolder + File.separator +  "nonNumeric" + i + ".dl");
			//write the weighted AF to file.
			writer.write(genNonNumeric.next(), f);
		}

	}


	private static void createDir(String path) {
		File customDir = new File(path);
		customDir.mkdirs();
	}

}

org-tweetyproject-arg-social/src/main/java/org/tweetyproject/arg/social/examples/SafExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
 package org.tweetyproject.arg.social.examples;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.social.reasoner.IssReasoner;
import org.tweetyproject.arg.social.semantics.SimpleProductSemantics;
import org.tweetyproject.arg.social.syntax.SocialAbstractArgumentationFramework;

/**
 * Example code for using social abstract argumentation.
 * @author Matthias Thimm
 *
 */
public class SafExample {

	/**
     * Default constructor for creating an instance of SimulationParameters.
     * This constructor initializes a new instance of the Hashtable.
     */
    public SafExample() {
        super();
    }


	/**
	 * Demonstrates the use of a social abstract argumentation framework (SAF) and
	 * reasoning over it using social semantics.
	 *
	 *
	 * @param args command-line arguments (not used in this example).
	 */
	public static void main(String[] args){
		SocialAbstractArgumentationFramework saf = new SocialAbstractArgumentationFramework();
		Argument a = new Argument("A");
		Argument b = new Argument("B");
		Argument c = new Argument("C");
		Argument d = new Argument("D");
		saf.add(a);
		saf.add(b);
		saf.add(c);
		saf.add(d);
		saf.add(new Attack(a,b));
		saf.add(new Attack(b,c));
		saf.add(new Attack(c,b));
		saf.add(new Attack(c,d));

		saf.voteUp(a,3);
		saf.voteUp(b,2);
		saf.voteUp(c,2);
		saf.voteUp(d,2);
		saf.voteDown(a);
		saf.voteDown(c,5);
		saf.voteDown(d,1);

		System.out.println(saf);

		IssReasoner reasoner = new IssReasoner(new SimpleProductSemantics(0.01),0.001);

		System.out.println(reasoner.getModel(saf));
	}
}

org-tweetyproject-arg-setaf/src/main/resources/ex1.apx

arg(a).
arg(b).
arg(c).
arg(d).
att(a,b).
att(b,c).
att(c,a).
att(c,d).
att(d,c).
att(d,d).

org-tweetyproject-arg-setaf/src/main/java/org/tweetyproject/arg/setaf/examples/SetAfTheoryTest.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2021 The TweetyProject Team <http://tweetyproject.org/contact/>
 */

package org.tweetyproject.arg.setaf.examples;

import java.util.HashSet;
import java.util.Set;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.setaf.syntax.SetAttack;
import org.tweetyproject.arg.setaf.syntax.SetAf;
import org.tweetyproject.arg.setaf.reasoners.*;

/**
 * Examples of SetAf Theories and their semantics
 *
 * @author Sebastian Franke
 *
 */
public class SetAfTheoryTest {

	/** Default */
	public SetAfTheoryTest() {
		// Constructor
	}

	/**
	 * Demonstrates the construction and reasoning within a SetAf (Set Attack
	 * Framework) argumentation framework.
	 * The method performs the following steps:
	 *
	 * 1. Constructs a SetAf with four arguments (a, b, c, d).
	 * 2. Defines two set attacks:
	 * - One attack from the set {b, d} to argument a.
	 * - One attack from the set {c, a} to argument c.
	 * 3. Prints the SetAf structure.
	 * 4. Applies various reasoning methods (grounded, admissible, and preferred
	 * semantics) to the SetAf:
	 * - The grounded model is computed using {@link SimpleGroundedSetAfReasoner}.
	 * - The admissible models are computed using
	 * {@link SimpleAdmissibleSetAfReasoner}.
	 * - The preferred models are computed using
	 * {@link SimplePreferredSetAfReasoner}.
	 * 5. Prints the results of the reasoning under each semantic.
	 *
	 * This example illustrates how to define a Set Attack Framework and perform
	 * reasoning to compute extensions.
	 *
	 * @param args Command-line arguments (not used in this example).
	 */

	public static void main(String[] args) {
		SetAf s = new SetAf();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		s.add(a);
		s.add(b);
		s.add(c);
		s.add(d);

		Set<Argument> a1 = new HashSet<Argument>();
		a1.add(b);
		a1.add(d);

		Set<Argument> a2 = new HashSet<Argument>();
		a2.add(c);
		a2.add(a);

		s.add(new SetAttack(a1, a));
		s.add(new SetAttack(a2, c));
		// s.remove(a);
		System.out.println(s.toString());
		// System.out.println(s.getComplementGraph(0));
		SimpleGroundedSetAfReasoner gr = new SimpleGroundedSetAfReasoner();
		SimpleAdmissibleSetAfReasoner ad = new SimpleAdmissibleSetAfReasoner();
		SimplePreferredSetAfReasoner pr = new SimplePreferredSetAfReasoner();
		System.out.println("grounded: " + gr.getModel(s));
		System.out.println("admissible: " + ad.getModels(s));
		System.out.println("preferred: " + pr.getModels(s));

	}

}

org-tweetyproject-arg-rankings/src/main/resources/ex1_bonzon.apx

arg(a).
arg(b).
arg(c).
arg(d).
arg(e).
att(a,e).
att(d,a).
att(e,d).
att(c,e).
att(b,c).
att(b,a).

org-tweetyproject-arg-rankings/src/main/java/org/tweetyproject/arg/rankings/examples/SerialisableRankingReasonerExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.rankings.examples;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.rankings.reasoner.SerialisableRankingReasoner;
/**
 * An example class that demonstrates the usage of the {@link SerialisableRankingReasoner}.
 *
 * <p>
 * This class constructs an argumentation framework (AAF) using the {@link DungTheory} class.
 * Several arguments and attacks between them are added to the framework.
 * The {@link SerialisableRankingReasoner} is then used to compute and display the ranking of the arguments.
 * </p>
 *
 * @author Name
 */
public class SerialisableRankingReasonerExample {

    /**
     * The main method that constructs the argumentation framework and invokes the
     * {@link SerialisableRankingReasoner} to compute the ranking of the arguments.
     *
     * @param args Command line arguments (not used)
     */
	public static void main(String[] args) {
		// Construct AAF
		DungTheory aaf = new DungTheory();
		Argument a = new Argument("a");
		Argument b1 = new Argument("b1");
		Argument b2 = new Argument("b2");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		Argument e = new Argument("e");
		Argument f = new Argument("f");
		Argument g = new Argument("g");
		Argument h = new Argument("h");

		// Add arguments to the theory
		aaf.add(a);
		aaf.add(b1);
		aaf.add(b2);
		aaf.add(c);
		aaf.add(d);
		aaf.add(e);
		aaf.add(f);
		aaf.add(g);
		aaf.add(h);

		// Add attacks between arguments
		aaf.add(new Attack(a, b1));
		aaf.add(new Attack(a, b2));
		aaf.add(new Attack(b1, c));
		aaf.add(new Attack(b2, c));
		aaf.add(new Attack(c, d));
		aaf.add(new Attack(d, a));
		aaf.add(new Attack(c, e));
		aaf.add(new Attack(e, f));
		aaf.add(new Attack(g, h));
		aaf.add(new Attack(h, f));

		// Instantiate the reasoner and compute the ranking model
		SerialisableRankingReasoner reasoner = new SerialisableRankingReasoner();
		System.out.println(reasoner.getModel(aaf));
	}

    /** Default Constructor */
    public SerialisableRankingReasonerExample() {
    }
}


org-tweetyproject-arg-rankings/src/main/java/org/tweetyproject/arg/rankings/examples/RankingSemanticsExample2.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.rankings.examples;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.rankings.reasoner.CountingRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.PropagationRankingReasoner;
import org.tweetyproject.arg.rankings.util.RankingTools;

/**
 * Example code for even more ranking semantics:
 * <br> - Counting Semantics [Pu, Zhang, G.Luo, J.Luo. Attacker and Defender Counting Approach
 * for Abstract Argumentation. CoRR 2015].
 * <br> - The three variations of the Propagation Semantics
 * [Delobelle. Ranking-based Semantics for Abstract Argumentation. Thesis, 2017])
 *
 * @author Anna Gessler
 */
public class RankingSemanticsExample2 {
	/**
	 * Example
	 * @param args cmd line
	 */
	public static void main(String[] args) {
		// Example 1, taken from [Bonzon, Delobelle, Konieczny, Maudet. A Comparative
		// Study of Ranking-Based Semantics for Abstract Argumentation. AAAI 2016]
		DungTheory example1 = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		Argument e = new Argument("e");
		example1.add(a,b,c,d,e);
		example1.add(new Attack(a, e));
		example1.add(new Attack(d, a));
		example1.add(new Attack(e, d));
		example1.add(new Attack(c, e));
		example1.add(new Attack(b, c), new Attack(b, a));

		// Example 2, taken from Figure 1.a in [Pu, Zhang, G.Luo, J.Luo.
		// Attacker and Defender Counting Approach for Abstract Argumentation. CoRR 2015]
		DungTheory example2 = new DungTheory();
		Argument x1 = new Argument("x1");
		Argument x2 = new Argument("x2");
		Argument x3 = new Argument("x3");
		Argument x4 = new Argument("x4");
		example2.add(x1, x2, x3, x4);
		example2.add(new Attack(x2, x3), new Attack(x2, x1));
		example2.add(new Attack(x3, x2), new Attack(x3, x3));
		example2.add(new Attack(x4, x2));

		// Example 3, taken from Figure 2.4 in
		// [Delobelle, Jerome. Ranking-based Semantics for Abstract Argumentation. 2017]
		DungTheory example3 = new DungTheory();
		Argument f = new Argument("f");
		Argument g = new Argument("g");
		Argument h = new Argument("h");
		Argument i = new Argument("i");
		Argument j = new Argument("j");
		example3.add(a,b,c,d,e,f,g,h,i,j);
		example3.add(new Attack(a,b));
		example3.add(new Attack(b,c), new Attack(b,f));
		example3.add(new Attack(d,g), new Attack(d,f));
		example3.add(new Attack(e,h), new Attack(e,d), new Attack(e,i));
		example3.add(new Attack(h,g));
		example3.add(new Attack(j,i));

		// Counting semantics
		CountingRankingReasoner reasoner = new CountingRankingReasoner(0.98, 0.001);
		System.out.println(reasoner.getClass().getSimpleName());
		System.out.println(RankingTools.roundRanking(reasoner.getModel(example1), 2));
		System.out.println(RankingTools.roundRanking(reasoner.getModel(example2), 2));
		reasoner = new CountingRankingReasoner(0.9, 0.001);
		System.out.println(RankingTools.roundRanking(reasoner.getModel(example3), 3));

		// Propagation semantics (examples from chapter 3.3 in
		// [Delobelle. Ranking-based Semantics for Abstract Argumentation. Thesis, 2017])
		System.out.println("Propagation semantics epsilon:");
		PropagationRankingReasoner propagation_reasoner_1 = new PropagationRankingReasoner(0.75, false, PropagationRankingReasoner.PropagationSemantics.PROPAGATION1);
		System.out.println("S,0.75:" + propagation_reasoner_1.getModel(example3));
		propagation_reasoner_1 = new PropagationRankingReasoner(0.3, false, PropagationRankingReasoner.PropagationSemantics.PROPAGATION1);
		System.out.println("S,0.3:" + propagation_reasoner_1.getModel(example3));
		propagation_reasoner_1 = new PropagationRankingReasoner(0.75, true, PropagationRankingReasoner.PropagationSemantics.PROPAGATION1);
		// Example that uses the multiset variant
		System.out.println("M:" + propagation_reasoner_1.getModel(example3));

		System.out.println("Propagation semantics 1+epsilon:");
		PropagationRankingReasoner propagation_reasoner_2 = new PropagationRankingReasoner(0.75, false, PropagationRankingReasoner.PropagationSemantics.PROPAGATION2);
		System.out.println("S:" + propagation_reasoner_2.getModel(example3));
		propagation_reasoner_2 = new PropagationRankingReasoner(0.75, true, PropagationRankingReasoner.PropagationSemantics.PROPAGATION2);
		System.out.println("M:" + propagation_reasoner_2.getModel(example3));

		System.out.println("Propagation semantics 1->epsilon:");
		propagation_reasoner_2 = new PropagationRankingReasoner(0.75, false, PropagationRankingReasoner.PropagationSemantics.PROPAGATION3);
		System.out.println("S:" + propagation_reasoner_2.getModel(example3));
		propagation_reasoner_2 = new PropagationRankingReasoner(0.75, true, PropagationRankingReasoner.PropagationSemantics.PROPAGATION3);
		System.out.println("M:" + propagation_reasoner_2.getModel(example3));
	}


    /** Default Constructor */
    public RankingSemanticsExample2(){}
}

org-tweetyproject-arg-rankings/src/main/java/org/tweetyproject/arg/rankings/examples/RankingSemanticsExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.rankings.examples;

import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.rankings.reasoner.BurdenBasedRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.CategorizerRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.DiscussionBasedRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.IteratedGradedDefenseReasoner;
import org.tweetyproject.arg.rankings.reasoner.ProbabilisticRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.SAFRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.StrategyBasedRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.TuplesRankingReasoner;
import org.tweetyproject.arg.rankings.util.RankingTools;
import org.tweetyproject.math.probability.Probability;

/**
 * Example code for the following ranking semantics:
 * <br> - Categorizer [Besnard, Hunter. A logic-based theory of deductive arguments. 2001]
 * <br> - Burden-Based [Amgoud, Ben-Naim. Ranking-based semantics for argumentation
 * frameworks. 2013]
 * <br> - Discussion-Based [Amgoud, Ben-Naim. Ranking-based semantics for argumentation
 * frameworks. 2013]
 * <br> - Tuples [Cayrol, Lagasquie-Schiex. Graduality in argumentation. 2005]
 * <br> - Strategy-Based [Matt, Toni. A
 * game-theoretic measure of argument strength for abstract argumentation. JELIA 2008]
 * <br> - Social Abstract Argumentation with simple product semantics [Bonzon, Delobelle, Konieczny, Maudet. A Comparative Study of Ranking-Based
 * Semantics for Abstract Argumentation. AAAI 2016]
 * <br> - Iterated Graded Defense [Grossi, Modgil. On the Graded Acceptability of Arguments. IJCAI 2015]
 * <br> - Probabilistic Graded Semantics [Thimm, Cerutti, Rienstra. Probabilistic Graded Semantics. COMMA 2018].
 *
 * @author Anna Gessler
 */
public class RankingSemanticsExample {

	/**
	 * Example
	 * @param args cmd args
	 */
	public static void main(String[] args) {
		// Example 1, taken from [Bonzon, Delobelle, Konieczny, Maudet. A Comparative
		// Study of Ranking-Based Semantics for Abstract Argumentation. AAAI 2016]
		DungTheory example1 = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		Argument e = new Argument("e");
		example1.add(a,b,c,d,e);
		example1.add(new Attack(a, e));
		example1.add(new Attack(d, a));
		example1.add(new Attack(e, d));
		example1.add(new Attack(c, e));
		example1.add(new Attack(b, c), new Attack(b, a));

		// Example 2, taken from
		// [Baumeister, Neugebauer, Rothe. Argumentation Meets Computational Social
		// Choice. Tutorial. 2018]
		DungTheory example2 = new DungTheory();
		Argument f = new Argument("f");
		example2.add(a,b,c,d,e,f);
		example2.add(new Attack(a, b));
		example2.add(new Attack(b, c));
		example2.add(new Attack(d, e));
		example2.add(new Attack(c, f));
		example2.add(new Attack(e, d),new Attack(e, c));

		// Example 3, taken from
		// [Cayrol, Lagasquie-Schiex. Graduality in argumentation. 2005]
		DungTheory example3 = new DungTheory();
		Argument a1 = new Argument("A");
		Argument b1 = new Argument("B1");
		Argument b2 = new Argument("B2");
		Argument b3 = new Argument("B3");
		Argument b4 = new Argument("B4");
		Argument c1 = new Argument("C1");
		Argument c2 = new Argument("C2");
		Argument c3 = new Argument("C3");
		Argument c4 = new Argument("C4");
		Argument d1 = new Argument("D1");
		Argument d2 = new Argument("D2");
		Argument d3 = new Argument("D3");
		Argument e1 = new Argument("E1");
		example3.add(a1,b1,b2,b3,b4);
		example3.add(c1,c2,c3,c4);
		example3.add(d1,d2,d3,e1);
		example3.add(new Attack(b1, a1));
		example3.add(new Attack(b2, a1));
		example3.add(new Attack(b3, a1));
		example3.add(new Attack(b4, a1));
		example3.add(new Attack(c1, b1));
		example3.add(new Attack(c2, b1));
		example3.add(new Attack(c3, b2));
		example3.add(new Attack(c4, b3));
		example3.add(new Attack(d1, c1));
		example3.add(new Attack(d2, c2));
		example3.add(new Attack(d3, c3));
		example3.add(new Attack(e1, d1));

		// Example 4a, taken from Figure 2 in
		// [Matt, Toni. A game-theoretic measure of argument strength for abstract argumentation. JELIA 2008]
		DungTheory example4a = new DungTheory();
		Argument g = new Argument("g");
		example4a.add(a,b,c,d,e,f,g);
		example4a.add(new Attack(b, a));
		example4a.add(new Attack(c, a));
		example4a.add(new Attack(d, a));
		example4a.add(new Attack(f, a));
		example4a.add(new Attack(e, d));
		example4a.add(new Attack(g, f));

		// Example 4b, taken from Figure 4 in
		// [Matt, Toni. A game-theoretic measure of argument strength for abstract argumentation. JELIA 2008]
		DungTheory example4b = new DungTheory();
		example4b.add(a,b,c,d,e,f);
		example4b.add(new Attack(a, b));
		example4b.add(new Attack(c, b));
		example4b.add(new Attack(d, e));
		example4b.add(new Attack(e, f),new Attack(e, b));
		example4b.add(new Attack(f, e));

		// Example 4c, taken from Figure 4 in
		// [Matt, Toni. A game-theoretic measure of argument strength for abstract argumentation. JELIA 2008]
		DungTheory example4c = new DungTheory();
		example4c.add(a,b,c,d,e,f);
		example4c.add(new Attack(a, b), new Attack(a, e));
		example4c.add(new Attack(c, b));
		example4c.add(new Attack(d, e));
		example4c.add(new Attack(e, f), new Attack(e, e), new Attack(e, b));
		example4c.add(new Attack(f, e), new Attack(f, b));

		// Example 5, taken from taken from Figure 2.4 in
		// [Delobelle, Jerome. Ranking-based Semantics for Abstract Argumentation. 2017]
		DungTheory example5 = new DungTheory();
		Argument h = new Argument("h");
		Argument i = new Argument("i");
		Argument j = new Argument("j");
		example5.add(a,b,c,d,e,f,g,h,i,j);
		example5.add(new Attack(a,b));
		example5.add(new Attack(b,c), new Attack(b,f));
		example5.add(new Attack(d,g), new Attack(d,f));
		example5.add(new Attack(e,h), new Attack(e,d), new Attack(e,i));
		example5.add(new Attack(h,g));
		example5.add(new Attack(j,i));

		// Categorizer ranking semantics
		CategorizerRankingReasoner reasoner = new CategorizerRankingReasoner();
		System.out.println(reasoner.getClass().getSimpleName());
		System.out.println(RankingTools.roundRanking(reasoner.getModel(example1), 2));
		System.out.println(RankingTools.roundRanking(reasoner.getModel(example2), 3));

		// Burden-based ranking semantics
		BurdenBasedRankingReasoner reasoner2 = new BurdenBasedRankingReasoner();
		System.out.println(reasoner2.getClass().getSimpleName());
		System.out.println(reasoner2.getModel(example1));
		System.out.println(reasoner2.getModel(example2));
		System.out.println(reasoner2.getModel(example5));

		// Discussion-based ranking semantics
		DiscussionBasedRankingReasoner reasoner3 = new DiscussionBasedRankingReasoner();
		System.out.println(reasoner3.getClass().getSimpleName());
		System.out.println(reasoner3.getModel(example1));
		System.out.println(reasoner3.getModel(example2));

		// Tuples* ranking semantics
		TuplesRankingReasoner reasoner4 = new TuplesRankingReasoner();
		System.out.println(reasoner4.getClass().getSimpleName());
		System.out.println(reasoner4.getModel(example5));
		System.out.println(reasoner4.prettyPrintTupledValues());
		System.out.println(reasoner4.getModel(example3));
		System.out.println(reasoner4.prettyPrintTupledValues());

		// Strategy based ranking semantics (Matt & Toni)
		StrategyBasedRankingReasoner reasoner5 = new StrategyBasedRankingReasoner();
		System.out.println(reasoner5.getClass().getSimpleName());
		System.out.println(RankingTools.roundRanking(reasoner5.getModel(example1),2));
		System.out.println(RankingTools.roundRanking(reasoner5.getModel(example4a),3));
		System.out.println(RankingTools.roundRanking(reasoner5.getModel(example4b),3));
		System.out.println(RankingTools.roundRanking(reasoner5.getModel(example4c),3));

		// Social Abstract Argumentation framework with simple product semantics
		SAFRankingReasoner reasoner6 = new SAFRankingReasoner();
		System.out.println(reasoner6.getClass().getSimpleName());
		System.out.println(RankingTools.roundRanking(reasoner6.getModel(example1), 2));

		// Iterated graded defense (Grossi & Modgil) ranking semantics
		IteratedGradedDefenseReasoner reasoner7 = new IteratedGradedDefenseReasoner();
		System.out.println(reasoner7.getClass().getSimpleName());
		System.out.println(reasoner7.getModel(example1));

		// Probabilistic graded ranking semantic [Thimm, Cerutti, Rienstra; 2018]
		ProbabilisticRankingReasoner reasoner8 = new ProbabilisticRankingReasoner(Semantics.GROUNDED_SEMANTICS,	new Probability(0.5), true);
		System.out.println(reasoner8.getClass().getSimpleName());
		System.out.println(reasoner8.getModel(example2));
	}



    /** Default Constructor */
    public RankingSemanticsExample(){}
}

org-tweetyproject-arg-rankings/src/main/java/org/tweetyproject/arg/rankings/examples/RankingPostulatesExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.rankings.examples;

import java.util.Collection;
import java.util.HashSet;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;
import org.tweetyproject.arg.dung.util.EnumeratingDungTheoryGenerator;
import org.tweetyproject.arg.rankings.postulates.RankingPostulate;
import org.tweetyproject.arg.rankings.reasoner.BurdenBasedRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.CategorizerRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.CountingRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.DiscussionBasedRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.PropagationRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.SAFRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.StrategyBasedRankingReasoner;
import org.tweetyproject.arg.rankings.reasoner.TuplesRankingReasoner;
import org.tweetyproject.commons.postulates.PostulateEvaluator;

/**
 * Example code for evaluating ranking semantics in regard to postulates.
 * Each postulate represents a single property that characterizes how the semantics ranks arguments.
 *
 * @author Anna Gessler
 */
public class RankingPostulatesExample {

    private static Collection<RankingPostulate> all_postulates;

    /**
     * Main method that initializes the postulates and runs the different ranking reasoner examples.
     *
     * @param args Command line arguments (not used)
     */
    public static void main(String[] args) {
        all_postulates = new HashSet<RankingPostulate>();
        all_postulates.add(RankingPostulate.ABSTRACTION);
        all_postulates.add(RankingPostulate.ADDITIONOFATTACKBRANCH);
        all_postulates.add(RankingPostulate.ADDITIONOFDEFENSEBRANCH);
        all_postulates.add(RankingPostulate.ATTACKVSFULLDEFENSE);
        all_postulates.add(RankingPostulate.CARDINALITYPRECEDENCE);
        all_postulates.add(RankingPostulate.COUNTERTRANSITIVITY);
        all_postulates.add(RankingPostulate.DEFENSEPRECEDENCE);
        all_postulates.add(RankingPostulate.DISTDEFENSEPRECEDENCE);
        all_postulates.add(RankingPostulate.INCREASEOFATTACKBRANCH);
        all_postulates.add(RankingPostulate.INCREASEOFDEFENSEBRANCH);
        all_postulates.add(RankingPostulate.INDEPENDENCE);
        all_postulates.add(RankingPostulate.NONATTACKEDEQUIVALENCE);
        all_postulates.add(RankingPostulate.QUALITYPRECEDENCE);
        all_postulates.add(RankingPostulate.SELFCONTRADICTION);
        all_postulates.add(RankingPostulate.STRICTADDITIONOFDEFENSEBRANCH);
        all_postulates.add(RankingPostulate.STRICTCOUNTERTRANSITIVITY);
        all_postulates.add(RankingPostulate.TOTAL);
        all_postulates.add(RankingPostulate.VOIDPRECEDENCE);

        CategorizerExample();
        BurdenExample();
        DiscussionExample();
        TuplesExample();
        StrategyBasedExample();
        SAFExample();
        CountingExample();
        PropagationExample();
    }

    /**
     * Evaluates the CategorizerRankingReasoner against all postulates and prints the results.
     */
    public static void CategorizerExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg,
                new CategorizerRankingReasoner());
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(4000, false).prettyPrint());
    }

    /**
     * Evaluates the BurdenBasedRankingReasoner against all postulates and prints the results.
     */
    public static void BurdenExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg,
                new BurdenBasedRankingReasoner());
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(100, false).prettyPrint());
    }

    /**
     * Evaluates the DiscussionBasedRankingReasoner against all postulates and prints the results.
     */
    public static void DiscussionExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg,
                new DiscussionBasedRankingReasoner());
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(2000, false).prettyPrint());
    }

    /**
     * Evaluates the TuplesRankingReasoner against all postulates and prints the results.
     */
    public static void TuplesExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg,
                new TuplesRankingReasoner());
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(4000, false).prettyPrint());
    }

    /**
     * Evaluates the StrategyBasedRankingReasoner against all postulates and prints the results.
     */
    public static void StrategyBasedExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg,
                new StrategyBasedRankingReasoner());
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(10, false).prettyPrint());
    }

    /**
     * Evaluates the SAFRankingReasoner against all postulates and prints the results.
     */
    public static void SAFExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg,
                new SAFRankingReasoner());
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(2000, false).prettyPrint());
    }

    /**
     * Evaluates the CountingRankingReasoner against all postulates and prints the results.
     */
    public static void CountingExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg,
                new CountingRankingReasoner());
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(2000, false).prettyPrint());
    }

    /**
     * Evaluates the PropagationRankingReasoner against all postulates and prints the results.
     */
    public static void PropagationExample() {
        DungTheoryGenerator dg = new EnumeratingDungTheoryGenerator();
        PropagationRankingReasoner propagation_reasoner = new PropagationRankingReasoner(0.75, false,
                PropagationRankingReasoner.PropagationSemantics.PROPAGATION1);
        PostulateEvaluator<Argument, DungTheory> evaluator = new PostulateEvaluator<>(dg, propagation_reasoner);
        evaluator.addAllPostulates(all_postulates);
        System.out.println(evaluator.evaluate(2000, false).prettyPrint());
    }

    /** Default Constructor */
    public RankingPostulatesExample() {
    }
}


org-tweetyproject-arg-rankings/src/main/java/org/tweetyproject/arg/rankings/examples/ProbabilisticRankingReasonerExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.rankings.examples;

import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.rankings.reasoner.ProbabilisticRankingReasoner;
import org.tweetyproject.math.probability.Probability;

/**
 * Example code for using the probabilistic ranking reasoner based on the ideas from
 * [Thimm, Cerutti, Rienstra. Probabilistic Graded Semantics. COMMA 2018].
 *
 * @author Matthias Thimm
 */
public class ProbabilisticRankingReasonerExample {
	/**
	 * Example
	 * @param args cmd args
	 */
	public static void main(String[] args){
		//Construct AAF
		DungTheory theory = new DungTheory();
		Argument a1 = new Argument("a1");
		Argument a2 = new Argument("a2");
		Argument a3 = new Argument("a3");
		Argument a4 = new Argument("a4");

		theory.add(a1);
		theory.add(a2);
		theory.add(a3);
		theory.add(a4);

		theory.add(new Attack(a1,a2));
		theory.add(new Attack(a2,a3));
		theory.add(new Attack(a3,a4));

		System.out.println(theory);

		// Compute probabilistic ranking wrt. grounded semantics, credoulous reasoning, and p=0.5
		ProbabilisticRankingReasoner reasoner = new ProbabilisticRankingReasoner(Semantics.GROUNDED_SEMANTICS,new Probability(0.5),true);

		System.out.println(reasoner.getModel(theory));
	}

    /** Default Constructor */
    public ProbabilisticRankingReasonerExample(){}
}

org-tweetyproject-arg-rankings/src/main/java/org/tweetyproject/arg/rankings/examples/IteratedGradedDefenseReasonerExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.rankings.examples;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.rankings.reasoner.IteratedGradedDefenseReasoner;

/**
 * Example code for using the iterated graded semantics from
 * [Grossi, Modgil. On the Graded Acceptability of Arguments. IJCAI 2015].
 *
 * @author Matthias Thimm
 *
 */
public class IteratedGradedDefenseReasonerExample {

	/**
	 * Main method to show example
	 * @param args cmd line args
	 */
	public static void main(String[] args){
		// Taken from Figure 3 in
		// [Grossi, Modgil. On the Graded Acceptability of Arguments. IJCAI 2015]
		DungTheory theory = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		Argument e = new Argument("e");
		Argument f = new Argument("f");
		Argument g = new Argument("g");
		theory.add(a);
		theory.add(b);
		theory.add(c);
		theory.add(d);
		theory.add(e);
		theory.add(f);
		theory.add(g);
		theory.add(new Attack(d,c));
		theory.add(new Attack(c,a));
		theory.add(new Attack(a,b));
		theory.add(new Attack(b,a));
		theory.add(new Attack(e,b));
		theory.add(new Attack(f,e));
		theory.add(new Attack(g,e));

		IteratedGradedDefenseReasoner reasoner = new IteratedGradedDefenseReasoner();

		for(int m = 1; m < theory.size(); m++)
			for(int n = 1; n < theory.size(); n++)
				System.out.println(m + "," + n + " : " + reasoner.getAllMNCompleteExtensions(theory,m, n));
	}

	/** Default Constructor */
    public IteratedGradedDefenseReasonerExample(){}
}

org-tweetyproject-arg-rankings/src/main/java/org/tweetyproject/arg/rankings/examples/CounterTransitivityReasonerExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2021 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.rankings.examples;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.rankings.reasoner.CounterTransitivityReasoner;
import org.tweetyproject.comparator.LatticePartialOrder;

/**
 * Demonstrates the usage of the {@link CounterTransitivityReasoner} with a specific Argumentation Framework (AAF).
 * <p>
 * This example constructs an argumentation framework, adds arguments and attacks to it, and then creates a
 * {@link LatticePartialOrder} to specify the acceptability relations between arguments. It then uses a
 * {@link CounterTransitivityReasoner} to evaluate various ranking strategies and prints the results.
 * </p>
 */
public class CounterTransitivityReasonerExample {

	   /**
     * The main method that sets up an argumentation framework, applies various ranking strategies, and prints the results.
     *
     * @param args Command-line arguments (not used in this example).
     */
	public static void main(String[] args) {

		//Construct AAF
		DungTheory theory = new DungTheory();
		Argument a1 = new Argument("a");
		Argument a2 = new Argument("b");
		Argument a3 = new Argument("c");
		Argument a4 = new Argument("d");
		Argument a5 = new Argument("e");
		Argument a6 = new Argument("f");

		theory.add(a1);
		theory.add(a2);
		theory.add(a3);
		theory.add(a4);
		theory.add(a5);
		theory.add(a6);

		theory.add(new Attack(a1,a2));
		theory.add(new Attack(a2,a1));
		theory.add(new Attack(a1,a5));
		theory.add(new Attack(a2,a3));
		theory.add(new Attack(a5,a4));
		theory.add(new Attack(a4,a1));
		theory.add(new Attack(a3,a5));
		theory.add(new Attack(a6,a3));

		LatticePartialOrder<Argument, DungTheory> lat = new LatticePartialOrder<Argument, DungTheory>(theory);

		lat.setStrictlyLessOrEquallyAcceptableThan(a2, a5);
		lat.setStrictlyLessOrEquallyAcceptableThan(a5, a2);
		lat.setStrictlyLessOrEquallyAcceptableThan(a2, a6);
		lat.setStrictlyLessOrEquallyAcceptableThan(a6, a2);
		lat.setStrictlyLessOrEquallyAcceptableThan(a1, a3);
		lat.setStrictlyLessOrEquallyAcceptableThan(a3, a1);
		lat.setStrictlyLessOrEquallyAcceptableThan(a1, a4);
		lat.setStrictlyLessOrEquallyAcceptableThan(a4, a1);
		lat.setStrictlyLessOrEquallyAcceptableThan(a1, a2);

		CounterTransitivityReasoner r = new CounterTransitivityReasoner(CounterTransitivityReasoner.solver.quality, lat);


		System.out.println("cardinality: " +r.cardinality(theory).toString());
		System.out.println("quality: " +  r.quality(theory, lat).toString());
		System.out.println("quality first: " +  r.qualityFirst(theory, lat).toString());
		System.out.println("cardinality first: " +r.cardinalityFirst(theory, lat).toString());
		System.out.println("gfp: " +r.gfpCardinality(theory).toString());
		System.out.println("dominance: " +r.simpleDominance(theory, lat).toString());
		System.out.println("call by getModel (quality): " +r.getModel(theory).toString());
	}

    /** Default Constructor */
    public CounterTransitivityReasonerExample(){}
}

org-tweetyproject-arg-prob/src/main/java/org/tweetyproject/arg/prob/examples/SubgraphProbExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.prob.examples;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.prob.lotteries.SubgraphProbabilityFunction;

/**
 * Example code for showing how to work with subgraph probability distributions
 * and updates.
 *
 * @author Matthias Thimm
 *
 */
public class SubgraphProbExample {

	/** Default */
	public SubgraphProbExample() {
	}

	/**
	 * This method demonstrates the use of a Dung argumentation framework (AAF) and
	 * a subgraph probability function.
	 * It includes the following steps:
	 *
	 * 1. Creating a Dung argumentation theory with three arguments (a, b, and c)
	 * and multiple attacks.
	 * 2. Initializing and printing the subgraph probability function for the
	 * theory.
	 * 3. Performing a rough update of the subgraph probability function by
	 * modifying the argumentation theory.
	 * 4. Printing the updated subgraph probability function and checking if the
	 * updated probability distribution is normalized.
	 *
	 * The method provides a basic example of how to use the TweetyProject libraries
	 * to work with argumentation frameworks and probabilistic reasoning.
	 *
	 * @param args Command-line arguments (not used in this example).
	 */
	public static void main(String[] args) {
		// create some Dung theory
		DungTheory theory = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		theory.add(a);
		theory.add(b);
		theory.add(c);
		theory.add(new Attack(a, b));
		theory.add(new Attack(b, a));
		theory.add(new Attack(c, b));

		System.out.println(theory);
		System.out.println();

		SubgraphProbabilityFunction prob = new SubgraphProbabilityFunction(theory);

		for (DungTheory key : prob.keySet())
			System.out.println(key + "\t" + prob.probability(key));
		System.out.println();

		DungTheory upd = new DungTheory();
		upd.add(a);

		prob = prob.roughUpdate(upd);

		for (DungTheory key : prob.keySet())
			System.out.println(key + "\t" + prob.probability(key));
		System.out.println(prob.isNormalized());
	}
}

org-tweetyproject-arg-prob/src/main/java/org/tweetyproject/arg/prob/examples/PAInconsistencyMeasureExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.prob.examples;

import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.prob.analysis.PAInconsistencyMeasure;
import org.tweetyproject.arg.prob.dynamics.*;
import org.tweetyproject.arg.prob.semantics.*;
import org.tweetyproject.arg.prob.syntax.PartialProbabilityAssignment;
import org.tweetyproject.math.func.EntropyFunction;
import org.tweetyproject.math.norm.*;
import org.tweetyproject.math.probability.Probability;

/**
 * Example code for the PAInconsistencyMeasure.
 *
 * @author Matthias Thimm
 *
 */
public class PAInconsistencyMeasureExample {

	/** Default */
	public PAInconsistencyMeasureExample() {

	}

	/**
	 * This method demonstrates how to calculate an inconsistency measure for
	 * argumentation theory
	 * with a partial probability assignment and apply a change operator to update
	 * the probability
	 * assignment based on argumentation semantics and entropy.
	 *
	 * The demonstration includes the following steps:
	 * 1. Constructing a argumentation theory with three arguments (A, B, and
	 * C) and three attacks.
	 * 2. Creating a partial probability assignment with a specific probability for
	 * argument A.
	 * 3. Using a PA inconsistency measure to assess the inconsistency of the
	 * partial probability assignment.
	 * 4. Applying a change operator to update the partial probability assignment
	 * based on a coherent semantics
	 * and entropy-based reasoning.
	 *
	 * @param args Command-line arguments (not used in this example).
	 */
	public static void main(String[] args) {
		DungTheory theory = new DungTheory();
		Argument a = new Argument("A");
		Argument b = new Argument("B");
		Argument c = new Argument("C");
		theory.add(a);
		theory.add(b);
		theory.add(c);
		theory.add(new Attack(a, b));
		theory.add(new Attack(b, c));
		theory.add(new Attack(a, c));

		PartialProbabilityAssignment ppa = new PartialProbabilityAssignment();
		ppa.put(a, new Probability(0.9));

		PAInconsistencyMeasure mes = new PAInconsistencyMeasure(new PNorm(2), theory, new SemiOptimisticPASemantics());

		System.out.println(mes.inconsistencyMeasure(ppa));

		ChangeOperator op = new PAUpdateOperator(new CoherentPASemantics(), new EntropyNorm<Extension<DungTheory>>(),
				new EntropyFunction());

		System.out.println(op.change(ppa, theory));
	}
}

org-tweetyproject-arg-prob/src/main/java/org/tweetyproject/arg/prob/examples/LotteryExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.prob.examples;

import java.util.Collection;

import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.divisions.Division;
import org.tweetyproject.arg.dung.reasoner.SimpleGroundedReasoner;
import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.prob.lotteries.ArgumentationLottery;
import org.tweetyproject.arg.prob.lotteries.SubgraphProbabilityFunction;
import org.tweetyproject.arg.prob.lotteries.UtilityFunction;

/**
 * Example code for working with lotteries in probabilistic abstract
 * argumentation.
 *
 * @author Matthias Thimm
 *
 */
public class LotteryExample {

	/** Deafult */
	public LotteryExample() {

	}

	/**
	 * Demonstrates the construction and analysis of a Dung argumentation framework
	 * (AAF) using
	 * the TweetyProject libraries. This example constructs a Dung theory, computes
	 * extensions
	 * using the grounded semantics, calculates probabilities over subgraphs, and
	 * performs
	 * various operations involving divisions, lotteries, and utility functions.
	 *
	 * The example includes:
	 * - Creating a Dung argumentation framework with three arguments (a, b, c) and
	 * attacks between them.
	 * - Computing grounded extensions of the argumentation framework using a simple
	 * grounded reasoner.
	 * - Printing the argumentation framework, extensions, and divisions.
	 * - Computing and printing a uniform probability distribution over all
	 * subgraphs of the argumentation framework.
	 * - Calculating and printing acceptance probabilities for various divisions and
	 * individual arguments.
	 * - Constructing and evaluating an argumentation lottery based on standard
	 * divisions and computing the expected utility
	 * with respect to a specific utility function.
	 *
	 * @param args Command-line arguments (not used in this example).
	 */

	public static void main(String[] args) {
		// create some Dung theory
		DungTheory theory = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		theory.add(a);
		theory.add(b);
		theory.add(c);
		theory.add(new Attack(a, b));
		theory.add(new Attack(b, a));
		theory.add(new Attack(c, b));

		// Instantiate reasoner
		AbstractExtensionReasoner r = new SimpleGroundedReasoner();
		Collection<Extension<DungTheory>> exts = r.getModels(theory);

		// print theory
		System.out.println("AAF: " + theory);

		// print extensions
		System.out.println();
		System.out.println("Extensions: ");
		for (Extension<DungTheory> e : exts)
			System.out.println(e);

		// print divisions
		System.out.println();
		System.out.println("Divisions: ");
		for (Division div : Division.getDivisions(exts, theory)) {
			System.out.println(div);
		}

		// print the uniform probability function
		SubgraphProbabilityFunction prob = new SubgraphProbabilityFunction(theory);
		System.out.println();
		System.out.println("Uniform probability function over all sub graphs: ");
		for (DungTheory key : prob.keySet())
			System.out.println("\t" + key + "\t=\t" + prob.probability(key));
		System.out.println();
		System.out.println("Probabilities of some divisions: ");
		// ---
		Extension<DungTheory> a1 = new Extension<DungTheory>();
		Extension<DungTheory> a2 = new Extension<DungTheory>();
		a1.add(a);
		a2.add(b);
		Division d1 = new Division(a1, a2);
		System.out.println("\t" + d1 + "\t=\t" + prob.getAcceptanceProbability(d1, Semantics.GROUNDED_SEMANTICS));
		// ---
		a1 = new Extension<DungTheory>();
		a2 = new Extension<DungTheory>();
		a1.add(a);
		d1 = new Division(a1, a2);
		System.out.println("\t" + d1 + "\t=\t" + prob.getAcceptanceProbability(d1, Semantics.GROUNDED_SEMANTICS));
		// ---
		a1 = new Extension<DungTheory>();
		a2 = new Extension<DungTheory>();
		a1.add(a);
		a1.add(b);
		d1 = new Division(a1, a2);
		System.out.println("\t" + d1 + "\t=\t" + prob.getAcceptanceProbability(d1, Semantics.GROUNDED_SEMANTICS));
		// ---
		a1 = new Extension<DungTheory>();
		a2 = new Extension<DungTheory>();
		a1.add(a);
		a1.add(c);
		a2.add(b);
		a2.add(a);
		d1 = new Division(a1, a2);
		System.out.println("\t" + d1 + "\t=\t" + prob.getAcceptanceProbability(d1, Semantics.GROUNDED_SEMANTICS));
		// ---
		a1 = new Extension<DungTheory>();
		a2 = new Extension<DungTheory>();
		a1.add(a);
		a1.add(c);
		a2.add(b);
		d1 = new Division(a1, a2);
		System.out.println("\t" + d1 + "\t=\t" + prob.getAcceptanceProbability(d1, Semantics.GROUNDED_SEMANTICS));

		System.out.println();
		System.out.println("Probabilities of arguments: ");
		// ---
		System.out.println("\t" + a + "\t=\t" + prob.getAcceptanceProbability(a, Semantics.GROUNDED_SEMANTICS));
		System.out.println("\t" + b + "\t=\t" + prob.getAcceptanceProbability(a, Semantics.GROUNDED_SEMANTICS));
		System.out.println("\t" + c + "\t=\t" + prob.getAcceptanceProbability(a, Semantics.GROUNDED_SEMANTICS));

		// lotteries
		Collection<Division> stDivisions = Division.getStandardDivisions(theory);
		ArgumentationLottery lottery = new ArgumentationLottery(stDivisions, prob, Semantics.GROUNDED_SEMANTICS);
		System.out.println();
		System.out.println("A lottery with standard set of divisions (see Proposition 8): ");
		System.out.println("\t" + lottery);

		UtilityFunction util = new UtilityFunction();
		util.put((Division) stDivisions.toArray()[2], 12d);
		util.put((Division) stDivisions.toArray()[4], 7d);
		util.put((Division) stDivisions.toArray()[6], -2d);
		System.out.println();
		System.out.println("Some utility function: ");
		System.out.println("\t" + util);

		System.out.println();
		System.out.println("The expected utility on the lottery: " + util.getExpectedUtility(lottery));
	}
}

org-tweetyproject-arg-extended/src/main/java/org/tweetyproject/arg/extended/examples/RecursiveExtendedTheoryExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2024 The TweetyProject Team <http://tweetyproject.org/contact/>
 */

 package org.tweetyproject.arg.extended.examples;

 import org.tweetyproject.arg.dung.syntax.Argument;
 import org.tweetyproject.arg.extended.reasoner.SimpleRecursiveExtendedCompleteReasoner;
 import org.tweetyproject.arg.extended.syntax.ExtendedAttack;
 import org.tweetyproject.arg.extended.syntax.RecursiveExtendedTheory;

 /**
  * This class provides an example demonstrating the usage of Recursive Extended Argumentation Frameworks
  * with standard and extended attacks.
  *
  * The example constructs a recursive extended theory and adds various arguments and attacks,
  * both standard and recursive. It also computes the complete extensions of the theory.
  *
  * @author Lars Bengel
  */
 public class RecursiveExtendedTheoryExample {

     /**
      * Default constructor for the {@code RecursiveExtendedTheoryExample} class.
      *
      * This constructor does not perform any specific initialization but is
      * explicitly provided to adhere to good coding practices.
      */
     public RecursiveExtendedTheoryExample() {
         // No specific initialization required
     }

     /**
      * The main method demonstrating how to construct a Recursive Extended Theory,
      * add arguments, standard attacks, and extended attacks, and compute the complete extensions.
      *
      * @param args command line arguments (not used in this example)
      */
     public static void main(String[] args) {
         // Create a new Recursive Extended Theory
         RecursiveExtendedTheory theory = new RecursiveExtendedTheory();

         // Create arguments
         Argument a = new Argument("a");
         Argument b = new Argument("b");
         Argument c = new Argument("c");
         Argument d = new Argument("d");
         Argument e = new Argument("e");
         Argument f = new Argument("f");

         // Add arguments to the theory
         theory.add(a, b, c, d, e, f);

         // Add standard attacks between arguments
         theory.addAttack(a, b);
         theory.addAttack(b, a);
         theory.addAttack(d, c);
         theory.addAttack(c, d);

         // Create extended attacks
         ExtendedAttack ab = new ExtendedAttack(a, b);
         ExtendedAttack ba = new ExtendedAttack(b, a);
         ExtendedAttack cd = new ExtendedAttack(c, d);
         ExtendedAttack ecd = new ExtendedAttack(e, cd);

         // Add extended attacks between arguments and existing attacks
         theory.addAttack(c, ba);
         theory.addAttack(d, ab);
         theory.addAttack(e, cd);
         theory.addAttack(f, ecd);

         // Print the recursive extended theory
         System.out.println(theory.prettyPrint());

         // Compute and print the complete extensions of the theory
         System.out.println("Complete Extensions: " + new SimpleRecursiveExtendedCompleteReasoner().getModels(theory));
     }
 }

 org-tweetyproject-arg-extended/src/main/java/org/tweetyproject/arg/extended/examples/ExtendedTheoryExample.java

 /*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2024 The TweetyProject Team <http://tweetyproject.org/contact/>
 */

package org.tweetyproject.arg.extended.examples;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.extended.reasoner.SimpleExtendedCompleteReasoner;
import org.tweetyproject.arg.extended.syntax.ExtendedTheory;

/**
 * Example usage of Extended Argumentation Frameworks
 *
 * @author Lars Bengel
 */
public class ExtendedTheoryExample {

    /** Default */
    public ExtendedTheoryExample() {
    }

    /**
     * Demonstrates the construction of an extended Dung argumentation theory and
     * the use of an extended reasoner.
     *
     * The following steps are performed:
     * 1. Constructs an extended argumentation theory with arguments (a, b, c, d,
     * e).
     * 2. Adds standard attacks between arguments.
     * 3. Adds extended attacks where arguments can attack other attacks.
     * 4. Prints the argumentation theory in a readable format.
     * 5. Computes and prints the complete extensions using the
     * {@link SimpleExtendedCompleteReasoner}.
     *
     * This example illustrates how to create both standard and extended attacks
     * within a Dung argumentation framework,
     * and how to use reasoning to compute extensions.
     *
     * @param args Command-line arguments (not used in this example).
     */


     /**
      *  Example theory
      * @param args cl arg
      */
    public static void main(String[] args) {
        ExtendedTheory theory = new ExtendedTheory();
        Argument a = new Argument("a");
        Argument b = new Argument("b");
        Argument c = new Argument("c");
        Argument d = new Argument("d");
        Argument e = new Argument("e");
        theory.add(a, b, c, d, e);

        // standard attacks
        theory.addAttack(a, b);
        theory.addAttack(b, a);
        theory.addAttack(d, c);
        theory.addAttack(c, d);

        // extended attacks
        Attack ab = new Attack(a, b);
        Attack ba = new Attack(b, a);
        Attack cd = new Attack(c, d);
        theory.addAttack(c, ba);
        theory.addAttack(d, ab);
        theory.addAttack(e, cd);

        System.out.println(theory.prettyPrint());

        System.out.println("Complete Extensions: " + new SimpleExtendedCompleteReasoner().getModels(theory));
    }
}

org-tweetyproject-arg-dung/src/main/resources/ex1.tgf

a
b
c
d
#
a b
b c
c a
c d
d c
d d

org-tweetyproject-arg-dung/src/main/java/org/tweetyproject/arg/dung/examples/VacuousReductReasonerExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.dung.examples;

import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.reasoner.SimpleConflictFreeReasoner;
import org.tweetyproject.arg.dung.reasoner.StronglyUndisputedReasoner;
import org.tweetyproject.arg.dung.reasoner.UndisputedReasoner;
import org.tweetyproject.arg.dung.reasoner.VacuousReductReasoner;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;

/**
 * example for the vacuous reduct reasoner
 * @author Matthias Thimm
 *
 */
public class VacuousReductReasonerExample {
	/**
	 * 
	 * @param reasoner the reasoner 
	 */
	public static void example1(AbstractExtensionReasoner reasoner) {
		// AF: ({a,b},{(a,a),(a,b)})
		DungTheory af = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		af.add(a);
		af.add(b);
		af.add(new Attack(a,a));
		af.add(new Attack(a,b));
		
		System.out.println("AF: " + af);
		System.out.println("Extensions: " + reasoner.getModels(af));
	}
	/**
	 * 
	 * @param reasoner the reasoner
	 */
	public static void example2(AbstractExtensionReasoner reasoner) {
		// AF: ({a1,a2,a3,b},{(a1,a3),(a3,a2),(a2,a1),(a1,b)})
		DungTheory af = new DungTheory();
		Argument a1 = new Argument("a1");
		Argument a2 = new Argument("a2");
		Argument a3 = new Argument("a3");
		Argument b = new Argument("b");
		af.add(a1);
		af.add(a2);
		af.add(a3);
		af.add(b);
		af.add(new Attack(a1,a3));
		af.add(new Attack(a3,a2));
		af.add(new Attack(a2,a1));
		af.add(new Attack(a1,b));
		
		System.out.println("AF: " + af);
		System.out.println("Extensions: " + reasoner.getModels(af));
	}
	
	/**
	 * 
	 * @param reasoner the reasoner
	 */
	public static void example3(AbstractExtensionReasoner reasoner) {
		// AF: ({a,b,c,d},{(a,b),(b,c),(c,a),(d,d),(d,a),(d,b),(d,c)})
		DungTheory af = new DungTheory();
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		af.add(a);
		af.add(b);
		af.add(c);
		af.add(d);
		af.add(new Attack(a,b));
		af.add(new Attack(b,c));
		af.add(new Attack(c,a));
		af.add(new Attack(d,d));
		af.add(new Attack(d,a));
		af.add(new Attack(d,b));
		af.add(new Attack(d,c));
		
		System.out.println("AF: " + af);
		System.out.println("Extensions: " + reasoner.getModels(af));
	}
	/**
	 * 
	 * @param args arguments
	 */
	public static void main(String[] args) {
		VacuousReductReasoner udReasoner = new UndisputedReasoner();
		System.out.println("Undisputed (=cf^adm) Semantics:");
		example1(udReasoner);
		example2(udReasoner);
		example3(udReasoner);
		System.out.println("================");
		
		VacuousReductReasoner sudReasoner = new StronglyUndisputedReasoner();
		System.out.println("Strongly Undisputed (=cf^cf^adm) Semantics:");
		example1(sudReasoner);
		example2(sudReasoner);
		example3(sudReasoner);
		System.out.println("================");
		
		VacuousReductReasoner cf3Reasoner = new VacuousReductReasoner(new SimpleConflictFreeReasoner(),sudReasoner);
		System.out.println("cf^cf^cf^adm Semantics:");
		example1(cf3Reasoner);
		example2(cf3Reasoner);
		example3(cf3Reasoner);
		System.out.println("================");
		
		VacuousReductReasoner cf4Reasoner = new VacuousReductReasoner(new SimpleConflictFreeReasoner(),cf3Reasoner);
		System.out.println("cf^cf^cf^cf^adm Semantics:");
		example1(cf4Reasoner);
		example2(cf4Reasoner);
		example3(cf4Reasoner);
	}
}

org-tweetyproject-arg-dung/src/main/java/org/tweetyproject/arg/dung/examples/ResolutionbasedSolverTest.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2021 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.dung.examples;


import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.DungTheory;

/**
 * Demonstrates the use of resolution-based solvers on Dung argumentation frameworks.
 * This class provides an example setup of a simple Dung theory and illustrates how to apply
 * resolution-based reasoning to determine acceptable arguments under various semantics.
 * The main focus is on testing the functionality of resolution-based solvers such as preferred
 * and admissible semantics reasoners.
 * 
 * @author Sebastian Franke
 */

public class ResolutionbasedSolverTest {

    /**
     * Main method to run the resolution-based solver test. It constructs a simple Dung theory with
     * arguments and attacks and applies resolution-based reasoners to determine the sets of acceptable arguments.
     * Uncomment the reasoner lines and add appropriate reasoners to see the output.
     * 
     * @param args Command-line arguments, not used in this example.
     */
	public static void main(String[] args) {
        DungTheory ex1 = new DungTheory();


        Argument a = new Argument("a");
        Argument b = new Argument("b");
        Argument c = new Argument("c");
        Argument d = new Argument("d");

        ex1.add(a);
        ex1.add(b);
        ex1.add(c);
        ex1.add(d);
        ex1.addAttack(a, b);
        ex1.addAttack(b, a);
        ex1.addAttack(c, d);
        ex1.addAttack(d, c);
        ex1.addAttack(a, c);


       // SimpleResolutionBasedReasoner re= new SimpleResolutionBasedReasoner(new SimplePreferredReasoner());
//SimpleAdmissibleReasoner ad = new SimpleAdmissibleReasoner();
        //System.out.println(re.getModels(ex1));
       // System.out.println(ad.getModels(ex1));
        


	}
}

org-tweetyproject-arg-dung/src/main/java/org/tweetyproject/arg/dung/examples/KwtGeneratorExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2022 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.dung.examples;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;

import org.tweetyproject.arg.dung.reasoner.AbstractAcceptabilityReasoner;
import org.tweetyproject.arg.dung.reasoner.IaqAcceptabilityReasoner;
import org.tweetyproject.arg.dung.reasoner.ProboReasoner;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.dung.util.KwtDungTheoryGenerator;
import org.tweetyproject.arg.dung.writer.TgfWriter;
import org.tweetyproject.commons.InferenceMode;

/**
 * 
 * Example code for generating a lot of KWT graphs.
 * 
 * @author Matthias Thimm
 *
 */
public class KwtGeneratorExample {
	/**
	 * 
	 * @param args command line arguments
	 * @throws IOException when Input goes wrong
	 */
	public static void main(String[] args) throws IOException {
		String path = args[0]; // enter path where graphs and solutions should be stored
		// add path of any ICCMA-compliant solver supporting DS-PR
		AbstractAcceptabilityReasoner reasoner = new IaqAcceptabilityReasoner(new ProboReasoner("/Users/mthimm/Documents/software/misc_bins/mu-toksia-glucose-2020-03-12", Semantics.PR),InferenceMode.SKEPTICAL);
		int[] i_num_arguments = {150};
		double[] i_num_skept_arguments = {0.4,0.5,0.6};
		double[] i_size_ideal_extension = {0.5};
		double[] i_num_cred_arguments = {0.1,0.4};
		int[] i_num_pref_exts = {100,200};
		
		double[] i_p_ideal_attacked = {0.3,0.5};
		double[] i_p_ideal_attack_back = {0.2,0.4};
		double[] i_p_other_skept_args_attacked = {0.3,0.5};
		double[] i_p_other_skept_args_attack_back = {0.2,0.4};
		double[] i_p_cred_args_attacked = {0.3,0.5};
		double[] i_p_cred_args_attack_back = {0.2,0.4};
		double[] i_p_other_attacks = {0.2,0.3};
		
		int num = 1;
		int offset = 1;
		
		TgfWriter writer = new TgfWriter();
		for(int i: i_num_arguments)
			for(double j: i_num_skept_arguments)
				for(double k: i_size_ideal_extension)
						for(double m: i_num_cred_arguments)
							for(int n: i_num_pref_exts)
								for(double o: i_p_ideal_attacked)
									for(double p: i_p_ideal_attack_back)
										for(double q: i_p_other_skept_args_attacked)
											for(double r: i_p_other_skept_args_attack_back)
												for(double s: i_p_cred_args_attacked)
													for(double t: i_p_cred_args_attack_back)
														for(double u: i_p_other_attacks) {
															int num_arguments = i;
															int num_skept_arguments = (int) Math.round(j*i);
															int size_ideal_extension = (int) Math.round(k*num_skept_arguments);
															int num_cred_arguments = (int) Math.round(m*i);;
															int num_pref_exts = n;
															double p_ideal_attacked = o;
															double p_ideal_attack_back = p;
															double p_other_skept_args_attacked = q;
															double p_other_skept_args_attack_back = r;
															double p_cred_args_attacked = s;
															double p_cred_args_attack_back = t;
															double p_other_attacks = u;
															KwtDungTheoryGenerator gen = new KwtDungTheoryGenerator(
																	num_arguments,
																	num_skept_arguments,
																	size_ideal_extension,
																	num_cred_arguments,
																	num_pref_exts,
																	p_ideal_attacked,
																	p_ideal_attack_back,
																	p_other_skept_args_attacked,
																	p_other_skept_args_attack_back,
																	p_cred_args_attacked,
																	p_cred_args_attack_back,
																	p_other_attacks
																);
															for(int v = 0; v < num; v++) {
																DungTheory af = gen.next();
																String filename =path+"kwt_"+
																		num_arguments + "_" + 
																		num_skept_arguments + "_" +
																		size_ideal_extension + "_" +
																		num_cred_arguments + "_" +
																		num_pref_exts + "_" +
																		p_ideal_attacked + "_" +
																		p_ideal_attack_back + "_" +
																		p_other_skept_args_attacked + "_" +
																		p_other_skept_args_attack_back + "_" +
																		p_cred_args_attacked + "_" +
																		p_cred_args_attack_back + "_" +
																		p_other_attacks + "__" +
																		(v+offset) + ".tgf";
																System.out.println(filename);
																writer.write(af, new File(filename));
																Collection<Argument> c = reasoner.getAcceptableArguments(af);
																File outputFile = new File(filename+".espr");
																String output = TgfWriter.writeArguments(c);
																FileWriter writer2 = new FileWriter(outputFile);
																writer2.write(output);
																writer2.close();
															}
														}
	}
}

org-tweetyproject-arg-delp/src/main/resources/nixon.txt

has_a_gun(X) -< lives_in_chicago(X).
~has_a_gun(X) -< lives_in_chicago(X), pacifist(X).
pacifist(X) -< quaker(X).
~pacifist(X) -< republican(X).

lives_in_chicago(nixon).
quaker(nixon).
republican(nixon).

org-tweetyproject-arg-delp/src/main/resources/counterarg.txt

h <- a.
~h <- c.

b.
d.

a -< b.
c -< d.

org-tweetyproject-arg-delp/src/main/resources/birds.txt

Bird(X) <- Chicken(X).
Bird(X) <- Penguin(X).
~Flies(X) <- Penguin(X).
Chicken(tina).
Penguin(tweety).
Scared(tina).

Flies(X) -< Bird(X).
~Flies(X) -< Chicken(X).
Flies(X) -< Chicken(X), Scared(X).
Nests_in_trees(X) -< Flies(X).

org-tweetyproject-arg-delp/src/main/java/org/tweetyproject/arg/delp/examples/DeLPExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.delp.examples;

import java.io.FileNotFoundException;
import java.io.IOException;

import org.tweetyproject.arg.delp.parser.DelpParser;
import org.tweetyproject.arg.delp.reasoner.DelpReasoner;
import org.tweetyproject.arg.delp.semantics.GeneralizedSpecificity;
import org.tweetyproject.arg.delp.syntax.DefeasibleLogicProgram;
import org.tweetyproject.commons.ParserException;
import org.tweetyproject.logics.fol.syntax.FolFormula;

/**
 * Shows how to parse and query a DeLP program.
 *
 * @author Matthias Thimm
 *
 */
public class DeLPExample {

    /**
     * The entry point of the application that parses a defeasible logic program from a file,
     * creates a reasoner with a specific criterion, and performs queries on the logic program.
     *
     * @param args Command-line arguments (not used in this example).
     * @throws FileNotFoundException If the specified file cannot be found.
     * @throws ParserException If there is an error while parsing the belief base or formula.
     * @throws IOException If an I/O error occurs while reading the file.
     */
    public static void main(String[] args) throws FileNotFoundException, ParserException, IOException {
        DelpParser parser = new DelpParser();

        // Parse the defeasible logic program from the specified file
        DefeasibleLogicProgram delp = parser.parseBeliefBaseFromFile(
            DeLPExample.class.getResource("/birds2.txt").getFile()
        );

        // Create a reasoner with a Generalized Specificity criterion
        DelpReasoner reasoner = new DelpReasoner(new GeneralizedSpecificity());

        // Parse and query a formula, then print the result
        FolFormula query = (FolFormula) parser.parseFormula("Fly(opus)");
        System.out.println(query + "\t" + reasoner.query(delp, query));

        // Parse and query another formula, then print the result
        query = (FolFormula) parser.parseFormula("Fly(tweety)");
        System.out.println(query + "\t" + reasoner.query(delp, query));
    }

    /** Default Constructor */
    public DeLPExample() {}
}

org-tweetyproject-arg-deductive/src/main/java/org/tweetyproject/arg/deductive/examples/SimplePlLogicExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2017 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.deductive.examples;

import java.io.IOException;
import java.io.StringReader;

import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.Attack;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.deductive.parser.SimplePlLogicParser;
import org.tweetyproject.arg.deductive.syntax.SimplePlLogicDeductiveKnowledgebase;
import org.tweetyproject.commons.ParserException;

/**
 * Example code for simple logic argumentation.
 *
 * @author Federico Cerutti (federico.cerutti@acm.org)
 *
 */
public class SimplePlLogicExample {
	/**
	 * Default Constructor
	 */
	public SimplePlLogicExample() {
		// Default
	}

	/**
	 * This class demonstrates the parsing of a simple propositional logic belief
	 * base,
	 * the generation of a deductive knowledge base, and the construction of an
	 * argumentation framework.
	 * The program parses a belief base in propositional logic, generates the
	 * corresponding
	 * argumentation framework (AF) with arguments and attacks, and prints the
	 * results.
	 *
	 * @param args Command-line arguments (not used in this example).
	 */
	public static void main(String[] args) {

		String skb = "a" + "\n" +
				"t" + "\n" +
				"a, t -> b" + "\n" +
				"b -> c" + "\n" +
				"-> d" + "\n" +
				"d -> !a" + "\n" +
				"d -> !c";

		SimplePlLogicParser p = new SimplePlLogicParser();

		SimplePlLogicDeductiveKnowledgebase k = null;
		try {
			k = p.parseBeliefBase(new StringReader(skb));
		} catch (ParserException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		System.out.println(k.getAF());

		DungTheory af = k.getAF();
		for (Argument arg : af.getNodes())
			System.out.println(arg);

		for (Attack att : af.getAttacks()) {
			System.out.println(att);
		}
		if (k.getAF().toString().equals(
				"<{ <[[a, t] -> b, [b] -> c, t, a],c>, <[[d] -> !a, d],!a>, <[[d] -> !c, d],!c>, <[[a, t] -> b, t, a],b> },[(<[[a, t] -> b, [b] -> c, t, a],c>,<[[d] -> !c, d],!c>), (<[[d] -> !a, d],!a>,<[[a, t] -> b, [b] -> c, t, a],c>), (<[[d] -> !c, d],!c>,<[[a, t] -> b, [b] -> c, t, a],c>), (<[[d] -> !a, d],!a>,<[[a, t] -> b, t, a],b>)]>")) {
			System.out.println("hurrah");

		}
	}

}

org-tweetyproject-arg-deductive/src/main/java/org/tweetyproject/arg/deductive/examples/DeductiveExample.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.deductive.examples;

import java.io.IOException;

import org.tweetyproject.arg.deductive.accumulator.SimpleAccumulator;
import org.tweetyproject.arg.deductive.categorizer.ClassicalCategorizer;
import org.tweetyproject.arg.deductive.reasoner.AbstractDeductiveArgumentationReasoner;
import org.tweetyproject.arg.deductive.reasoner.SimpleDeductiveReasoner;
import org.tweetyproject.arg.deductive.syntax.DeductiveKnowledgeBase;
import org.tweetyproject.commons.*;
import org.tweetyproject.logics.pl.parser.PlParser;
import org.tweetyproject.logics.pl.sat.Sat4jSolver;
import org.tweetyproject.logics.pl.sat.SatSolver;
import org.tweetyproject.logics.pl.syntax.PlFormula;

/**
 *
 * Shows how to construct and query a deductive knowledge base.
 *
 * @author Matthias Thimm
 *
 */
public class DeductiveExample {
	/**
	 * Default Constructor
	 */
	public DeductiveExample() {
		// default
	}

	/**
	 * This class demonstrates the use of a deductive knowledge base in combination
	 * with a SAT solver
	 * to perform reasoning using propositional logic formulas. The program adds
	 * several logical
	 * formulas to the knowledge base, uses a deductive reasoning engine, and
	 * queries the knowledge
	 * base for a specific formula's truth value.
	 *
	 * @param args Command-line arguments (not used in this example).
	 * @throws ParserException If there is an error in parsing the logical formulas.
	 * @throws IOException     If there is an I/O error while processing.
	 */
	public static void main(String[] args) throws ParserException, IOException {
		SatSolver.setDefaultSolver(new Sat4jSolver());
		DeductiveKnowledgeBase kb = new DeductiveKnowledgeBase();

		PlParser parser = new PlParser();
		kb.add((PlFormula) parser.parseFormula("s"));
		kb.add((PlFormula) parser.parseFormula("!s || h"));
		kb.add((PlFormula) parser.parseFormula("f"));
		kb.add((PlFormula) parser.parseFormula("!f || !h"));
		kb.add((PlFormula) parser.parseFormula("v"));
		kb.add((PlFormula) parser.parseFormula("!v || !h"));

		System.out.println(kb);

		AbstractDeductiveArgumentationReasoner reasoner = new SimpleDeductiveReasoner(new ClassicalCategorizer(),
				new SimpleAccumulator());

		System.out.println(reasoner.query(kb, (PlFormula) parser.parseFormula("h")));

	}

}

org-tweetyproject-arg-caf/src/main/java/org/tweetyproject/arg/caf/examples/CAFReasonerExample.java

/*
* This file is part of "TweetyProject", a collection of Java libraries for
* logical aspects of artificial intelligence and knowledge representation.
*
* TweetyProject is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License version 3 as
* published by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2024 The TweetyProject Team <http://tweetyproject.org/contact/>
*/
package org.tweetyproject.arg.caf.examples;

import java.util.Collection;

import org.tweetyproject.arg.caf.reasoner.AbstractCAFReasoner;
import org.tweetyproject.arg.caf.reasoner.SimpleCAFGroundedReasoner;
import org.tweetyproject.arg.caf.reasoner.SimpleCAFPreferredReasoner;
import org.tweetyproject.arg.caf.reasoner.SimpleCAFStableReasoner;
import org.tweetyproject.arg.caf.reasoner.SimpleCAFWeakGroundedReasoner;
import org.tweetyproject.arg.caf.semantics.CAFSemantics;
import org.tweetyproject.arg.caf.syntax.ConstrainedArgumentationFramework;
import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.commons.InferenceMode;

/**
 * Example Class on how to perform inference on constrained argumentation frameworks.
 * @author Sandra Hoffmann
 *
 */
public class CAFReasonerExample {

	/**
	 * Main method
	 * @param args unused
	 */
	public static void main(String[] args) {
		
		Argument a = new Argument("a");
		Argument b = new Argument("b");
		Argument c = new Argument("c");
		Argument d = new Argument("d");
		Argument e = new Argument("e");
		Argument f = new Argument("f");
		String propForm = "!a || !d || !e";

		DungTheory af = new DungTheory();
		
		af.add(a);
		af.add(b);
		af.add(c);
		af.add(d);
		af.add(e);
		af.add(f);
		
		af.addAttack(a,b);
		af.addAttack(a,c);
		af.addAttack(b,d);	
		af.addAttack(c,e);
		af.addAttack(e,f);
		af.addAttack(f,e);
	
		//Create CAF
		ConstrainedArgumentationFramework caf = new ConstrainedArgumentationFramework(af, propForm);		
		
		System.out.println("The CAF: \n"+ caf.prettyPrint() +"\n\nhas the following C-extensions:\n");
		
		System.out.println("C-Admissible Extensions:");
		
		//Reasoners can be created using the abstract superclass
		AbstractCAFReasoner cafReasoner = AbstractCAFReasoner.getSimpleReasonerForSemantics(CAFSemantics.CAF_ADM);
		Collection<Extension<ConstrainedArgumentationFramework>> cAdmSets = cafReasoner.getModels(caf);
		System.out.println(cAdmSets);
		System.out.println("Credulous justification status of each argument under admissibility:");
		for(Argument arg: caf) {
			System.out.println(arg +": " + cafReasoner.query(caf, arg, InferenceMode.CREDULOUS));
		}

		//Or by instantiating a reasoner for the required semantics
		SimpleCAFGroundedReasoner cafGr = new SimpleCAFGroundedReasoner();
		System.out.println("C-Grounded Extension:");
		System.out.println(cafGr.getModel(caf));
		
		SimpleCAFWeakGroundedReasoner cafWGr = new SimpleCAFWeakGroundedReasoner();
		System.out.println("Weak C-Extension:");
		System.out.println(cafWGr.getModel(caf));
		
		System.out.println("\nC-Preferred Extensions:");
		SimpleCAFPreferredReasoner cafPrefR = new SimpleCAFPreferredReasoner();
		System.out.println(cafPrefR.getModels(caf));
		System.out.println("Skeptical justification status of each argument under admissibility:");
		for(Argument arg: caf) {
			System.out.println(arg +": " + cafPrefR.query(caf, arg));
		}
		
		System.out.println("\nC-Stable Extensions:");
		SimpleCAFStableReasoner cafStR = new SimpleCAFStableReasoner();
		System.out.println(cafStR.getModels(caf));
	
	}

}

org-tweetyproject-agents-dialogues/src/main/java/org/tweetyproject/agents/dialogues/examples/LotteryDialogueTest2.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.agents.dialogues.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.tweetyproject.agents.dialogues.lotteries.AbstractLotteryAgent;
import org.tweetyproject.agents.dialogues.lotteries.LotteryGameSystem;
import org.tweetyproject.agents.dialogues.lotteries.ProbabilisticLotteryAgent;
import org.tweetyproject.agents.dialogues.lotteries.sim.DirectGameProtocol;
import org.tweetyproject.agents.dialogues.lotteries.sim.DirectGameProtocolGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.DummyAgentGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.LotteryGameGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.ProbabilisticLotteryAgentGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.RandomLotteryAgentGenerator;
import org.tweetyproject.agents.dialogues.lotteries.sim.UtilityBasedAgentGenerator;
import org.tweetyproject.agents.sim.AgentGenerator;
import org.tweetyproject.agents.sim.GameSimulator;
import org.tweetyproject.agents.sim.MultiAgentSystemGenerator;
import org.tweetyproject.agents.sim.ProtocolGenerator;
import org.tweetyproject.agents.sim.SimulationResult;
import org.tweetyproject.arg.dung.parser.ApxFilenameFilter;
import org.tweetyproject.arg.dung.parser.ApxParser;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;
import org.tweetyproject.arg.dung.util.FileDungTheoryGenerator;
import org.tweetyproject.commons.ParserException;

/**
 * Main class for empirical evaluation in [Hunter, Thimm. 2015, to appear]. Shows
 * how a simulation of a multi-agent system can be set up. It defines a dialogue
 * game between different agents, in particular one based on an action selection
 * strategy using lotteries.
 * 
 * @author Matthias Thimm
 */
public class LotteryDialogueTest2 {

	/** The argumentation semantics used */
	public static Semantics semantics = Semantics.GROUNDED_SEMANTICS;
	/** Timeout */
	public static int timeout = 60 * 60 * 72 * 3; // timeout of 72*3 hours
	/** Number of repetitions per file */
	public static int rep = 1;

	/**
	 * Main method for evaluation.
	 * 
	 * @param args additional arguments
	 * @throws ParserException       if parsing failed
	 * @throws FileNotFoundException if a file could not be found
	 * @throws IOException           if some general IO issue occurred
	 */
	public static void main(String[] args) throws ParserException, FileNotFoundException, IOException {
		String pathToApxGraphs = args[0];
		// String pathToApxGraphs = "/Users/mthimm/Desktop/tmp";

		// Agent generators
		List<AgentGenerator<AbstractLotteryAgent, LotteryGameSystem>> ag_gens = new ArrayList<AgentGenerator<AbstractLotteryAgent, LotteryGameSystem>>();
		ag_gens.add(new UtilityBasedAgentGenerator("UtilBased"));
		ag_gens.add(new RandomLotteryAgentGenerator("Random"));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotteryNaive"));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotterySimple", ProbabilisticLotteryAgent.UPDATE_SIMPLE));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotterySticky01", ProbabilisticLotteryAgent.UPDATE_STICKY,
				0.1));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotterySticky03", ProbabilisticLotteryAgent.UPDATE_STICKY,
				0.3));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotterySticky05", ProbabilisticLotteryAgent.UPDATE_STICKY,
				0.5));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotterySticky07", ProbabilisticLotteryAgent.UPDATE_STICKY,
				0.7));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotterySticky09", ProbabilisticLotteryAgent.UPDATE_STICKY,
				0.9));
		ag_gens.add(new ProbabilisticLotteryAgentGenerator("LotteryRough", ProbabilisticLotteryAgent.UPDATE_ROUGH));

		// for every different move selection strategy
		for (AgentGenerator<AbstractLotteryAgent, LotteryGameSystem> ag_gen : ag_gens) {
			// AAF generator
			File[] apxFiles = new File(pathToApxGraphs).listFiles(new ApxFilenameFilter());
			int numRuns = apxFiles.length * rep;
			DungTheoryGenerator aaf_gen = new FileDungTheoryGenerator(apxFiles, new ApxParser(), true);

			// MAS generator
			MultiAgentSystemGenerator<AbstractLotteryAgent, LotteryGameSystem> masGenerator = new LotteryGameGenerator(
					aaf_gen, semantics, false);
			List<AgentGenerator<AbstractLotteryAgent, LotteryGameSystem>> agentGenerators = new ArrayList<AgentGenerator<AbstractLotteryAgent, LotteryGameSystem>>();

			agentGenerators.add(ag_gen);
			agentGenerators.add(new DummyAgentGenerator("Audience"));

			ProtocolGenerator<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem> protGenerator = new DirectGameProtocolGenerator();
			final GameSimulator<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem> sim = new GameSimulator<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem>(
					masGenerator, protGenerator, agentGenerators);
			// Run iterated simulations and show aggregated results (with timeout)
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationResult<DirectGameProtocol, AbstractLotteryAgent, LotteryGameSystem> result = sim
							.run(numRuns);
					System.out.println(result.csvDisplay());
					return null;
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
				e.printStackTrace();
			}
			executor.shutdownNow();
		}

	}

    /** Default Constructor */
    public LotteryDialogueTest2(){}
}

org-tweetyproject-agents-dialogues/src/main/java/org/tweetyproject/agents/dialogues/examples/GroundedTest2.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.agents.dialogues.examples;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.tweetyproject.agents.Agent;
import org.tweetyproject.agents.ProtocolTerminatedException;
import org.tweetyproject.agents.dialogues.oppmodels.ArguingAgent;
import org.tweetyproject.agents.dialogues.oppmodels.BeliefState;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameProtocol;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameSystem;
import org.tweetyproject.agents.dialogues.oppmodels.T3BeliefState;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameProtocolGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT1AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT3AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T1Configuration;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T3Configuration;
import org.tweetyproject.agents.sim.MultiAgentSystemGenerator;
import org.tweetyproject.agents.sim.ProtocolGenerator;
import org.tweetyproject.agents.sim.SimulationParameters;
import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;

/**
 *
 * Shows how a simulation of a multi-agent system can be set up. It defines a
 * dialogue game between different agents with varying complexity of their
 * opponent models.
 *
 * @author Matthias Thimm
 *
 */
public class GroundedTest2 {

    /**
     * Timeout duration for each simulation run in seconds.
     * Default is set to 10 minutes (600 seconds).
     */
    public static int timeout = 60 * 10; // 10 minutes

    /**
     * Number of simulation runs to be executed for each experiment.
     * Default is set to 5000 runs.
     */
    public static int numberOfRunsEach = 5000;

    /**
     * The main method of the simulation. This sets up and runs the
     * multi-agent dialogue game simulation.
     *
     * @param args Command line arguments (not used in this simulation).
     * @throws ProtocolTerminatedException if the protocol terminates unexpectedly.
     */
	public static void main(String[] args) throws ProtocolTerminatedException {


		GroundedTest.attackProbability = 0.4;
		GroundedTest.frameworkSize = 10;
		GroundedTest.enforceTreeShape = false;

		DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
		params.attackProbability = GroundedTest.attackProbability;
		params.numberOfArguments = GroundedTest.frameworkSize;
		params.enforceTreeShape = GroundedTest.enforceTreeShape;
		DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
		// gen.setSeed(GroundedTest.RANDOM_SEED1);
		// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
		final MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
				0.5, 0.9);
		// masGenerator.setSeed(GroundedTest.RANDOM_SEED2);

		// The PRO agent has a T1 belief state without opponent model
		T1Configuration configPro = new T1Configuration();
		configPro.maxRecursionDepth = 0;
		configPro.probRecursionDecay = 0;
		configPro.oppModelCorrect = true;
		// The CONTRA agent
		T3Configuration configCon = new T3Configuration();
		configCon.maxRecursionDepth = 2;
		configCon.probRecursionDecay = 0.6;
		configCon.maxRecursionWidth = 3;
		configCon.percentageVirtualArguments = 0.3;
		configCon.percentageVirtualAttacks = 0.8;

		final GroundedGameT1AgentGenerator proGenerator = new GroundedGameT1AgentGenerator(
				GroundedGameSystem.AgentFaction.PRO, configPro);
		final GroundedGameT3AgentGenerator conGenerator = new GroundedGameT3AgentGenerator(
				GroundedGameSystem.AgentFaction.CONTRA, configCon);
		// proGenerator.setSeed(GroundedTest.RANDOM_SEED3);
		// conGenerator.setSeed(GroundedTest.RANDOM_SEED4);

		final ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();

		// 0 holds score for pro in pro vs. T3
		// 1 holds score for T3 in pro vs. T3
		// 2 holds score for pro in pro vs. T2
		// 3 holds score for T2 in pro vs. T2
		// 4 holds score for pro in pro vs. T1
		// 5 holds score for T1 in pro vs. T1
		final int[] results = { 0, 0, 0, 0, 0, 0 };

		for (int i = 0; i < GroundedTest2.numberOfRunsEach; i++) {
			final int k = i;
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationParameters sParams = new SimulationParameters();
					GroundedGameSystem mas = masGenerator.generate(sParams);
					// create agents for T3 test
					ArguingAgent proAgent = proGenerator.generate(mas, sParams);
					ArguingAgent conAgentT3 = conGenerator.generate(mas, sParams);
					// make backups
					ArguingAgent proBackup = new ArguingAgent(proAgent.getFaction(),
							(BeliefState) proAgent.getBeliefState().clone());
					ArguingAgent conBackup = new ArguingAgent(conAgentT3.getFaction(),
							(BeliefState) conAgentT3.getBeliefState().clone());
					mas.add(proAgent);
					mas.add(conAgentT3);
					GroundedGameProtocol prot = protGenerator.generate(mas, sParams);
					mas.execute(prot);
					if (prot.hasWinner()) {
						Agent winner = prot.getWinner();
						if (winner == proAgent)
							results[0]++;
						else
							results[1]++;
					}
					mas.remove(proAgent);
					mas.remove(conAgentT3);
					// create agents for T2 test
					mas.getEnvironment().reset();
					proAgent = new ArguingAgent(proBackup.getFaction(),
							(BeliefState) proBackup.getBeliefState().clone());
					ArguingAgent conAgentT2 = new ArguingAgent(conBackup.getFaction(),
							((T3BeliefState) conBackup.getBeliefState()).projectToT2BeliefState());
					mas.add(proAgent);
					mas.add(conAgentT2);
					prot = protGenerator.generate(mas, sParams);
					mas.execute(prot);
					if (prot.hasWinner()) {
						Agent winner = prot.getWinner();
						if (winner == proAgent)
							results[2]++;
						else
							results[3]++;
					}
					mas.remove(proAgent);
					mas.remove(conAgentT2);
					// create agents for T1 test
					mas.getEnvironment().reset();
					proAgent = new ArguingAgent(proBackup.getFaction(),
							(BeliefState) proBackup.getBeliefState().clone());
					ArguingAgent conAgentT1 = new ArguingAgent(conBackup.getFaction(),
							((T3BeliefState) conBackup.getBeliefState()).projectToT2BeliefState()
									.sampleT1BeliefState());
					mas.add(proAgent);
					mas.add(conAgentT1);
					prot = protGenerator.generate(mas, sParams);
					mas.execute(prot);
					if (prot.hasWinner()) {
						Agent winner = prot.getWinner();
						if (winner == proAgent)
							results[4]++;
						else
							results[5]++;
					}
					System.out.println(k + ":\t" + results[0] + "\t" + results[1] + "\t" + results[2] + "\t"
							+ results[3] + "\t" + results[4] + "\t" + results[5]);
					return "";
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest2.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
		}

	}

    /** Default Constructor */
    public GroundedTest2(){}
}

org-tweetyproject-agents-dialogues/src/main/java/org/tweetyproject/agents/dialogues/examples/GroundedTest.java

/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.agents.dialogues.examples;

import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.tweetyproject.agents.ProtocolTerminatedException;
import org.tweetyproject.agents.dialogues.oppmodels.ArguingAgent;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameProtocol;
import org.tweetyproject.agents.dialogues.oppmodels.GroundedGameSystem;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameProtocolGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT1AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT2AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.GroundedGameT3AgentGenerator;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T1Configuration;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T2Configuration;
import org.tweetyproject.agents.dialogues.oppmodels.sim.T3Configuration;
import org.tweetyproject.agents.sim.AgentGenerator;
import org.tweetyproject.agents.sim.GameSimulator;
import org.tweetyproject.agents.sim.MultiAgentSystemGenerator;
import org.tweetyproject.agents.sim.ProtocolGenerator;
import org.tweetyproject.agents.sim.SimulationResult;
import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;

/**
 *
 * Shows how a simulation of a multi-agent system can be set up. It defines a
 * dialogue game between different agents with varying complexity of their
 * opponent models.
 *
 * @author Matthias Thimm
 *
 */
public class GroundedTest {

    /** The size of the argumentation framework in the simulation. */
    public static int frameworkSize;

    /** The probability of an attack between arguments in the framework (0.0 to 1.0). */
    public static double attackProbability;

    /**
     * Flag indicating whether the framework should enforce a tree-like structure.
     * If true, the argumentation framework will be forced to have a tree shape.
     */
    public static boolean enforceTreeShape;

    /** The timeout for the simulation in seconds (default: six hours). */
    public static int timeout = 60 * 60 * 6;

    /** The number of simulation runs to be executed for each experiment. */
    public static int numberOfRunsEach = 100;

    /** Random seed for ensuring reproducibility in the first configuration. */
    public static long RANDOM_SEED1 = 43589744589L;

    /** Random seed for ensuring reproducibility in the second configuration. */
    public static long RANDOM_SEED2 = 96498321389L;

    /** Random seed for ensuring reproducibility in the third configuration. */
    public static long RANDOM_SEED3 = 647597568L;

    /** Random seed for ensuring reproducibility in the fourth configuration. */
    public static long RANDOM_SEED4 = 213596455579L;

	/**
	 * This method shows that with increasing complexity of the T1-belief state of
	 * the CONTRA agent (and constant model of the PRO agent), the average utility
	 * of the CONTRA agent increases. NOTE: the simulation might take a while.
	 *
	 * @throws ProtocolTerminatedException if the protocol already terminated
	 */
	public static void runSimulationT1() throws ProtocolTerminatedException {
		// We run different simulations with increasing recursion depth
		// of the CON agent's belief state
		for (int i = 1; i < 4; i++) {
			// We generate Dung theories with the given number of arguments and attack
			// probability.
			// In every theory, the argument under consideration is guaranteed to
			// be in the grounded extension (so under perfect information, the PRO
			// agent should always win)
			DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
			params.attackProbability = GroundedTest.attackProbability;
			params.numberOfArguments = GroundedTest.frameworkSize;
			params.enforceTreeShape = GroundedTest.enforceTreeShape;
			DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
			gen.setSeed(GroundedTest.RANDOM_SEED1);
			// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
			MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
					0.5, 0.9);
			masGenerator.setSeed(GroundedTest.RANDOM_SEED2);
			List<AgentGenerator<ArguingAgent, GroundedGameSystem>> agentGenerators = new ArrayList<AgentGenerator<ArguingAgent, GroundedGameSystem>>();

			// The PRO agent has a T1 belief state without opponent model
			T1Configuration configPro = new T1Configuration();
			configPro.maxRecursionDepth = 0;
			configPro.probRecursionDecay = 0;
			configPro.oppModelCorrect = true;
			// The CONTRA agent has a T1 belief state of depth i,
			// every sub-model correctly and completely models the PRO agent
			T1Configuration configCon = new T1Configuration();
			configCon.maxRecursionDepth = i;
			configCon.probRecursionDecay = 0;
			configCon.oppModelCorrect = true;

			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.PRO, configPro));
			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.CONTRA, configCon));
			agentGenerators.get(0).setSeed(GroundedTest.RANDOM_SEED3);
			agentGenerators.get(1).setSeed(GroundedTest.RANDOM_SEED4);

			ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();
			final GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> sim = new GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem>(
					masGenerator, protGenerator, agentGenerators);
			final int j = i;
			// Run iterated simulations and show aggregated results (with timeout)
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationResult<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> result = sim
							.run(GroundedTest.numberOfRunsEach);
					System.out.print("T1;T1;" + GroundedTest.frameworkSize + ";" + GroundedTest.attackProbability + ";"
							+ (GroundedTest.enforceTreeShape ? ("tree") : ("no-tree")));
					System.out.print(";T1-" + j + ";");
					System.out.println(result.csvDisplay());
					return null;
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
		}
	}
//T1;T1;10;0.3;tree;T1-3;PRO;58;CONTRA;42;PRO;(0.14080000000000006, 0.9995124848484855);CONTRA;(-0.17920000000000003, 0.9693225858585856);
	/**
	 * Same as runSimulationT1()
	 *
	 * @throws ProtocolTerminatedException if the protocol already terminated
	 */
	public static void runSimulationT2() throws ProtocolTerminatedException {
		// We run different simulations with increasing complexity
		// of the CON agent's belief state
		int depth[] = { 2, 3, 4 }; // depth complexity
		double decay[] = { 0.4, 0.3, 0.2 }; // decay complexity
		int width[] = { 4, 3, 2 }; // width complexity
		int idx[] = new int[3];
		idx[0] = 0;
		idx[1] = 0;
		idx[2] = 0;
		for (int i = 0; i < 27; i++) {
			DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
			params.attackProbability = GroundedTest.attackProbability;
			params.numberOfArguments = GroundedTest.frameworkSize;
			params.enforceTreeShape = GroundedTest.enforceTreeShape;
			DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
			gen.setSeed(GroundedTest.RANDOM_SEED1);
			// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
			MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
					0.5, 0.9);
			masGenerator.setSeed(GroundedTest.RANDOM_SEED2);
			List<AgentGenerator<ArguingAgent, GroundedGameSystem>> agentGenerators = new ArrayList<AgentGenerator<ArguingAgent, GroundedGameSystem>>();

			// The PRO agent has a T1 belief state without opponent model
			T1Configuration configPro = new T1Configuration();
			configPro.maxRecursionDepth = 0;
			configPro.probRecursionDecay = 0;
			configPro.oppModelCorrect = true;
			// The CONTRA agent has a T2 belief state of complexity i
			T2Configuration configCon = new T2Configuration();
			configCon.maxRecursionDepth = depth[idx[0]];
			configCon.probRecursionDecay = decay[idx[1]];
			configCon.maxRecursionWidth = width[idx[2]];

			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.PRO, configPro));
			agentGenerators.add(new GroundedGameT2AgentGenerator(GroundedGameSystem.AgentFaction.CONTRA, configCon));
			agentGenerators.get(0).setSeed(GroundedTest.RANDOM_SEED3);
			agentGenerators.get(1).setSeed(GroundedTest.RANDOM_SEED4);

			ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();
			final GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> sim = new GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem>(
					masGenerator, protGenerator, agentGenerators);
			final int d1 = depth[idx[0]];
			final double d2 = decay[idx[1]];
			final int d3 = width[idx[2]];
			// Run iterated simulations and show aggregated results (with timeout)
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationResult<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> result = sim
							.run(GroundedTest.numberOfRunsEach);
					System.out.print("T1;T2;" + GroundedTest.frameworkSize + ";" + GroundedTest.attackProbability + ";"
							+ (GroundedTest.enforceTreeShape ? ("tree") : ("no-tree")));
					System.out.print(";T2-(" + d1 + "," + d2 + "," + d3 + ");");
					System.out.println(result.csvDisplay());
					return null;
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
			idx[2]++;
			if (idx[2] > 2) {
				idx[2] = 0;
				idx[1]++;
				if (idx[1] > 2) {
					idx[1] = 0;
					idx[0]++;
					if (idx[0] > 2)
						idx[0] = 0;
				}
			}
		}
	}

	/**
	 * Same as runSimulationT1()
	 *
	 * @throws ProtocolTerminatedException if the protocol already terminated
	 */
	public static void runSimulationT3() throws ProtocolTerminatedException {
		// We run different simulations with increasing complexity
		// of the CON agent's belief state
		int depth[] = { 2, 3, 4 }; // depth complexity
		double decay[] = { 0.4, 0.3, 0.2 }; // decay complexity
		int width[] = { 4, 3, 2 }; // width complexity
		double virtArg[] = { 0.3, 0.2, 0.1 }; // virtual arguments
		double virtAtt[] = { 0.7, 0.8, 0.9 }; // virtual attacks
		int idx[] = new int[5];
		idx[0] = 0;
		idx[1] = 0;
		idx[2] = 0;
		idx[3] = 0;
		idx[4] = 0;

		for (int i = 0; i < 243; i++) {
			DungTheoryGenerationParameters params = new DungTheoryGenerationParameters();
			params.attackProbability = GroundedTest.attackProbability;
			params.numberOfArguments = GroundedTest.frameworkSize;
			params.enforceTreeShape = GroundedTest.enforceTreeShape;
			DungTheoryGenerator gen = new DefaultDungTheoryGenerator(params);
			gen.setSeed(GroundedTest.RANDOM_SEED1);
			// PRO agent knows 50% of all arguments, CONTRA agent knows 90% of all arguments
			MultiAgentSystemGenerator<ArguingAgent, GroundedGameSystem> masGenerator = new GroundedGameGenerator(gen,
					0.5, 0.9);
			masGenerator.setSeed(GroundedTest.RANDOM_SEED2);
			List<AgentGenerator<ArguingAgent, GroundedGameSystem>> agentGenerators = new ArrayList<AgentGenerator<ArguingAgent, GroundedGameSystem>>();

			// The PRO agent has a T1 belief state without opponent model
			T1Configuration configPro = new T1Configuration();
			configPro.maxRecursionDepth = 0;
			configPro.probRecursionDecay = 0;
			configPro.oppModelCorrect = true;
			// The CONTRA agent has a T3 belief state
			T3Configuration configCon = new T3Configuration();
			configCon.maxRecursionDepth = depth[idx[0]];
			configCon.probRecursionDecay = decay[idx[1]];
			configCon.maxRecursionWidth = width[idx[2]];
			configCon.percentageVirtualArguments = virtArg[idx[3]];
			configCon.percentageVirtualAttacks = virtAtt[idx[4]];

			agentGenerators.add(new GroundedGameT1AgentGenerator(GroundedGameSystem.AgentFaction.PRO, configPro));
			agentGenerators.add(new GroundedGameT3AgentGenerator(GroundedGameSystem.AgentFaction.CONTRA, configCon));
			agentGenerators.get(0).setSeed(GroundedTest.RANDOM_SEED3);
			agentGenerators.get(1).setSeed(GroundedTest.RANDOM_SEED4);

			ProtocolGenerator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> protGenerator = new GroundedGameProtocolGenerator();
			final GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> sim = new GameSimulator<GroundedGameProtocol, ArguingAgent, GroundedGameSystem>(
					masGenerator, protGenerator, agentGenerators);
			final int d1 = depth[idx[0]];
			final double d2 = decay[idx[1]];
			final int d3 = width[idx[2]];
			final double d4 = virtArg[idx[3]];
			final double d5 = virtAtt[idx[4]];
			// Run iterated simulations and show aggregated results (with timeout)
			Callable<String> callee = new Callable<String>() {
				@Override
				public String call() throws Exception {
					SimulationResult<GroundedGameProtocol, ArguingAgent, GroundedGameSystem> result = sim
							.run(GroundedTest.numberOfRunsEach);
					System.out.print("T1;T3;" + GroundedTest.frameworkSize + ";" + GroundedTest.attackProbability + ";"
							+ (GroundedTest.enforceTreeShape ? ("tree") : ("no-tree")));
					System.out.print(";T3-(" + d1 + "," + d2 + "," + d3 + "," + d4 + "," + d5 + ");");
					System.out.println(result.csvDisplay());
					return null;
				}
			};
			ExecutorService executor = Executors.newSingleThreadExecutor();
			Future<String> future = executor.submit(callee);
			try {
				future.get(GroundedTest.timeout, TimeUnit.SECONDS);
			} catch (Exception e) {
				System.out.println("Aborted...");
			}
			executor.shutdownNow();
			idx[4]++;
			if (idx[4] > 2) {
				idx[4] = 0;
				idx[3]++;
				if (idx[3] > 2) {
					idx[3] = 0;
					idx[2]++;
					if (idx[2] > 2) {
						idx[2] = 0;
						idx[1]++;
						if (idx[1] > 2) {
							idx[1] = 0;
							idx[0]++;
							if (idx[0] > 2)
								idx[0] = 0;
						}
					}
				}
			}
		}
	}

	/**
	 * Grounded test method
	 * @param args the args
	 * @throws ProtocolTerminatedException error
	 */
	public static void main(String[] args) throws ProtocolTerminatedException {
		// set logging level to "TRACE" to get detailed descriptions

		GroundedTest.attackProbability = 0.3;
		GroundedTest.frameworkSize = 10;

		GroundedTest.enforceTreeShape = true;
		GroundedTest.runSimulationT1();
		// GroundedTest.enforceTreeShape = false;
		// GroundedTest.runSimulationT1();

		// GroundedTest.runSimulationT2();
		// GroundedTest.runSimulationT3();
		// GroundedTest.enforceTreeShape = false;
		// GroundedTest.runSimulationT1();
		// GroundedTest.runSimulationT2();
		// GroundedTest.runSimulationT3();
	}

    /** Default Constructor */
    public GroundedTest(){}
}