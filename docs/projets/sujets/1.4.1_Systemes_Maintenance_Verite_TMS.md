# 1.4.1 Systèmes de Maintenance de la Vérité (TMS)

**Étudiants :** julien.zebic, thomas.leguere  
**Niveau :** Avancé  
**Prérequis :** Logique propositionnelle, Théorie de l'argumentation, Programmation Java, Révision de croyances  

## Table des Matières

0. [Objectifs du Projet](#0-objectifs-du-projet)
1. [Fondements Théoriques](#1-fondements-théoriques)
2. [Architectures TMS Classiques](#2-architectures-tms-classiques)
3. [Algorithmes et Structures de Données](#3-algorithmes-et-structures-de-données)
4. [Intégration TweetyProject](#4-intégration-tweetyproject)
5. [Implémentation Pratique](#5-implémentation-pratique)
6. [Applications Avancées](#6-applications-avancées)
7. [Défis et Limitations](#7-défis-et-limitations)
8. [Ressources et Références](#8-ressources-et-références)

---

## 0. Objectifs du Projet

L'objectif principal de ce projet est le **développement de deux agents spécialistes distincts : un agent JTMS (Justification-based Truth Maintenance System) et un agent ATMS (Assumption-based Truth Maintenance System)**.

Ces agents devront être implémentés en Python, en utilisant la bibliothèque `jpype` pour s'interfacer avec les fonctionnalités de **"belief dynamics" (révision de croyances) de TweetyProject**. TweetyProject servira de fournisseur pour les logiques de TMS sous-jacentes.

Chaque agent devra exposer clairement les capacités du TMS correspondant. Cela inclut, sans s'y limiter :
- L'ajout et le retrait de croyances (ou faits).
- L'ajout et le retrait de justifications (pour JTMS) ou d'hypothèses et de justifications (pour ATMS).
- La vérification de la cohérence de l'ensemble des croyances.
- La capacité à expliquer l'état actuel des croyances (par exemple, pourquoi une croyance est "IN" ou "OUT").

Une attention particulière sera portée à la **documentation détaillée** du code, à la création d'une API claire pour chaque agent, et potentiellement à la fourniture d'exemples d'utilisation.

---

## 1. Fondements Théoriques

### 1.1 Histoire et Origine des TMS

Les **Systèmes de Maintenance de la Vérité** (Truth Maintenance Systems) ont été introduits par Jon Doyle en 1979 pour résoudre le problème fondamental de la maintenance de cohérence dans les systèmes de raisonnement automatique.

**Définition formelle :**
Un TMS est un tuple `TMS = ⟨N, J, L, U⟩` où :
- `N` : ensemble des nœuds (propositions)
- `J` : ensemble des justifications (règles d'inférence)
- `L` : fonction de labellisation (IN/OUT/UNKNOWN)
- `U` : procédure de mise à jour de cohérence

#### 1.1.1 Problème Motivant

```
Exemple classique :
- Fait initial : "Tweety est un oiseau"
- Règle par défaut : "Les oiseaux volent"
- Conclusion : "Tweety vole"
- Nouvelle information : "Tweety est un pingouin"
- Règle spécifique : "Les pingouins ne volent pas"
→ Comment maintenir la cohérence automatiquement ?
```

#### 1.1.2 Contributions Historiques

**Jon Doyle (1979) - JTMS Original**
- Premier système de maintenance de justifications
- Propagation de labels IN/OUT
- Gestion des dépendances causales

**Johan de Kleer (1986) - ATMS**
- Assumption-based Truth Maintenance System
- Gestion explicite des hypothèses
- Environnements multiples simultanés

**Drew McDermott & Jon Doyle (1980) - Logiques Non-Monotones**
- Formalisation théorique du raisonnement défaisable
- Connexion avec les logiques modales

### 1.2 Problème de la Maintenance de Cohérence

#### 1.2.1 Raisonnement Non-Monotone

Le raisonnement non-monotone permet de tirer des conclusions qui peuvent être révisées :

```
Règle de défaut : Bird(x) ∧ ¬Ab(x) → Flies(x)
Où Ab(x) signifie "x est anormal"

Raisonnement :
1. Bird(Tweety) [donné]
2. ¬Ab(Tweety) [assumé par défaut]
3. Flies(Tweety) [par modus ponens]

Nouvelle information :
4. Penguin(Tweety) [observé]
5. Penguin(x) → Ab(x) [règle]
6. Ab(Tweety) [par 4,5]
→ Contradiction avec 2, révision nécessaire
```

#### 1.2.2 Types de Révision

**Révision par Contraction (AGM)**
- Retrait minimal d'informations
- Préservation maximale de cohérence
- Postulats de rationalité

**Révision par Expansion**
- Ajout de nouvelles informations
- Résolution des conflits
- Maintien de la fermeture logique

### 1.3 Révision de Croyances et Contraction

#### 1.3.1 Postulats AGM (Alchourrón, Gärdenfors, Makinson)

Pour une base de croyances `K` et une formule `φ` :

**Postulats de Contraction :**
1. `K ÷ φ` est un ensemble de formules
2. `K ÷ φ ⊆ K` (inclusion)
3. Si `φ ∉ Cn(K)`, alors `K ÷ φ = K` (vacuité)
4. Si `⊬ φ`, alors `φ ∉ Cn(K ÷ φ)` (succès)
5. Si `φ ∈ Cn(K)`, alors `K ⊆ Cn((K ÷ φ) ∪ {φ})` (récupération)
6. `K ÷ φ = K ÷ ψ` si `Cn(φ) = Cn(ψ)` (extensionalité)

**Postulats de Révision :**
1. `K * φ` est un ensemble de formules
2. `φ ∈ K * φ` (succès)
3. `K * φ ⊆ Cn(K ∪ {φ})` (inclusion)
4. Si `¬φ ∉ K`, alors `Cn(K ∪ {φ}) ⊆ K * φ` (préservation)
5. `K * φ` est inconsistant ssi `⊢ ¬φ` (consistance)
6. `K * φ = K * ψ` si `⊢ φ ↔ ψ` (extensionalité)

#### 1.3.2 Construction de Levi

La révision peut être définie en termes de contraction :
```
K * φ = (K ÷ ¬φ) ∪ {φ}
```

### 1.4 Logiques Non-Monotones et Défaisabilité

#### 1.4.1 Logique de Défaut (Reiter)

**Règle de défaut :**
```
α : β₁, ..., βₙ / γ
```
Signification : "Si α est prouvable et β₁, ..., βₙ sont consistants, alors conclure γ"

**Extension de défaut :**
Un ensemble maximal et cohérent de conclusions obtenues par application des règles.

#### 1.4.2 Circonscription (McCarthy)

Minimisation des prédicats anormaux :
```
CIRC[T; Ab] = T ∧ ∀P(P ⊆ Ab → T[P/Ab] → P = Ab)
```

---

## 2. Architectures TMS Classiques

### 2.1 Justification-based TMS (JTMS)

#### 2.1.1 Structure de Base

```java
public class JTMSNode {
    private String label;           // Nom du nœud
    private NodeStatus status;      // IN, OUT, UNKNOWN
    private Set<Justification> inJustifications;   // Justifications supportant IN
    private Set<Justification> outJustifications;  // Justifications supportant OUT
    private Set<JTMSNode> consequences;            // Nœuds dépendants
    
    public enum NodeStatus {
        IN,      // Cru vrai
        OUT,     // Cru faux
        UNKNOWN  // Statut indéterminé
    }
}

public class Justification {
    private Set<JTMSNode> inList;   // Nœuds devant être IN
    private Set<JTMSNode> outList;  // Nœuds devant être OUT
    private JTMSNode consequent;    // Nœud conclu
    private String rule;            // Règle d'inférence
}
```

#### 2.1.2 Algorithme de Propagation

```java
public class JTMSEngine {
    private Set<JTMSNode> nodes;
    private Queue<JTMSNode> propagationQueue;
    
    public void propagateLabels() {
        while (!propagationQueue.isEmpty()) {
            JTMSNode node = propagationQueue.poll();
            NodeStatus oldStatus = node.getStatus();
            NodeStatus newStatus = computeStatus(node);
            
            if (oldStatus != newStatus) {
                node.setStatus(newStatus);
                // Ajouter les conséquences à la queue
                for (JTMSNode consequence : node.getConsequences()) {
                    propagationQueue.offer(consequence);
                }
            }
        }
    }
    
    private NodeStatus computeStatus(JTMSNode node) {
        // Vérifier les justifications IN
        for (Justification just : node.getInJustifications()) {
            if (isValidJustification(just)) {
                return NodeStatus.IN;
            }
        }
        
        // Vérifier les justifications OUT
        for (Justification just : node.getOutJustifications()) {
            if (isValidJustification(just)) {
                return NodeStatus.OUT;
            }
        }
        
        return NodeStatus.UNKNOWN;
    }
    
    private boolean isValidJustification(Justification just) {
        // Tous les nœuds inList doivent être IN
        for (JTMSNode node : just.getInList()) {
            if (node.getStatus() != NodeStatus.IN) {
                return false;
            }
        }
        
        // Tous les nœuds outList doivent être OUT
        for (JTMSNode node : just.getOutList()) {
            if (node.getStatus() != NodeStatus.OUT) {
                return false;
            }
        }
        
        return true;
    }
}
### 2.2 Assumption-based TMS (ATMS)

#### 2.2.1 Concepts Fondamentaux

```java
public class ATMSNode {
    private String datum;                    // Contenu du nœud
    private Set<Environment> environments;   // Environnements supportant le nœud
    private Set<Assumption> assumptions;     // Hypothèses de base
}

public class Environment {
    private Set<Assumption> assumptions;     // Ensemble d'hypothèses
    private boolean isConsistent;           // Cohérence de l'environnement
    
    public boolean isMinimal() {
        // Un environnement est minimal si aucun sous-ensemble propre
        // ne supporte les mêmes conclusions
        return true; // Implémentation simplifiée
    }
}

public class Assumption {
    private String name;
    private boolean isContradicted;
    
    // Les hypothèses sont les seules sources de croyance
    // Tout le reste est dérivé par inférence
}
```

#### 2.2.2 Algorithme ATMS

```java
public class ATMSEngine {
    private Set<ATMSNode> nodes;
    private Set<Environment> environments;
    private Set<Assumption> assumptions;
    
    public void processNewJustification(Justification just) {
        ATMSNode consequent = just.getConsequent();
        
        // Calculer les nouveaux environnements pour le conséquent
        Set<Environment> newEnvs = computeEnvironments(just);
        
        // Filtrer pour ne garder que les environnements minimaux et cohérents
        newEnvs = filterMinimalConsistent(newEnvs);
        
        // Mettre à jour le nœud conséquent
        consequent.getEnvironments().addAll(newEnvs);
        
        // Propager aux nœuds dépendants
        propagateToConsequences(consequent);
    }
    
    private Set<Environment> computeEnvironments(Justification just) {
        Set<Environment> result = new HashSet<>();
        
        // Produit cartésien des environnements des antécédents
        List<Set<Environment>> antecedentEnvs = new ArrayList<>();
        for (ATMSNode antecedent : just.getAntecedents()) {
            antecedentEnvs.add(antecedent.getEnvironments());
        }
        
        // Calculer le produit cartésien
        Set<List<Environment>> cartesianProduct = cartesianProduct(antecedentEnvs);
        
        for (List<Environment> envCombination : cartesianProduct) {
            Environment unionEnv = unionEnvironments(envCombination);
            if (unionEnv.isConsistent()) {
                result.add(unionEnv);
            }
        }
        
        return result;
    }
}
```

### 2.3 Logic-based TMS (LTMS)

#### 2.3.1 Intégration avec Solveurs SAT

```java
public class LTMSEngine {
    private SATSolver satSolver;
    private Map<String, Integer> variableMapping;
    private Set<Clause> clauses;
    
    public void addClause(String... literals) {
        Clause clause = new Clause();
        for (String literal : literals) {
            int var = getOrCreateVariable(literal);
            clause.addLiteral(var);
        }
        clauses.add(clause);
        satSolver.addClause(clause);
    }
    
    public boolean isConsistent() {
        return satSolver.isSatisfiable();
    }
    
    public Set<String> getModel() {
        if (!isConsistent()) {
            return null;
        }
        
        int[] model = satSolver.getModel();
        Set<String> result = new HashSet<>();
        
        for (Map.Entry<String, Integer> entry : variableMapping.entrySet()) {
            int var = entry.getValue();
            if (model[var] > 0) {
                result.add(entry.getKey());
            } else {
                result.add("¬" + entry.getKey());
            }
        }
        
        return result;
    }
}
```

### 2.4 Comparaison des Approches

| Aspect | JTMS | ATMS | LTMS |
|--------|------|------|------|
| **Représentation** | Graphe de dépendances | Environnements multiples | Clauses logiques |
| **Cohérence** | Une seule interprétation | Multiples contextes | Satisfiabilité SAT |
| **Complexité** | O(n²) propagation | Exponentielle (environnements) | NP-complet (SAT) |
| **Expressivité** | Règles Horn étendues | Hypothèses explicites | Logique propositionnelle complète |
| **Applications** | Systèmes experts | Diagnostic | Planification, vérification |

---

## 3. Algorithmes et Structures de Données

### 3.1 Graphes de Dépendances

#### 3.1.1 Représentation

```java
public class DependencyGraph {
    private Map<String, Node> nodes;
    private Map<String, Set<Edge>> incomingEdges;
    private Map<String, Set<Edge>> outgoingEdges;
    
    public static class Node {
        private String id;
        private Object value;
        private NodeType type;
        
        public enum NodeType {
            ASSUMPTION,    // Hypothèse de base
            DERIVED,       // Conclusion dérivée
            CONTRADICTION  // Nœud de contradiction
        }
    }
    
    public static class Edge {
        private String source;
        private String target;
        private EdgeType type;
        private String justification;
        
        public enum EdgeType {
            SUPPORT,    // Support positif
            DEFEAT,     // Défaite/attaque
            DEPENDENCY  // Dépendance simple
        }
    }
}
```

#### 3.1.2 Détection de Cycles

```java
public class CycleDetector {
    private DependencyGraph graph;
    private Set<String> visited;
    private Set<String> recursionStack;
    
    public List<List<String>> findAllCycles() {
        List<List<String>> cycles = new ArrayList<>();
        visited = new HashSet<>();
        recursionStack = new HashSet<>();
        
        for (String nodeId : graph.getNodes().keySet()) {
            if (!visited.contains(nodeId)) {
                List<String> currentPath = new ArrayList<>();
                findCyclesFromNode(nodeId, currentPath, cycles);
            }
        }
        
        return cycles;
    }
    
    private void findCyclesFromNode(String nodeId, List<String> path, 
                                   List<List<String>> cycles) {
        visited.add(nodeId);
        recursionStack.add(nodeId);
        path.add(nodeId);
        
        for (Edge edge : graph.getOutgoingEdges(nodeId)) {
            String target = edge.getTarget();
            
            if (recursionStack.contains(target)) {
                // Cycle détecté
                int cycleStart = path.indexOf(target);
                List<String> cycle = new ArrayList<>(path.subList(cycleStart, path.size()));
                cycles.add(cycle);
            } else if (!visited.contains(target)) {
                findCyclesFromNode(target, path, cycles);
            }
        }
        
        recursionStack.remove(nodeId);
        path.remove(path.size() - 1);
    }
}
```

### 3.2 Propagation de Labels (IN/OUT)

#### 3.2.1 Algorithme de Propagation Efficace

```java
public class LabelPropagator {
    private DependencyGraph graph;
    private Map<String, Label> labels;
    private Queue<String> propagationQueue;
    
    public enum Label {
        IN, OUT, UNKNOWN
    }
    
    public void propagateLabels() {
        initializeLabels();
        
        while (!propagationQueue.isEmpty()) {
            String nodeId = propagationQueue.poll();
            Label oldLabel = labels.get(nodeId);
            Label newLabel = computeLabel(nodeId);
            
            if (oldLabel != newLabel) {
                labels.put(nodeId, newLabel);
                scheduleConsequences(nodeId);
            }
        }
    }
    
    private Label computeLabel(String nodeId) {
        Node node = graph.getNode(nodeId);
        
        if (node.getType() == NodeType.ASSUMPTION) {
            return Label.IN; // Les hypothèses sont toujours IN par défaut
        }
        
        // Vérifier les justifications
        for (Edge edge : graph.getIncomingEdges(nodeId)) {
            if (edge.getType() == EdgeType.SUPPORT) {
                if (labels.get(edge.getSource()) == Label.IN) {
                    return Label.IN;
                }
            } else if (edge.getType() == EdgeType.DEFEAT) {
                if (labels.get(edge.getSource()) == Label.IN) {
                    return Label.OUT;
                }
            }
        }
        
        return Label.UNKNOWN;
    }
    
    private void scheduleConsequences(String nodeId) {
        for (Edge edge : graph.getOutgoingEdges(nodeId)) {
            propagationQueue.offer(edge.getTarget());
        }
    }
}
```
### 3.3 Gestion des Contradictions

#### 3.3.1 Détection de Contradictions

```java
public class ContradictionDetector {
    private DependencyGraph graph;
    private Map<String, Label> labels;
    
    public Set<Contradiction> detectContradictions() {
        Set<Contradiction> contradictions = new HashSet<>();
        
        for (String nodeId : graph.getNodes().keySet()) {
            Node node = graph.getNode(nodeId);
            if (node.getType() == NodeType.CONTRADICTION) {
                if (labels.get(nodeId) == Label.IN) {
                    contradictions.add(new Contradiction(nodeId, findSupport(nodeId)));
                }
            }
        }
        
        return contradictions;
    }
    
    public static class Contradiction {
        private String contradictionNode;
        private Set<String> supportingNodes;
        
        public Contradiction(String node, Set<String> support) {
            this.contradictionNode = node;
            this.supportingNodes = support;
        }
        
        // Getters...
    }
    
    private Set<String> findSupport(String nodeId) {
        Set<String> support = new HashSet<>();
        findSupportRecursive(nodeId, support, new HashSet<>());
        return support;
    }
    
    private void findSupportRecursive(String nodeId, Set<String> support, 
                                    Set<String> visited) {
        if (visited.contains(nodeId)) return;
        visited.add(nodeId);
        
        Node node = graph.getNode(nodeId);
        if (node.getType() == NodeType.ASSUMPTION) {
            support.add(nodeId);
            return;
        }
        
        for (Edge edge : graph.getIncomingEdges(nodeId)) {
            if (edge.getType() == EdgeType.SUPPORT && 
                labels.get(edge.getSource()) == Label.IN) {
                findSupportRecursive(edge.getSource(), support, visited);
            }
        }
    }
}
```

### 3.4 Algorithmes de Révision Efficaces

#### 3.4.1 Révision Minimale

```java
public class MinimalRevisionEngine {
    private DependencyGraph graph;
    private ContradictionDetector detector;
    
    public RevisionResult performMinimalRevision() {
        Set<Contradiction> contradictions = detector.detectContradictions();
        
        if (contradictions.isEmpty()) {
            return new RevisionResult(Collections.emptySet(), true);
        }
        
        // Trouver l'ensemble minimal d'hypothèses à retirer
        Set<String> toRemove = findMinimalCut(contradictions);
        
        // Appliquer la révision
        for (String nodeId : toRemove) {
            removeAssumption(nodeId);
        }
        
        return new RevisionResult(toRemove, contradictions.isEmpty());
    }
    
    private Set<String> findMinimalCut(Set<Contradiction> contradictions) {
        // Algorithme glouton pour trouver un ensemble minimal
        // (approximation - le problème exact est NP-difficile)
        
        Map<String, Integer> assumptionCount = new HashMap<>();
        
        // Compter combien de contradictions chaque hypothèse supporte
        for (Contradiction contradiction : contradictions) {
            for (String assumption : contradiction.getSupportingNodes()) {
                assumptionCount.merge(assumption, 1, Integer::sum);
            }
        }
        
        // Sélectionner les hypothèses qui résolvent le plus de contradictions
        Set<String> toRemove = new HashSet<>();
        Set<Contradiction> resolved = new HashSet<>();
        
        while (resolved.size() < contradictions.size()) {
            String bestAssumption = null;
            int maxResolved = 0;
            
            for (Map.Entry<String, Integer> entry : assumptionCount.entrySet()) {
                if (!toRemove.contains(entry.getKey()) && entry.getValue() > maxResolved) {
                    maxResolved = entry.getValue();
                    bestAssumption = entry.getKey();
                }
            }
            
            if (bestAssumption != null) {
                toRemove.add(bestAssumption);
                // Marquer les contradictions résolues
                for (Contradiction contradiction : contradictions) {
                    if (contradiction.getSupportingNodes().contains(bestAssumption)) {
                        resolved.add(contradiction);
                    }
                }
            } else {
                break; // Pas de solution trouvée
            }
        }
        
        return toRemove;
    }
    
    public static class RevisionResult {
        private Set<String> removedAssumptions;
        private boolean isConsistent;
        
        public RevisionResult(Set<String> removed, boolean consistent) {
            this.removedAssumptions = removed;
            this.isConsistent = consistent;
        }
        
        // Getters...
    }
}
```

---

## 4. Intégration TweetyProject

L'intégration avec TweetyProject est centrale à ce projet. TweetyProject servira de **fournisseur principal pour les logiques de TMS sous-jacentes et les mécanismes de révision de croyances ("belief dynamics")**. L'interaction entre les agents Python et la bibliothèque Java TweetyProject se fera via **`jpype`**, un outil permettant de démarrer une JVM et d'interagir avec des classes Java depuis Python.

Il est crucial de bien comprendre le rôle de TweetyProject : il ne s'agit pas de réimplémenter les TMS depuis zéro en Python, mais de créer des agents Python qui **utilisent et exposent les fonctionnalités TMS de TweetyProject**.

Les étudiants sont encouragés à explorer spécifiquement les classes et méthodes de TweetyProject relatives aux JTMS, ATMS, et plus généralement à la "belief dynamics". Cela inclut, mais n'est pas limité à, l'étude des packages `org.tweetyproject.beliefdynamics` et des modules liés aux différents types de TMS si disponibles directement, ou comment les construire en utilisant les briques de révision de croyances.

Pour l'implémentation, si des sections de code illustrant l'appel aux fonctionnalités de TMS de Tweety via `jpype` peuvent être ajoutées, elles seraient bénéfiques. À défaut, les étudiants devraient s'inspirer des tests unitaires existants pour d'autres modules TweetyProject (comme ceux pour l'argumentation dialogique ou QBF, par exemple dans `tests/integration/jpype_tweety/`) pour structurer leurs appels `jpype`.

### 4.1 Utilisation des Belief Bases

TweetyProject fournit une infrastructure complète pour la révision de croyances dans le package `org.tweetyproject.beliefdynamics`.

#### 4.1.1 Configuration de Base

```java
import org.tweetyproject.beliefdynamics.*;
import org.tweetyproject.beliefdynamics.operators.*;
import org.tweetyproject.beliefdynamics.kernels.*;
import org.tweetyproject.logics.pl.syntax.*;
import org.tweetyproject.logics.pl.parser.*;
import org.tweetyproject.logics.pl.reasoner.*;

public class TweetyTMSSetup {
    
    public static void main(String[] args) throws Exception {
        // Parser pour la logique propositionnelle
        PlParser parser = new PlParser();
        
        // Base de croyances initiale
        PlBeliefSet beliefSet = new PlBeliefSet();
        beliefSet.add((PlFormula) parser.parseFormula("bird(tweety)"));
        beliefSet.add((PlFormula) parser.parseFormula("bird(X) && !abnormal(X) -> flies(X)"));
        beliefSet.add((PlFormula) parser.parseFormula("!abnormal(tweety)"));
        
        System.out.println("Base initiale: " + beliefSet);
        
        // Nouvelle information contradictoire
        PlFormula newInfo = (PlFormula) parser.parseFormula("penguin(tweety)");
        PlFormula penguinRule = (PlFormula) parser.parseFormula("penguin(X) -> abnormal(X)");
        
        // Configuration de l'opérateur de révision
        setupRevisionOperator(beliefSet, newInfo, penguinRule);
    }
    
    private static void setupRevisionOperator(PlBeliefSet beliefSet, 
                                            PlFormula newInfo, 
                                            PlFormula additionalRule) {
        // Opérateur de contraction par kernel
        KernelContractionOperator<PlFormula> contractionOp = 
            new KernelContractionOperator<>(
                new RandomIncisionFunction<PlFormula>(), 
                new SimplePlReasoner()
            );
        
        // Opérateur d'expansion
        DefaultMultipleBaseExpansionOperator<PlFormula> expansionOp = 
            new DefaultMultipleBaseExpansionOperator<>();
        
        // Opérateur de révision de Levi
        LeviMultipleBaseRevisionOperator<PlFormula> revisionOp = 
            new LeviMultipleBaseRevisionOperator<>(contractionOp, expansionOp);
        
        // Application de la révision
        Collection<PlFormula> newInformation = Arrays.asList(newInfo, additionalRule);
        Collection<PlFormula> revisedBeliefs = revisionOp.revise(beliefSet, newInformation);
        
        System.out.println("Base révisée: " + revisedBeliefs);
    }
}
```

#### 4.1.2 Exemple Basé sur CrMasExample

```java
import org.tweetyproject.beliefdynamics.mas.*;
import org.tweetyproject.agents.*;
import org.tweetyproject.comparator.Order;

public class CrMasTMSExample {
    
    public static void runMultiAgentTMS() throws Exception {
        PlParser parser = new PlParser();
        
        // Création des agents
        List<Agent> agents = new ArrayList<>();
        agents.add(new DummyAgent("Expert"));      // Agent le plus crédible
        agents.add(new DummyAgent("Witness"));     // Agent moyennement crédible
        agents.add(new DummyAgent("Rumor"));       // Agent peu crédible
        
        // Ordre de crédibilité: Expert > Witness > Rumor
        Order<Agent> credibilityOrder = new Order<>(agents);
        credibilityOrder.setOrderedBefore(agents.get(0), agents.get(1));
        credibilityOrder.setOrderedBefore(agents.get(1), agents.get(2));
        
        // Base de croyances multi-agents
        CrMasBeliefSet<PlFormula, PlSignature> beliefSet = 
            new CrMasBeliefSet<>(credibilityOrder, new PlSignature());
        
        // Ajout d'informations avec sources
        beliefSet.add(new InformationObject<>(
            (PlFormula) parser.parseFormula("bird(tweety)"), 
            agents.get(1) // Witness
        ));
        
        beliefSet.add(new InformationObject<>(
            (PlFormula) parser.parseFormula("!flies(tweety)"), 
            agents.get(2) // Rumor
        ));
        
        // Nouvelle information de l'expert
        Collection<InformationObject<PlFormula>> newInfo = new HashSet<>();
        newInfo.add(new InformationObject<>(
            (PlFormula) parser.parseFormula("penguin(tweety)"), 
            agents.get(0) // Expert
        ));
        
        newInfo.add(new InformationObject<>(
            (PlFormula) parser.parseFormula("penguin(X) -> !flies(X)"), 
            agents.get(0) // Expert
        ));
        
        System.out.println("Base initiale: " + beliefSet);
        System.out.println("Nouvelles informations: " + newInfo);
        
        // Test des différents opérateurs de révision
        testRevisionOperators(beliefSet, newInfo);
    }
    
    private static void testRevisionOperators(
            CrMasBeliefSet<PlFormula, PlSignature> beliefSet,
            Collection<InformationObject<PlFormula>> newInfo) {
        
        // 1. Révision priorisée simple
        System.out.println("\n=== Révision Priorisée ===");
        CrMasRevisionWrapper<PlFormula> prioritizedRevision = 
            new CrMasRevisionWrapper<>(
                new LeviMultipleBaseRevisionOperator<>(
                    new KernelContractionOperator<>(
                        new RandomIncisionFunction<>(), 
                        new SimplePlReasoner()
                    ),
                    new DefaultMultipleBaseExpansionOperator<>()
                )
            );
        
        try {
            Collection<InformationObject<PlFormula>> result1 = 
                prioritizedRevision.revise(beliefSet, newInfo);
            System.out.println("Résultat PRIO: " + result1);
        } catch (Exception e) {
            System.out.println("Erreur PRIO: " + e.getMessage());
        }
        
        // 2. Révision non-priorisée avec crédibilité
        System.out.println("\n=== Révision Non-Priorisée (Crédibilité) ===");
        try {
            CrMasSimpleRevisionOperator simpleRevision = new CrMasSimpleRevisionOperator();
            Collection<InformationObject<PlFormula>> result2 = 
                simpleRevision.revise(beliefSet, newInfo);
            System.out.println("Résultat N-PRIO CRED: " + result2);
        } catch (Exception e) {
            System.out.println("Erreur N-PRIO: " + e.getMessage());
        }
        
        // 3. Révision argumentative
        System.out.println("\n=== Révision Argumentative ===");
        try {
            CrMasArgumentativeRevisionOperator argRevision = 
                new CrMasArgumentativeRevisionOperator();
            Collection<InformationObject<PlFormula>> result3 = 
                argRevision.revise(beliefSet, newInfo);
            System.out.println("Résultat ARG: " + result3);
        } catch (Exception e) {
            System.out.println("Erreur ARG: " + e.getMessage());
        }
    }
}
```
### 4.2 Opérateurs de Révision (AGM)

#### 4.2.1 Implémentation des Postulats AGM

```java
public class AGMRevisionOperator {
    private PlReasoner reasoner;
    private IncisionFunction<PlFormula> incisionFunction;
    
    public AGMRevisionOperator(PlReasoner reasoner, IncisionFunction<PlFormula> incision) {
        this.reasoner = reasoner;
        this.incisionFunction = incision;
    }
    
    /**
     * Révision selon la construction de Levi: K * φ = (K ÷ ¬φ) ∪ {φ}
     */
    public PlBeliefSet revise(PlBeliefSet beliefSet, PlFormula newFormula) {
        // Étape 1: Contracter par la négation de la nouvelle formule
        PlFormula negatedFormula = new Negation(newFormula);
        PlBeliefSet contracted = contract(beliefSet, negatedFormula);
        
        // Étape 2: Ajouter la nouvelle formule
        contracted.add(newFormula);
        
        return contracted;
    }
    
    /**
     * Contraction selon les postulats AGM
     */
    public PlBeliefSet contract(PlBeliefSet beliefSet, PlFormula formula) {
        // Vérifier la vacuité (postulat 3)
        if (!reasoner.query(beliefSet, formula)) {
            return new PlBeliefSet(beliefSet); // Pas de changement
        }
        
        // Vérifier si la formule est une tautologie (postulat 4)
        if (reasoner.query(new PlBeliefSet(), formula)) {
            return new PlBeliefSet(beliefSet); // Pas de contraction possible
        }
        
        // Trouver les ensembles de reste (remainder sets)
        Set<PlBeliefSet> remainderSets = findRemainderSets(beliefSet, formula);
        
        // Appliquer la fonction d'incision
        Set<PlFormula> toRemove = incisionFunction.incise(remainderSets);
        
        // Construire la base contractée
        PlBeliefSet result = new PlBeliefSet();
        for (PlFormula f : beliefSet) {
            if (!toRemove.contains(f)) {
                result.add(f);
            }
        }
        
        return result;
    }
    
    private Set<PlBeliefSet> findRemainderSets(PlBeliefSet beliefSet, PlFormula formula) {
        Set<PlBeliefSet> remainderSets = new HashSet<>();
        
        // Algorithme naïf pour trouver les ensembles de reste maximaux
        // qui n'impliquent pas la formule
        Set<Set<PlFormula>> subsets = generateMaximalSubsets(beliefSet, formula);
        
        for (Set<PlFormula> subset : subsets) {
            PlBeliefSet remainder = new PlBeliefSet(subset);
            if (!reasoner.query(remainder, formula)) {
                remainderSets.add(remainder);
            }
        }
        
        return remainderSets;
    }
    
    private Set<Set<PlFormula>> generateMaximalSubsets(PlBeliefSet beliefSet, 
                                                      PlFormula formula) {
        // Implémentation simplifiée - en pratique, utiliser des algorithmes optimisés
        Set<Set<PlFormula>> maximalSubsets = new HashSet<>();
        
        // Générer tous les sous-ensembles et garder les maximaux
        // qui ne dérivèrent pas la formule
        List<PlFormula> formulas = new ArrayList<>(beliefSet);
        
        for (int i = 0; i < (1 << formulas.size()); i++) {
            Set<PlFormula> subset = new HashSet<>();
            for (int j = 0; j < formulas.size(); j++) {
                if ((i & (1 << j)) != 0) {
                    subset.add(formulas.get(j));
                }
            }
            
            PlBeliefSet testSet = new PlBeliefSet(subset);
            if (!reasoner.query(testSet, formula)) {
                // Vérifier la maximalité
                if (isMaximal(subset, formulas, formula)) {
                    maximalSubsets.add(subset);
                }
            }
        }
        
        return maximalSubsets;
    }
    
    private boolean isMaximal(Set<PlFormula> subset, List<PlFormula> allFormulas, 
                             PlFormula formula) {
        for (PlFormula f : allFormulas) {
            if (!subset.contains(f)) {
                Set<PlFormula> extended = new HashSet<>(subset);
                extended.add(f);
                PlBeliefSet testSet = new PlBeliefSet(extended);
                if (!reasoner.query(testSet, formula)) {
                    return false; // Pas maximal
                }
            }
        }
        return true;
    }
}
```

#### 4.2.2 Fonctions d'Incision

```java
/**
 * Fonction d'incision aléatoire
 */
public class RandomIncisionFunction<T extends Formula> implements IncisionFunction<T> {
    private Random random = new Random();
    
    @Override
    public Set<T> incise(Collection<? extends Collection<T>> remainderSets) {
        Set<T> result = new HashSet<>();
        
        for (Collection<T> remainderSet : remainderSets) {
            if (!remainderSet.isEmpty()) {
                // Choisir un élément aléatoire de chaque ensemble de reste
                List<T> formulas = new ArrayList<>(remainderSet);
                T selected = formulas.get(random.nextInt(formulas.size()));
                result.add(selected);
            }
        }
        
        return result;
    }
}

/**
 * Fonction d'incision basée sur les priorités
 */
public class PriorityIncisionFunction<T extends Formula> implements IncisionFunction<T> {
    private Map<T, Double> priorities;
    
    public PriorityIncisionFunction(Map<T, Double> priorities) {
        this.priorities = priorities;
    }
    
    @Override
    public Set<T> incise(Collection<? extends Collection<T>> remainderSets) {
        Set<T> result = new HashSet<>();
        
        for (Collection<T> remainderSet : remainderSets) {
            T lowestPriority = null;
            double minPriority = Double.MAX_VALUE;
            
            for (T formula : remainderSet) {
                double priority = priorities.getOrDefault(formula, 1.0);
                if (priority < minPriority) {
                    minPriority = priority;
                    lowestPriority = formula;
                }
            }
            
            if (lowestPriority != null) {
                result.add(lowestPriority);
            }
        }
        
        return result;
    }
}
```

### 4.3 Validation Formelle des Révisions

#### 4.3.1 Vérification des Postulats

```java
public class AGMPostulateValidator {
    private PlReasoner reasoner;
    
    public AGMPostulateValidator(PlReasoner reasoner) {
        this.reasoner = reasoner;
    }
    
    public ValidationResult validateRevisionOperator(
            BaseRevisionOperator<PlFormula> operator,
            PlBeliefSet testSet,
            PlFormula testFormula) {
        
        ValidationResult result = new ValidationResult();
        
        // Test des postulats de révision
        result.addResult("R1", testPostulateR1(operator, testSet, testFormula));
        result.addResult("R2", testPostulateR2(operator, testSet, testFormula));
        result.addResult("R3", testPostulateR3(operator, testSet, testFormula));
        result.addResult("R4", testPostulateR4(operator, testSet, testFormula));
        result.addResult("R5", testPostulateR5(operator, testSet, testFormula));
        result.addResult("R6", testPostulateR6(operator, testSet, testFormula));
        
        return result;
    }
    
    // R1: K * φ est un ensemble de formules
    private boolean testPostulateR1(BaseRevisionOperator<PlFormula> operator,
                                   PlBeliefSet beliefSet, PlFormula formula) {
        try {
            Collection<PlFormula> result = operator.revise(beliefSet, formula);
            return result != null;
        } catch (Exception e) {
            return false;
        }
    }
    
    // R2: φ ∈ K * φ (succès)
    private boolean testPostulateR2(BaseRevisionOperator<PlFormula> operator,
                                   PlBeliefSet beliefSet, PlFormula formula) {
        Collection<PlFormula> result = operator.revise(beliefSet, formula);
        return result.contains(formula);
    }
    
    // R3: K * φ ⊆ Cn(K ∪ {φ}) (inclusion)
    private boolean testPostulateR3(BaseRevisionOperator<PlFormula> operator,
                                   PlBeliefSet beliefSet, PlFormula formula) {
        Collection<PlFormula> revised = operator.revise(beliefSet, formula);
        
        PlBeliefSet expanded = new PlBeliefSet(beliefSet);
        expanded.add(formula);
        
        // Vérifier que chaque formule de la révision est dérivable de K ∪ {φ}
        for (PlFormula f : revised) {
            if (!reasoner.query(expanded, f)) {
                return false;
            }
        }
        
        return true;
    }
    
    // R4: Si ¬φ ∉ K, alors Cn(K ∪ {φ}) ⊆ K * φ (préservation)
    private boolean testPostulateR4(BaseRevisionOperator<PlFormula> operator,
                                   PlBeliefSet beliefSet, PlFormula formula) {
        PlFormula negFormula = new Negation(formula);
        
        if (reasoner.query(beliefSet, negFormula)) {
            return true; // Condition non applicable
        }
        
        Collection<PlFormula> revised = operator.revise(beliefSet, formula);
        PlBeliefSet revisedSet = new PlBeliefSet(revised);
        
        PlBeliefSet expanded = new PlBeliefSet(beliefSet);
        expanded.add(formula);
        
        // Vérifier que K ∪ {φ} ⊆ Cn(K * φ)
        for (PlFormula f : expanded) {
            if (!reasoner.query(revisedSet, f)) {
                return false;
            }
        }
        
        return true;
    }
    
    // R5: K * φ est inconsistant ssi ⊢ ¬φ (consistance)
    private boolean testPostulateR5(BaseRevisionOperator<PlFormula> operator,
                                   PlBeliefSet beliefSet, PlFormula formula) {
        Collection<PlFormula> revised = operator.revise(beliefSet, formula);
        PlBeliefSet revisedSet = new PlBeliefSet(revised);
        
        boolean revisedInconsistent = !reasoner.isConsistent(revisedSet);
        boolean formulaTautology = reasoner.query(new PlBeliefSet(), new Negation(formula));
        
        return revisedInconsistent == formulaTautology;
    }
    
    // R6: K * φ = K * ψ si ⊢ φ ↔ ψ (extensionalité)
    private boolean testPostulateR6(BaseRevisionOperator<PlFormula> operator,
                                   PlBeliefSet beliefSet, PlFormula formula1) {
        // Test avec une formule équivalente
        PlFormula formula2 = new Negation(new Negation(formula1)); // φ ≡ ¬¬φ
        
        Collection<PlFormula> result1 = operator.revise(beliefSet, formula1);
        Collection<PlFormula> result2 = operator.revise(beliefSet, formula2);
        
        return result1.equals(result2);
    }
    
    public static class ValidationResult {
        private Map<String, Boolean> results = new HashMap<>();
        
        public void addResult(String postulate, boolean satisfied) {
            results.put(postulate, satisfied);
        }
        
        public boolean allSatisfied() {
            return results.values().stream().allMatch(Boolean::booleanValue);
        }
        
        public Map<String, Boolean> getResults() {
            return results;
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("Validation des postulats AGM:\n");
            for (Map.Entry<String, Boolean> entry : results.entrySet()) {
                sb.append(String.format("  %s: %s\n", 
                    entry.getKey(), 
                    entry.getValue() ? "✓" : "✗"));
            }
            return sb.toString();
        }
    }
}
```

### 4.4 Mesures d'Incohérence

#### 4.4.1 Intégration avec TweetyProject

```java
import org.tweetyproject.logics.pl.analysis.*;
import org.tweetyproject.logics.commons.analysis.*;

public class InconsistencyMeasureExample {
    
    public static void demonstrateInconsistencyMeasures() throws Exception {
        PlParser parser = new PlParser();
        
        // Base de croyances inconsistante
        PlBeliefSet inconsistentSet = new PlBeliefSet();
        inconsistentSet.add((PlFormula) parser.parseFormula("a"));
        inconsistentSet.add((PlFormula) parser.parseFormula("!a"));
        inconsistentSet.add((PlFormula) parser.parseFormula("b && c"));
        inconsistentSet.add((PlFormula) parser.parseFormula("!b || !c"));
        
        System.out.println("Base inconsistante: " + inconsistentSet);
        
        // 1. Mesure de Contension
        testContensionMeasure(inconsistentSet);
        
        // 2. Mesures basées sur MUS
        testMUSBasedMeasures(inconsistentSet);
        
        // 3. Mesures basées sur la distance
        testDistanceBasedMeasures(inconsistentSet);
        
        // 4. Mesure floue
        testFuzzyMeasure(inconsistentSet);
    }
    
    private static void testContensionMeasure(PlBeliefSet beliefSet) {
        System.out.println("\n=== Mesure de Contension ===");
        try {
            ContensionInconsistencyMeasure contension = new ContensionInconsistencyMeasure();
            Double value = contension.inconsistencyMeasure(beliefSet);
            System.out.println("Valeur de contension: " + value);
        } catch (Exception e) {
            System.out.println("Erreur contension: " + e.getMessage());
        }
    }
    
    private static void testMUSBasedMeasures(PlBeliefSet beliefSet) {
        System.out.println("\n=== Mesures basées sur MUS ===");
        try {
            // Énumérateur MUS naïf
            NaiveMusEnumerator musEnumerator = new NaiveMusEnumerator(SatSolver.getDefaultSolver());
            
            // Mesure Ma (nombre de MUS)
            MaInconsistencyMeasure maMeasure = new MaInconsistencyMeasure(musEnumerator);
            Double maValue = maMeasure.inconsistencyMeasure(beliefSet);
            System.out.println("Mesure Ma (nombre de MUS): " + maValue);
            
            // Mesure Mcsc (taille du plus petit ensemble de correction)
            McscInconsistencyMeasure mcscMeasure = new McscInconsistencyMeasure(musEnumerator);
            Double mcscValue = mcscMeasure.inconsistencyMeasure(beliefSet);
            System.out.println("Mesure Mcsc (plus petit ensemble de correction): " + mcscValue);
            
        } catch (Exception e) {
            System.out.println("Erreur MUS: " + e.getMessage());
        }
    }
    
    private static void testDistanceBasedMeasures(PlBeliefSet beliefSet) {
        System.out.println("\n=== Mesures basées sur la distance ===");
        try {
            PlSignature signature = (PlSignature) beliefSet.getMinimalSignature();
            PossibleWorldIterator worldIterator = new PossibleWorldIterator(signature);
            DalalDistance distance = new DalalDistance();
            
            // Mesure DSum
            DSumInconsistencyMeasure dsumMeasure = 
                new DSumInconsistencyMeasure(distance, worldIterator);
            Double dsumValue = dsumMeasure.inconsistencyMeasure(beliefSet);
            System.out.println("Mesure DSum: " + dsumValue);
            
            // Mesure DMax
            DMaxInconsistencyMeasure dmaxMeasure = 
                new DMaxInconsistencyMeasure(distance, worldIterator);
            Double dmaxValue = dmaxMeasure.inconsistencyMeasure(beliefSet);
            System.out.println("Mesure DMax: " + dmaxValue);
            
            // Mesure DHit
            DHitInconsistencyMeasure dhitMeasure = 
                new DHitInconsistencyMeasure(distance, worldIterator);
            Double dhitValue = dhitMeasure.inconsistencyMeasure(beliefSet);
            System.out.println("Mesure DHit: " + dhitValue);
            
        } catch (Exception e) {
            System.out.println("Erreur distance: " + e.getMessage());
        }
    }
    
    private static void testFuzzyMeasure(PlBeliefSet beliefSet) {
        System.out.println("\n=== Mesure Floue ===");
        try {
            ProductNorm productNorm = new ProductNorm();
            FuzzyInconsistencyMeasure fuzzyMeasure = 
                new FuzzyInconsistencyMeasure(productNorm, 
                    FuzzyInconsistencyMeasure.SUMFUZZY_MEASURE);
            
            Double fuzzyValue = fuzzyMeasure.inconsistencyMeasure(beliefSet);
            System.out.println("Mesure floue (ProductNorm, Sum): " + fuzzyValue);
            
        } catch (Exception e) {
            System.out.println("Erreur floue: " + e.getMessage());
        }
    }
}
```
---

## 5. Implémentation Pratique

### 5.1 TMS Simple en Java/Python

#### 5.1.1 Architecture Modulaire

```java
public class SimpleTMS {
    private Map<String, TMSNode> nodes;
    private Set<TMSJustification> justifications;
    private LabelPropagator propagator;
    private ContradictionHandler contradictionHandler;
    
    public SimpleTMS() {
        this.nodes = new HashMap<>();
        this.justifications = new HashSet<>();
        this.propagator = new LabelPropagator(this);
        this.contradictionHandler = new ContradictionHandler(this);
    }
    
    public TMSNode createNode(String name, NodeType type) {
        TMSNode node = new TMSNode(name, type);
        nodes.put(name, node);
        return node;
    }
    
    public void addJustification(String consequent, Set<String> inList, 
                               Set<String> outList, String rule) {
        TMSJustification just = new TMSJustification(
            nodes.get(consequent), 
            inList.stream().map(nodes::get).collect(Collectors.toSet()),
            outList.stream().map(nodes::get).collect(Collectors.toSet()),
            rule
        );
        
        justifications.add(just);
        nodes.get(consequent).addJustification(just);
        
        // Déclencher la propagation
        propagator.scheduleNode(consequent);
    }
    
    public void setAssumption(String nodeName, boolean value) {
        TMSNode node = nodes.get(nodeName);
        if (node.getType() == NodeType.ASSUMPTION) {
            node.setStatus(value ? NodeStatus.IN : NodeStatus.OUT);
            propagator.scheduleNode(nodeName);
        }
    }
    
    public void propagate() {
        propagator.propagateAll();
        
        // Vérifier les contradictions
        Set<String> contradictions = contradictionHandler.detectContradictions();
        if (!contradictions.isEmpty()) {
            System.out.println("Contradictions détectées: " + contradictions);
            handleContradictions(contradictions);
        }
    }
    
    private void handleContradictions(Set<String> contradictions) {
        // Stratégie simple: retirer les hypothèses les moins prioritaires
        for (String contradiction : contradictions) {
            Set<String> support = findSupport(contradiction);
            String toRemove = selectLeastPriorityAssumption(support);
            if (toRemove != null) {
                setAssumption(toRemove, false);
                System.out.println("Retrait de l'hypothèse: " + toRemove);
            }
        }
        
        // Re-propager après révision
        propagate();
    }
    
    public void printStatus() {
        System.out.println("\n=== État du TMS ===");
        for (TMSNode node : nodes.values()) {
            System.out.println(String.format("%s: %s (%s)", 
                node.getName(), 
                node.getStatus(), 
                node.getType()));
        }
    }
    
    // Méthodes utilitaires
    private Set<String> findSupport(String nodeId) {
        // Implémentation de la recherche de support
        return new HashSet<>();
    }
    
    private String selectLeastPriorityAssumption(Set<String> assumptions) {
        // Sélection basée sur des priorités prédéfinies
        return assumptions.iterator().next();
    }
}
```

#### 5.1.2 Exemple d'Utilisation

```java
public class TMSExample {
    
    public static void main(String[] args) {
        // Créer un TMS simple
        SimpleTMS tms = new SimpleTMS();
        
        // Exemple: Tweety l'oiseau
        setupTweetyExample(tms);
        
        // Propagation initiale
        System.out.println("=== État initial ===");
        tms.propagate();
        tms.printStatus();
        
        // Ajouter nouvelle information: Tweety est un pingouin
        System.out.println("\n=== Ajout: Tweety est un pingouin ===");
        tms.setAssumption("penguin_tweety", true);
        tms.propagate();
        tms.printStatus();
    }
    
    private static void setupTweetyExample(SimpleTMS tms) {
        // Créer les nœuds
        tms.createNode("bird_tweety", NodeType.ASSUMPTION);
        tms.createNode("penguin_tweety", NodeType.ASSUMPTION);
        tms.createNode("abnormal_tweety", NodeType.DERIVED);
        tms.createNode("flies_tweety", NodeType.DERIVED);
        tms.createNode("not_flies_tweety", NodeType.DERIVED);
        tms.createNode("contradiction", NodeType.CONTRADICTION);
        
        // Règles d'inférence
        // R1: bird(X) ∧ ¬abnormal(X) → flies(X)
        tms.addJustification("flies_tweety", 
            Set.of("bird_tweety"), 
            Set.of("abnormal_tweety"), 
            "Les oiseaux volent par défaut");
        
        // R2: penguin(X) → abnormal(X)
        tms.addJustification("abnormal_tweety", 
            Set.of("penguin_tweety"), 
            Set.of(), 
            "Les pingouins sont anormaux");
        
        // R3: penguin(X) → ¬flies(X)
        tms.addJustification("not_flies_tweety", 
            Set.of("penguin_tweety"), 
            Set.of(), 
            "Les pingouins ne volent pas");
        
        // R4: flies(X) ∧ ¬flies(X) → ⊥
        tms.addJustification("contradiction", 
            Set.of("flies_tweety", "not_flies_tweety"), 
            Set.of(), 
            "Contradiction");
        
        // État initial: Tweety est un oiseau
        tms.setAssumption("bird_tweety", true);
        tms.setAssumption("penguin_tweety", false);
    }
}
```

### 5.2 Interface Graphique pour Visualisation

#### 5.2.1 Visualiseur de Graphe de Dépendances

```java
import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;
import java.util.*;

public class TMSVisualizer extends JPanel {
    private SimpleTMS tms;
    private Map<String, Point2D> nodePositions;
    private Map<String, Color> nodeColors;
    
    public TMSVisualizer(SimpleTMS tms) {
        this.tms = tms;
        this.nodePositions = new HashMap<>();
        this.nodeColors = new HashMap<>();
        
        setPreferredSize(new Dimension(800, 600));
        setBackground(Color.WHITE);
        
        // Calculer les positions des nœuds
        layoutNodes();
        updateColors();
    }
    
    private void layoutNodes() {
        // Algorithme de placement simple en cercle
        Set<String> nodeNames = tms.getNodes().keySet();
        int nodeCount = nodeNames.size();
        double angleStep = 2 * Math.PI / nodeCount;
        double radius = 200;
        Point2D center = new Point2D.Double(400, 300);
        
        int i = 0;
        for (String nodeName : nodeNames) {
            double angle = i * angleStep;
            double x = center.getX() + radius * Math.cos(angle);
            double y = center.getY() + radius * Math.sin(angle);
            nodePositions.put(nodeName, new Point2D.Double(x, y));
            i++;
        }
    }
    
    private void updateColors() {
        for (String nodeName : tms.getNodes().keySet()) {
            TMSNode node = tms.getNode(nodeName);
            Color color;
            
            switch (node.getStatus()) {
                case IN:
                    color = Color.GREEN;
                    break;
                case OUT:
                    color = Color.RED;
                    break;
                case UNKNOWN:
                default:
                    color = Color.GRAY;
                    break;
            }
            
            // Modifier la couleur selon le type
            if (node.getType() == NodeType.ASSUMPTION) {
                color = color.darker();
            } else if (node.getType() == NodeType.CONTRADICTION) {
                color = Color.ORANGE;
            }
            
            nodeColors.put(nodeName, color);
        }
    }
    
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Dessiner les arêtes (justifications)
        drawJustifications(g2d);
        
        // Dessiner les nœuds
        drawNodes(g2d);
        
        // Dessiner les labels
        drawLabels(g2d);
    }
    
    private void drawJustifications(Graphics2D g2d) {
        g2d.setStroke(new BasicStroke(2.0f));
        
        for (TMSJustification just : tms.getJustifications()) {
            String consequent = just.getConsequent().getName();
            Point2D consequentPos = nodePositions.get(consequent);
            
            // Dessiner les supports (IN list)
            g2d.setColor(Color.BLUE);
            for (TMSNode antecedent : just.getInList()) {
                Point2D antecedentPos = nodePositions.get(antecedent.getName());
                g2d.draw(new Line2D.Double(antecedentPos, consequentPos));
                
                // Flèche
                drawArrow(g2d, antecedentPos, consequentPos, Color.BLUE);
            }
            
            // Dessiner les inhibitions (OUT list)
            g2d.setColor(Color.RED);
            for (TMSNode inhibitor : just.getOutList()) {
                Point2D inhibitorPos = nodePositions.get(inhibitor.getName());
                
                // Ligne pointillée pour les inhibitions
                Stroke oldStroke = g2d.getStroke();
                g2d.setStroke(new BasicStroke(2.0f, BasicStroke.CAP_BUTT, 
                    BasicStroke.JOIN_MITER, 10.0f, new float[]{5.0f}, 0.0f));
                g2d.draw(new Line2D.Double(inhibitorPos, consequentPos));
                g2d.setStroke(oldStroke);
                
                drawArrow(g2d, inhibitorPos, consequentPos, Color.RED);
            }
        }
    }
    
    private void drawNodes(Graphics2D g2d) {
        for (Map.Entry<String, Point2D> entry : nodePositions.entrySet()) {
            String nodeName = entry.getKey();
            Point2D pos = entry.getValue();
            Color color = nodeColors.get(nodeName);
            
            // Dessiner le cercle
            int radius = 25;
            g2d.setColor(color);
            g2d.fillOval((int)(pos.getX() - radius), (int)(pos.getY() - radius), 
                        2 * radius, 2 * radius);
            
            // Contour
            g2d.setColor(Color.BLACK);
            g2d.setStroke(new BasicStroke(2.0f));
            g2d.drawOval((int)(pos.getX() - radius), (int)(pos.getY() - radius), 
                        2 * radius, 2 * radius);
        }
    }
    
    private void drawLabels(Graphics2D g2d) {
        g2d.setColor(Color.BLACK);
        g2d.setFont(new Font("Arial", Font.BOLD, 12));
        FontMetrics fm = g2d.getFontMetrics();
        
        for (Map.Entry<String, Point2D> entry : nodePositions.entrySet()) {
            String nodeName = entry.getKey();
            Point2D pos = entry.getValue();
            
            // Centrer le texte
            int textWidth = fm.stringWidth(nodeName);
            int textHeight = fm.getHeight();
            
            g2d.drawString(nodeName, 
                (int)(pos.getX() - textWidth / 2), 
                (int)(pos.getY() + textHeight / 4));
        }
    }
    
    private void drawArrow(Graphics2D g2d, Point2D from, Point2D to, Color color) {
        // Calculer la direction
        double dx = to.getX() - from.getX();
        double dy = to.getY() - from.getY();
        double length = Math.sqrt(dx * dx + dy * dy);
        
        if (length == 0) return;
        
        // Normaliser
        dx /= length;
        dy /= length;
        
        // Position de la pointe (à distance du centre du nœud)
        double arrowX = to.getX() - 25 * dx;
        double arrowY = to.getY() - 25 * dy;
        
        // Dessiner la pointe
        double arrowLength = 10;
        double arrowAngle = Math.PI / 6;
        
        double x1 = arrowX - arrowLength * Math.cos(Math.atan2(dy, dx) - arrowAngle);
        double y1 = arrowY - arrowLength * Math.sin(Math.atan2(dy, dx) - arrowAngle);
        
        double x2 = arrowX - arrowLength * Math.cos(Math.atan2(dy, dx) + arrowAngle);
        double y2 = arrowY - arrowLength * Math.sin(Math.atan2(dy, dx) + arrowAngle);
        
        g2d.setColor(color);
        g2d.draw(new Line2D.Double(arrowX, arrowY, x1, y1));
        g2d.draw(new Line2D.Double(arrowX, arrowY, x2, y2));
    }
    
    public void refresh() {
        updateColors();
        repaint();
    }
}
```

#### 5.2.2 Interface Principale

```java
public class TMSVisualizerApp extends JFrame {
    private SimpleTMS tms;
    private TMSVisualizer visualizer;
    private JTextArea logArea;
    
    public TMSVisualizerApp() {
        setTitle("TMS Visualizer");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());
        
        // Créer le TMS
        tms = new SimpleTMS();
        setupTweetyExample();
        
        // Créer le visualiseur
        visualizer = new TMSVisualizer(tms);
        add(visualizer, BorderLayout.CENTER);
        
        // Panneau de contrôle
        JPanel controlPanel = createControlPanel();
        add(controlPanel, BorderLayout.SOUTH);
        
        // Zone de log
        logArea = new JTextArea(10, 50);
        logArea.setEditable(false);
        JScrollPane scrollPane = new JScrollPane(logArea);
        add(scrollPane, BorderLayout.EAST);
        
        pack();
        setLocationRelativeTo(null);
        
        // Propagation initiale
        propagateAndLog();
    }
    
    private JPanel createControlPanel() {
        JPanel panel = new JPanel(new FlowLayout());
        
        // Boutons pour les hypothèses
        JButton birdButton = new JButton("Tweety est un oiseau");
        birdButton.addActionListener(e -> {
            tms.setAssumption("bird_tweety", true);
            propagateAndLog();
        });
        
        JButton penguinButton = new JButton("Tweety est un pingouin");
        penguinButton.addActionListener(e -> {
            tms.setAssumption("penguin_tweety", true);
            propagateAndLog();
        });
        
        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(e -> {
            tms = new SimpleTMS();
            setupTweetyExample();
            visualizer = new TMSVisualizer(tms);
            propagateAndLog();
        });
        
        panel.add(birdButton);
        panel.add(penguinButton);
        panel.add(resetButton);
        
        return panel;
    }
    
    private void propagateAndLog() {
        logArea.append("=== Propagation ===\n");
        tms.propagate();
        
        // Afficher l'état
        for (String nodeName : tms.getNodes().keySet()) {
            TMSNode node = tms.getNode(nodeName);
            logArea.append(String.format("%s: %s\n", nodeName, node.getStatus()));
        }
        logArea.append("\n");
        
        visualizer.refresh();
    }
    
    private void setupTweetyExample() {
        // Même configuration que l'exemple précédent
        // ... (code identique)
    }
    
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            new TMSVisualizerApp().setVisible(true);
        });
    }
}
```

### 5.3 Benchmarking des Performances

#### 5.3.1 Framework de Test

```java
public class TMSBenchmark {
    
    public static void main(String[] args) {
        // Tests de performance sur différentes tailles
        int[] sizes = {10, 50, 100, 500, 1000};
        
        for (int size : sizes) {
            System.out.println("\n=== Test avec " + size + " nœuds ===");
            
            // Test JTMS
            benchmarkJTMS(size);
            
            // Test avec TweetyProject
            benchmarkTweetyProject(size);
        }
    }
    
    private static void benchmarkJTMS(int nodeCount) {
        SimpleTMS tms = new SimpleTMS();
        
        // Générer un graphe aléatoire
        generateRandomGraph(tms, nodeCount);
        
        // Mesurer le temps de propagation
        long startTime = System.nanoTime();
        tms.propagate();
        long endTime = System.nanoTime();
        
        double duration = (endTime - startTime) / 1_000_000.0; // ms
        System.out.println("JTMS (" + nodeCount + " nœuds): " + duration + " ms");
    }
    
    private static void benchmarkTweetyProject(int formulaCount) {
        try {
            PlParser parser = new PlParser();
            PlBeliefSet beliefSet = new PlBeliefSet();
            
            // Générer des formules aléatoires
            for (int i = 0; i < formulaCount; i++) {
                String formula = generateRandomFormula(i);
                beliefSet.add((PlFormula) parser.parseFormula(formula));
            }
            
            // Mesurer la révision
            long startTime = System.nanoTime();
            
            KernelContractionOperator<PlFormula> contractionOp = 
                new KernelContractionOperator<>(
                    new RandomIncisionFunction<>(), 
                    new SimplePlReasoner()
                );
            
            LeviMultipleBaseRevisionOperator<PlFormula> revisionOp = 
                new LeviMultipleBaseRevisionOperator<>(
                    contractionOp, 
                    new DefaultMultipleBaseExpansionOperator<>()
                );
            
            PlFormula newFormula = (PlFormula) parser.parseFormula("contradiction");
            Collection<PlFormula> result = revisionOp.revise(beliefSet, newFormula);
            
            long endTime = System.nanoTime();
            
            double duration = (endTime - startTime) / 1_000_000.0; // ms
            System.out.println("TweetyProject (" + formulaCount + " formules): " + duration + " ms");
            
        } catch (Exception e) {
            System.out.println("Erreur TweetyProject: " + e.getMessage());
        }
    }
    
    private static void generateRandomGraph(SimpleTMS tms, int nodeCount) {
        Random random = new Random();
        
        // Créer les nœuds
        for (int i = 0; i < nodeCount; i++) {
            NodeType type = (i < nodeCount / 4) ? NodeType.ASSUMPTION : NodeType.DERIVED;
            tms.createNode("node_" + i, type);
        }
        
        // Créer des justifications aléatoires
        for (int i = nodeCount / 4; i < nodeCount; i++) {
            Set<String> inList = new HashSet<>();
            Set<String> outList = new HashSet<>();
            
            // Ajouter quelques antécédents aléatoires
            int antecedentCount = random.nextInt(3) + 1;
            for (int j = 0; j < antecedentCount; j++) {
                int antecedent = random.nextInt(i);
                if (random.nextBoolean()) {
                    inList.add("node_" + antecedent);
                } else {
                    outList.add("node_" + antecedent);
                }
            }
            
            tms.addJustification("node_" + i, inList, outList, "rule_" + i);
        }
        
        // Activer quelques hypothèses aléatoirement
        for (int i = 0; i < nodeCount / 4; i++) {
            tms.setAssumption("node_" + i, random.nextBoolean());
        }
    }
    
    private static String generateRandomFormula(int index) {
        Random random = new Random();
        String[] operators = {"&&", "||", "->"};
        String[] variables = {"a", "b", "c", "d", "e"};
        
        if (random.nextBoolean()) {
            // Formule simple
            return variables[random.nextInt(variables.length)] + "_" + index;
        } else {
            // Formule composée
            String var1 = variables[random.nextInt(variables.length)] + "_" + index;
            String var2 = variables[random.nextInt(variables.length)] + "_" + (index + 1);
            String op = operators[random.nextInt(operators.length)];
            
            return var1 + " " + op + " " + var2;
        }
    }
}
```

### 5.4 Cas d'Usage en Argumentation

#### 5.4.1 Intégration avec Frameworks d'Argumentation

```java
import org.tweetyproject.arg.dung.syntax.*;
import org.tweetyproject.arg.dung.semantics.*;
import org.tweetyproject.arg.dung.reasoner.*;

public class ArgumentationTMSBridge {
    private SimpleTMS tms;
    private DungTheory argumentationFramework;
    private Map<Argument, String> argumentToNode;
    
    public ArgumentationTMSBridge() {
        this.tms = new SimpleTMS();
        this.argumentationFramework = new DungTheory();
        this.argumentToNode = new HashMap<>();
    }
    
    public void addArgument(String name, String content) {
        Argument arg = new Argument(name);
        argumentationFramework.add(arg);
        
        // Créer un nœud TMS correspondant
        String nodeName = "arg_" + name;
        tms.createNode(nodeName, NodeType.DERIVED);
        argumentToNode.put(arg, nodeName);
    }
    
    public void addAttack(String attacker, String target) {
        Argument attackerArg = findArgument(attacker);
        Argument targetArg = findArgument(target);
        
        if (attackerArg != null && targetArg != null) {
            // Ajouter l'attaque au framework
            argumentationFramework.add(new Attack(attackerArg, targetArg));
            
            // Créer une justification TMS: si attacker est IN, alors target est OUT
            String attackerNode = argumentToNode.get(attackerArg);
            String targetNode = argumentToNode.get(targetArg);
            
            tms.addJustification(targetNode + "_defeated", 
                Set.of(attackerNode), 
                Set.of(), 
                "Attaque de " + attacker + " vers " + target);
            
            // Justification pour mettre target OUT si il est attaqué
            tms.addJustification(targetNode, 
                Set.of(), 
                Set.of(targetNode + "_defeated"), 
                "Argument non attaqué");
        }
    }
    
    public void computeExtensions() {
        // Calculer les extensions avec TweetyProject
        GroundedReasoner reasoner = new GroundedReasoner();
        Extension groundedExtension = reasoner.getModel(argumentationFramework);
        
        System.out.println("Extension fondée: " + groundedExtension);
        
        // Synchroniser avec le TMS
        for (Argument arg : argumentationFramework) {
            String nodeName = argumentToNode.get(arg);
            boolean inExtension = groundedExtension.contains(arg);
            
            // Créer une hypothèse pour forcer l'état
            String assumptionName = nodeName + "_in_extension";
            tms.createNode(assumptionName, NodeType.ASSUMPTION);
            tms.setAssumption(assumptionName, inExtension);
            
            // Justification: si dans l'extension, alors l'argument est IN
            tms.addJustification(nodeName, 
                Set.of(assumptionName), 
                Set.of(), 
                "Dans l'extension fondée");
        }
        
        // Propager dans le TMS
        tms.propagate();
        tms.printStatus();
    }
    
    private Argument findArgument(String name) {
        for (Argument arg : argumentationFramework) {
            if (arg.getName().equals(name)) {
                return arg;
            }
        }
        return null;
    }
    
    public static void main(String[] args) {
        ArgumentationTMSBridge bridge = new ArgumentationTMSBridge();
        
        // Exemple: débat sur les voitures électriques
        bridge.addArgument("A", "Les voitures électriques sont écologiques");
        bridge.addArgument("B", "Les voitures électriques sont chères");
        bridge.addArgument("C", "Le coût diminue avec la production de masse");
        bridge.addArgument("D", "L'électricité peut venir de sources polluantes");
        
        // Attaques
        bridge.addAttack("B", "A"); // Le coût attaque l'aspect écologique
        bridge.addAttack("C", "B"); // La production de masse attaque le coût
        bridge.addAttack("D", "A"); // Les sources polluantes attaquent l'écologie
        
        // Calculer et afficher
        bridge.computeExtensions();
    }
}
```
---

## 6. Applications Avancées

### 6.1 TMS pour Systèmes Experts

#### 6.1.1 Architecture Intégrée

```java
public class ExpertSystemTMS {
    private SimpleTMS tms;
    private RuleBase ruleBase;
    private FactBase factBase;
    private InferenceEngine inferenceEngine;
    
    public ExpertSystemTMS() {
        this.tms = new SimpleTMS();
        this.ruleBase = new RuleBase();
        this.factBase = new FactBase();
        this.inferenceEngine = new InferenceEngine(tms);
    }
    
    public void addRule(String name, String condition, String conclusion, double certainty) {
        Rule rule = new Rule(name, condition, conclusion, certainty);
        ruleBase.addRule(rule);
        
        // Créer les nœuds TMS correspondants
        String conditionNode = "cond_" + name;
        String conclusionNode = "concl_" + name;
        
        tms.createNode(conditionNode, NodeType.DERIVED);
        tms.createNode(conclusionNode, NodeType.DERIVED);
        
        // Justification: condition → conclusion
        tms.addJustification(conclusionNode, 
            Set.of(conditionNode), 
            Set.of(), 
            "Règle: " + name + " (certitude: " + certainty + ")");
    }
    
    public void addFact(String fact, double certainty) {
        factBase.addFact(fact, certainty);
        
        // Créer un nœud hypothèse dans le TMS
        String factNode = "fact_" + fact.replaceAll("\\s+", "_");
        tms.createNode(factNode, NodeType.ASSUMPTION);
        tms.setAssumption(factNode, certainty > 0.5);
    }
    
    public void query(String goal) {
        System.out.println("Requête: " + goal);
        
        // Déclencher l'inférence
        inferenceEngine.forwardChain();
        tms.propagate();
        
        // Vérifier si le but est atteint
        String goalNode = "goal_" + goal.replaceAll("\\s+", "_");
        if (tms.getNodes().containsKey(goalNode)) {
            TMSNode node = tms.getNode(goalNode);
            System.out.println("Résultat: " + node.getStatus());
            
            if (node.getStatus() == NodeStatus.IN) {
                explainConclusion(goalNode);
            }
        } else {
            System.out.println("But non trouvé dans la base de connaissances");
        }
    }
    
    private void explainConclusion(String goalNode) {
        System.out.println("\nExplication:");
        Set<String> visited = new HashSet<>();
        explainRecursive(goalNode, visited, 0);
    }
    
    private void explainRecursive(String nodeId, Set<String> visited, int depth) {
        if (visited.contains(nodeId)) return;
        visited.add(nodeId);
        
        String indent = "  ".repeat(depth);
        TMSNode node = tms.getNode(nodeId);
        
        System.out.println(indent + nodeId + ": " + node.getStatus());
        
        // Trouver les justifications actives
        for (TMSJustification just : node.getJustifications()) {
            if (isJustificationActive(just)) {
                System.out.println(indent + "  Justifié par: " + just.getRule());
                
                for (TMSNode antecedent : just.getInList()) {
                    explainRecursive(antecedent.getName(), visited, depth + 2);
                }
            }
        }
    }
    
    private boolean isJustificationActive(TMSJustification just) {
        // Vérifier si tous les antécédents sont satisfaits
        for (TMSNode node : just.getInList()) {
            if (node.getStatus() != NodeStatus.IN) {
                return false;
            }
        }
        
        for (TMSNode node : just.getOutList()) {
            if (node.getStatus() != NodeStatus.OUT) {
                return false;
            }
        }
        
        return true;
    }
    
    // Classes auxiliaires
    public static class Rule {
        private String name, condition, conclusion;
        private double certainty;
        
        public Rule(String name, String condition, String conclusion, double certainty) {
            this.name = name;
            this.condition = condition;
            this.conclusion = conclusion;
            this.certainty = certainty;
        }
        
        // Getters...
    }
    
    public static class RuleBase {
        private List<Rule> rules = new ArrayList<>();
        
        public void addRule(Rule rule) {
            rules.add(rule);
        }
        
        public List<Rule> getRules() {
            return rules;
        }
    }
    
    public static class FactBase {
        private Map<String, Double> facts = new HashMap<>();
        
        public void addFact(String fact, double certainty) {
            facts.put(fact, certainty);
        }
        
        public Map<String, Double> getFacts() {
            return facts;
        }
    }
    
    public static class InferenceEngine {
        private SimpleTMS tms;
        
        public InferenceEngine(SimpleTMS tms) {
            this.tms = tms;
        }
        
        public void forwardChain() {
            // Implémentation du chaînage avant
            // Appliquer toutes les règles possibles
            boolean changed = true;
            while (changed) {
                changed = false;
                // Logique de chaînage avant
                // (simplifiée pour cet exemple)
            }
        }
    }
}
```

### 6.2 Maintenance de Cohérence en Bases de Connaissances

#### 6.2.1 Système de Gestion de Versions

```java
public class VersionedKnowledgeBase {
    private List<KBVersion> versions;
    private int currentVersion;
    private TweetyTMSIntegration tmsIntegration;
    
    public VersionedKnowledgeBase() {
        this.versions = new ArrayList<>();
        this.currentVersion = -1;
        this.tmsIntegration = new TweetyTMSIntegration();
        
        // Version initiale vide
        createNewVersion("Initial version");
    }
    
    public void addFormula(PlFormula formula, String source) {
        KBVersion current = getCurrentVersion();
        
        // Vérifier la cohérence avant ajout
        PlBeliefSet testSet = new PlBeliefSet(current.getFormulas());
        testSet.add(formula);
        
        if (!tmsIntegration.isConsistent(testSet)) {
            System.out.println("Ajout de " + formula + " causerait une incohérence");
            
            // Proposer des révisions
            Collection<PlFormula> revised = tmsIntegration.revise(testSet, formula);
            
            System.out.println("Révision proposée:");
            for (PlFormula f : revised) {
                System.out.println("  " + f);
            }
            
            // Créer une nouvelle version avec la révision
            createRevisionVersion(revised, "Révision après ajout de " + formula);
        } else {
            // Ajout simple
            current.addFormula(formula, source);
            System.out.println("Formule ajoutée: " + formula);
        }
    }
    
    public void removeFormula(PlFormula formula) {
        KBVersion current = getCurrentVersion();
        current.removeFormula(formula);
        
        System.out.println("Formule supprimée: " + formula);
    }
    
    public void createNewVersion(String description) {
        KBVersion newVersion = new KBVersion(versions.size(), description);
        if (!versions.isEmpty()) {
            // Copier la version précédente
            KBVersion previous = getCurrentVersion();
            newVersion.getFormulas().addAll(previous.getFormulas());
        }
        
        versions.add(newVersion);
        currentVersion = versions.size() - 1;
    }
    
    private void createRevisionVersion(Collection<PlFormula> formulas, String description) {
        KBVersion newVersion = new KBVersion(versions.size(), description);
        newVersion.getFormulas().addAll(formulas);
        
        versions.add(newVersion);
        currentVersion = versions.size() - 1;
    }
    
    public void revertToVersion(int versionId) {
        if (versionId >= 0 && versionId < versions.size()) {
            currentVersion = versionId;
            System.out.println("Retour à la version " + versionId);
        }
    }
    
    public KBVersion getCurrentVersion() {
        return versions.get(currentVersion);
    }
    
    public void printVersionHistory() {
        System.out.println("\n=== Historique des Versions ===");
        for (int i = 0; i < versions.size(); i++) {
            KBVersion version = versions.get(i);
            String marker = (i == currentVersion) ? " [CURRENT]" : "";
            System.out.println(String.format("Version %d: %s (%d formules)%s", 
                i, version.getDescription(), version.getFormulas().size(), marker));
        }
    }
    
    public static class KBVersion {
        private int id;
        private String description;
        private PlBeliefSet formulas;
        private Map<PlFormula, String> sources;
        private long timestamp;
        
        public KBVersion(int id, String description) {
            this.id = id;
            this.description = description;
            this.formulas = new PlBeliefSet();
            this.sources = new HashMap<>();
            this.timestamp = System.currentTimeMillis();
        }
        
        public void addFormula(PlFormula formula, String source) {
            formulas.add(formula);
            sources.put(formula, source);
        }
        
        public void removeFormula(PlFormula formula) {
            formulas.remove(formula);
            sources.remove(formula);
        }
        
        // Getters...
        public PlBeliefSet getFormulas() { return formulas; }
        public String getDescription() { return description; }
    }
}
```

### 6.3 Révision de Croyances en Temps Réel

#### 6.3.1 Système Réactif

```java
public class RealtimeTMS {
    private SimpleTMS tms;
    private EventQueue eventQueue;
    private Thread processingThread;
    private volatile boolean running;
    
    public RealtimeTMS() {
        this.tms = new SimpleTMS();
        this.eventQueue = new EventQueue();
        this.running = false;
    }
    
    public void start() {
        running = true;
        processingThread = new Thread(this::processEvents);
        processingThread.start();
        System.out.println("TMS temps réel démarré");
    }
    
    public void stop() {
        running = false;
        if (processingThread != null) {
            processingThread.interrupt();
        }
        System.out.println("TMS temps réel arrêté");
    }
    
    public void addEvent(TMSEvent event) {
        eventQueue.offer(event);
    }
    
    private void processEvents() {
        while (running) {
            try {
                TMSEvent event = eventQueue.poll(100, TimeUnit.MILLISECONDS);
                if (event != null) {
                    processEvent(event);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private void processEvent(TMSEvent event) {
        long startTime = System.nanoTime();
        
        switch (event.getType()) {
            case ADD_ASSUMPTION:
                tms.setAssumption(event.getNodeName(), event.getValue());
                break;
                
            case REMOVE_ASSUMPTION:
                tms.setAssumption(event.getNodeName(), false);
                break;
                
            case ADD_JUSTIFICATION:
                tms.addJustification(event.getConsequent(), 
                    event.getInList(), event.getOutList(), event.getRule());
                break;
                
            case QUERY_STATUS:
                TMSNode node = tms.getNode(event.getNodeName());
                System.out.println("Status de " + event.getNodeName() + ": " + 
                    (node != null ? node.getStatus() : "UNKNOWN"));
                break;
        }
        
        // Propagation
        tms.propagate();
        
        long endTime = System.nanoTime();
        double duration = (endTime - startTime) / 1_000_000.0;
        
        // Logging des performances
        if (duration > 10.0) { // Plus de 10ms
            System.out.println("⚠️ Événement lent: " + event.getType() + 
                " (" + duration + " ms)");
        }
        
        // Notifier les observateurs
        notifyObservers(event, duration);
    }
    
    private void notifyObservers(TMSEvent event, double processingTime) {
        // Implémentation du pattern Observer pour notifier les changements
        // en temps réel
    }
    
    // Classes auxiliaires
    public static class TMSEvent {
        private EventType type;
        private String nodeName;
        private boolean value;
        private String consequent;
        private Set<String> inList;
        private Set<String> outList;
        private String rule;
        private long timestamp;
        
        public TMSEvent(EventType type, String nodeName) {
            this.type = type;
            this.nodeName = nodeName;
            this.timestamp = System.currentTimeMillis();
        }
        
        // Constructeurs et getters...
        public EventType getType() { return type; }
        public String getNodeName() { return nodeName; }
        public boolean getValue() { return value; }
        public String getConsequent() { return consequent; }
        public Set<String> getInList() { return inList; }
        public Set<String> getOutList() { return outList; }
        public String getRule() { return rule; }
    }
    
    public enum EventType {
        ADD_ASSUMPTION,
        REMOVE_ASSUMPTION,
        ADD_JUSTIFICATION,
        QUERY_STATUS
    }
    
    public static class EventQueue {
        private BlockingQueue<TMSEvent> queue = new LinkedBlockingQueue<>();
        
        public void offer(TMSEvent event) {
            queue.offer(event);
        }
        
        public TMSEvent poll(long timeout, TimeUnit unit) throws InterruptedException {
            return queue.poll(timeout, unit);
        }
    }
}
```

### 6.4 Intégration avec des Agents Argumentatifs

#### 6.4.1 Agent Argumentatif avec TMS

```java
public class ArgumentativeAgent {
    private String name;
    private SimpleTMS tms;
    private Set<Argument> arguments;
    private ArgumentationStrategy strategy;
    
    public ArgumentativeAgent(String name, ArgumentationStrategy strategy) {
        this.name = name;
        this.tms = new SimpleTMS();
        this.arguments = new HashSet<>();
        this.strategy = strategy;
    }
    
    public void receiveArgument(Argument argument, ArgumentativeAgent sender) {
        System.out.println(name + " reçoit l'argument: " + argument.getContent() + 
            " de " + sender.getName());
        
        // Évaluer l'argument
        ArgumentEvaluation evaluation = evaluateArgument(argument);
        
        if (evaluation.isAccepted()) {
            acceptArgument(argument);
        } else {
            // Générer une contre-argumentation
            Argument counterArgument = strategy.generateCounterArgument(argument, this);
            if (counterArgument != null) {
                System.out.println(name + " contre-argumente: " + counterArgument.getContent());
                sender.receiveArgument(counterArgument, this);
            }
        }
    }
    
    private ArgumentEvaluation evaluateArgument(Argument argument) {
        // Créer un nœud temporaire dans le TMS
        String tempNode = "temp_" + argument.getId();
        tms.createNode(tempNode, NodeType.ASSUMPTION);
        tms.setAssumption(tempNode, true);
        
        // Ajouter les justifications de l'argument
        for (String premise : argument.getPremises()) {
            String premiseNode = "premise_" + premise.hashCode();
            tms.createNode(premiseNode, NodeType.ASSUMPTION);
            tms.setAssumption(premiseNode, true);
            
            tms.addJustification(tempNode, 
                Set.of(premiseNode), 
                Set.of(), 
                "Prémisse: " + premise);
        }
        
        // Propager et vérifier la cohérence
        tms.propagate();
        
        // Vérifier s'il y a des contradictions
        boolean hasContradictions = !tms.getContradictions().isEmpty();
        
        // Nettoyer les nœuds temporaires
        cleanupTemporaryNodes(tempNode, argument);
        
        return new ArgumentEvaluation(!hasContradictions, 
            hasContradictions ? "Cause des contradictions" : "Cohérent");
    }
    
    private void acceptArgument(Argument argument) {
        arguments.add(argument);
        
        // Intégrer définitivement dans le TMS
        String argNode = "arg_" + argument.getId();
        tms.createNode(argNode, NodeType.DERIVED);
        
        // Ajouter les justifications
        for (String premise : argument.getPremises()) {
            String premiseNode = "premise_" + premise.hashCode();
            if (!tms.getNodes().containsKey(premiseNode)) {
                tms.createNode(premiseNode, NodeType.ASSUMPTION);
                tms.setAssumption(premiseNode, true);
            }
            
            tms.addJustification(argNode, 
                Set.of(premiseNode), 
                Set.of(), 
                "Argument accepté: " + argument.getContent());
        }
        
        tms.propagate();
        System.out.println(name + " accepte l'argument: " + argument.getContent());
    }
    
    private void cleanupTemporaryNodes(String tempNode, Argument argument) {
        // Supprimer les nœuds temporaires du TMS
        // (implémentation simplifiée)
    }
    
    public void printBeliefs() {
        System.out.println("\n=== Croyances de " + name + " ===");
        tms.printStatus();
        
        System.out.println("\nArguments acceptés:");
        for (Argument arg : arguments) {
            System.out.println("  - " + arg.getContent());
        }
    }
    
    // Getters
    public String getName() { return name; }
    public Set<Argument> getArguments() { return arguments; }
    
    // Classes auxiliaires
    public static class Argument {
        private String id;
        private String content;
        private List<String> premises;
        private String conclusion;
        private double strength;
        
        public Argument(String id, String content, List<String> premises, String conclusion) {
            this.id = id;
            this.content = content;
            this.premises = premises;
            this.conclusion = conclusion;
            this.strength = 1.0;
        }
        
        // Getters...
        public String getId() { return id; }
        public String getContent() { return content; }
        public List<String> getPremises() { return premises; }
        public String getConclusion() { return conclusion; }
    }
    
    public static class ArgumentEvaluation {
        private boolean accepted;
        private String reason;
        
        public ArgumentEvaluation(boolean accepted, String reason) {
            this.accepted = accepted;
            this.reason = reason;
        }
        
        public boolean isAccepted() { return accepted; }
        public String getReason() { return reason; }
    }
    
    public interface ArgumentationStrategy {
        Argument generateCounterArgument(Argument targetArgument, ArgumentativeAgent agent);
    }
    
    public static class ConservativeStrategy implements ArgumentationStrategy {
        @Override
        public Argument generateCounterArgument(Argument targetArgument, ArgumentativeAgent agent) {
            // Stratégie conservatrice: contre-argumenter seulement si très sûr
            return null; // Implémentation simplifiée
        }
    }
    
    public static class AggressiveStrategy implements ArgumentationStrategy {
        @Override
        public Argument generateCounterArgument(Argument targetArgument, ArgumentativeAgent agent) {
            // Stratégie agressive: toujours contre-argumenter
            return new Argument("counter_" + targetArgument.getId(), 
                "Je ne suis pas d'accord avec: " + targetArgument.getContent(),
                Arrays.asList("Expérience personnelle", "Sources alternatives"),
                "L'argument est incorrect");
        }
    }
}
```

---

## 7. Défis et Limitations

### 7.1 Complexité Computationnelle

#### 7.1.1 Analyse de Complexité

**JTMS (Justification-based TMS)**
- **Propagation de labels**: O(n²) dans le pire cas
- **Détection de cycles**: O(n + m) avec DFS
- **Gestion des contradictions**: NP-difficile en général

**ATMS (Assumption-based TMS)**
- **Nombre d'environnements**: Exponentiel en nombre d'hypothèses
- **Filtrage des environnements**: Coûteux en temps et espace
- **Maintien de la minimalité**: Complexité élevée

**Révision AGM avec TweetyProject**
- **Énumération des ensembles de reste**: Exponentielle
- **Calcul des MUS**: NP-difficile
- **Mesures d'incohérence**: Varie selon la mesure (polynomial à exponentiel)

#### 7.1.2 Stratégies d'Optimisation

```java
public class TMSOptimizer {
    
    // Optimisation 1: Propagation incrémentale
    public static class IncrementalPropagator {
        private Set<String> changedNodes;
        private Map<String, Set<String>> dependencyGraph;
        
        public void markChanged(String nodeId) {
            changedNodes.add(nodeId);
        }
        
        public void propagateIncremental() {
            Queue<String> toProcess = new LinkedList<>(changedNodes);
            changedNodes.clear();
            
            while (!toProcess.isEmpty()) {
                String nodeId = toProcess.poll();
                
                // Propager seulement aux nœuds dépendants
                Set<String> dependents = dependencyGraph.get(nodeId);
                if (dependents != null) {
                    for (String dependent : dependents) {
                        if (updateNode(dependent)) {
                            toProcess.offer(dependent);
                        }
                    }
                }
            }
        }
        
        private boolean updateNode(String nodeId) {
            // Retourne true si le nœud a changé
            return false; // Implémentation simplifiée
        }
    }
    
    // Optimisation 2: Cache des résultats
    public static class ResultCache {
        private Map<String, Object> cache = new HashMap<>();
        private Map<String, Long> timestamps = new HashMap<>();
        
        public <T> T getCached(String key, Supplier<T> computation) {
            if (cache.containsKey(key)) {
                return (T) cache.get(key);
            }
            
            T result = computation.get();
            cache.put(key, result);
            timestamps.put(key, System.currentTimeMillis());
            
            return result;
        }
        
        public void invalidate(String key) {
            cache.remove(key);
            timestamps.remove(key);
        }
        
        public void cleanupOld(long maxAge) {
            long now = System.currentTimeMillis();
            Set<String> toRemove = new HashSet<>();
            
            for (Map.Entry<String, Long> entry : timestamps.entrySet()) {
                if (now - entry.getValue() > maxAge) {
                    toRemove.add(entry.getKey());
                }
            }
            
            for (String key : toRemove) {
                cache.remove(key);
                timestamps.remove(key);
            }
        }
    }
    
    // Optimisation 3: Parallélisation
    public static class ParallelTMS {
        private ExecutorService executor;
        private int threadCount;
        
        public ParallelTMS(int threadCount) {
            this.threadCount = threadCount;
            this.executor = Executors.newFixedThreadPool(threadCount);
        }
        
        public void parallelPropagate(List<String> independentNodes) {
            List<Future<Void>> futures = new ArrayList<>();
            
            // Diviser les nœuds en groupes indépendants
            List<List<String>> nodeGroups = partitionNodes(independentNodes);
            
            for (List<String> group : nodeGroups) {
                Future<Void> future = executor.submit(() -> {
                    for (String nodeId : group) {
                        processNode(nodeId);
                    }
                    return null;
                });
                futures.add(future);
            }
            
            // Attendre la completion
            for (Future<Void> future : futures) {
                try {
                    future.get();
                } catch (Exception e) {
                    System.err.println("Erreur dans le traitement parallèle: " + e);
                }
            }
        }
        
        private List<List<String>> partitionNodes(List<String> nodes) {
            List<List<String>> partitions = new ArrayList<>();
            int partitionSize = Math.max(1, nodes.size() / threadCount);
            
            for (int i = 0; i < nodes.size(); i += partitionSize) {
                int end = Math.min(i + partitionSize, nodes.size());
                partitions.add(nodes.subList(i, end));
            }
            
            return partitions;
        }
        
        private void processNode(String nodeId) {
            // Traitement d'un nœud
        }
        
        public void shutdown() {
            executor.shutdown();
        }
    }
}
```

### 7.2 Problème de l'Explosion Combinatoire

#### 7.2.1 Techniques de Réduction

```java
public class CombinatoricsReducer {
    
    // Technique 1: Élagage précoce
    public static class EarlyPruning {
        private Set<String> prunedBranches;
        
        public boolean shouldPrune(Set<String> currentAssumptions) {
            // Vérifier si cette combinaison a déjà été éliminée
            String signature = generateSignature(currentAssumptions);
            return prunedBranches.contains(signature);
        }
        
        public void addPrunedBranch(Set<String> assumptions) {
            String signature = generateSignature(assumptions);
            prunedBranches.add(signature);
        }
        
        private String generateSignature(Set<String> assumptions) {
            return assumptions.stream()
                .sorted()
                .collect(Collectors.joining(","));
        }
    }
    
    // Technique 2: Approximation heuristique
    public static class HeuristicApproximation {
        private Map<String, Double> assumptionPriorities;
        
        public Set<String> selectBestAssumptions(Set<String> candidates, int maxCount) {
            return candidates.stream()
                .sorted((a, b) -> Double.compare(
                    assumptionPriorities.getOrDefault(b, 0.0),
                    assumptionPriorities.getOrDefault(a, 0.0)))
                .limit(maxCount)
                .collect(Collectors.toSet());
        }
        
        public void updatePriorities(String assumption, double newPriority) {
            assumptionPriorities.put(assumption, newPriority);
        }
    }
    
    // Technique 3: Décomposition hiérarchique
    public static class HierarchicalDecomposition {
        private Map<String, Set<String>> clusters;
        private Map<String, String> nodeToCluster;
        
        public void createClusters(Set<String> nodes) {
            // Algorithme de clustering simple basé sur les dépendances
            // Grouper les nœuds fortement connectés
            
            for (String node : nodes) {
                String clusterId = findOrCreateCluster(node);
                clusters.computeIfAbsent(clusterId, k -> new HashSet<>()).add(node);
                nodeToCluster.put(node, clusterId);
            }
        }
        
        public void processClusterByCluster() {
            for (Map.Entry<String, Set<String>> cluster : clusters.entrySet()) {
                System.out.println("Traitement du cluster: " + cluster.getKey());
                processCluster(cluster.getValue());
            }
        }
        
        private String findOrCreateCluster(String node) {
            // Logique de clustering simplifiée
            return "cluster_" + (node.hashCode() % 5);
        }
        
        private void processCluster(Set<String> clusterNodes) {
            // Traitement optimisé pour un cluster
        }
    }
}
```

### 7.3 Gestion de l'Incertitude

#### 7.3.1 TMS Probabiliste

```java
public class ProbabilisticTMS {
    private Map<String, Double> nodeProbabilities;
    private Map<String, ProbabilisticJustification> justifications;
    
    public ProbabilisticTMS() {
        this.nodeProbabilities = new HashMap<>();
        this.justifications = new HashMap<>();
    }
    
    public void setNodeProbability(String nodeId, double probability) {
        nodeProbabilities.put(nodeId, Math.max(0.0, Math.min(1.0, probability)));
    }
    
    public void addProbabilisticJustification(String consequent, 
                                            Map<String, Double> antecedents,
                                            double strength) {
        ProbabilisticJustification just = new ProbabilisticJustification(
            consequent, antecedents, strength);
        justifications.put(consequent + "_" + justifications.size(), just);
    }
    
    public void propagateProbabilities() {
        boolean changed = true;
        int iterations = 0;
        final int maxIterations = 100;
        
        while (changed && iterations < maxIterations) {
            changed = false;
            iterations++;
            
            for (Probabil
isticJustification just : justifications.values()) {
                double oldProb = nodeProbabilities.getOrDefault(just.getConsequent(), 0.0);
                double newProb = computeProbability(just);
                
                if (Math.abs(newProb - oldProb) > 0.001) {
                    nodeProbabilities.put(just.getConsequent(), newProb);
                    changed = true;
                }
            }
        }
        
        if (iterations >= maxIterations) {
            System.out.println("⚠️ Convergence non atteinte après " + maxIterations + " itérations");
        }
    }
    
    private double computeProbability(ProbabilisticJustification just) {
        double product = just.getStrength();
        
        for (Map.Entry<String, Double> antecedent : just.getAntecedents().entrySet()) {
            String nodeId = antecedent.getKey();
            double weight = antecedent.getValue();
            double nodeProb = nodeProbabilities.getOrDefault(nodeId, 0.0);
            
            product *= Math.pow(nodeProb, weight);
        }
        
        return Math.max(0.0, Math.min(1.0, product));
    }
    
    public void printProbabilities() {
        System.out.println("\n=== Probabilités des Nœuds ===");
        for (Map.Entry<String, Double> entry : nodeProbabilities.entrySet()) {
            System.out.println(String.format("%s: %.3f", entry.getKey(), entry.getValue()));
        }
    }
    
    public static class ProbabilisticJustification {
        private String consequent;
        private Map<String, Double> antecedents; // nœud -> poids
        private double strength;
        
        public ProbabilisticJustification(String consequent, 
                                        Map<String, Double> antecedents, 
                                        double strength) {
            this.consequent = consequent;
            this.antecedents = antecedents;
            this.strength = strength;
        }
        
        // Getters...
        public String getConsequent() { return consequent; }
        public Map<String, Double> getAntecedents() { return antecedents; }
        public double getStrength() { return strength; }
    }
}
```

### 7.4 Stratégies d'Optimisation

#### 7.4.1 Optimisations Avancées

```java
public class AdvancedOptimizations {
    
    // Optimisation par indexation
    public static class IndexedTMS {
        private Map<String, Set<String>> supportIndex;    // qui supporte quoi
        private Map<String, Set<String>> dependentIndex;  // qui dépend de quoi
        private Map<String, Integer> priorityIndex;       // priorités des nœuds
        
        public void buildIndices(SimpleTMS tms) {
            supportIndex = new HashMap<>();
            dependentIndex = new HashMap<>();
            priorityIndex = new HashMap<>();
            
            // Construire les index de dépendances
            for (String nodeId : tms.getNodes().keySet()) {
                TMSNode node = tms.getNode(nodeId);
                
                for (TMSJustification just : node.getJustifications()) {
                    for (TMSNode antecedent : just.getInList()) {
                        supportIndex.computeIfAbsent(antecedent.getName(), k -> new HashSet<>())
                                   .add(nodeId);
                        dependentIndex.computeIfAbsent(nodeId, k -> new HashSet<>())
                                     .add(antecedent.getName());
                    }
                }
                
                // Calculer la priorité basée sur le nombre de dépendants
                int dependentCount = supportIndex.getOrDefault(nodeId, Collections.emptySet()).size();
                priorityIndex.put(nodeId, dependentCount);
            }
        }
        
        public List<String> getProcessingOrder() {
            return priorityIndex.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
        }
    }
    
    // Optimisation par lazy evaluation
    public static class LazyTMS {
        private Map<String, Supplier<NodeStatus>> lazyComputations;
        private Map<String, NodeStatus> cachedResults;
        private Set<String> computing; // Détection de cycles
        
        public LazyTMS() {
            this.lazyComputations = new HashMap<>();
            this.cachedResults = new HashMap<>();
            this.computing = new HashSet<>();
        }
        
        public NodeStatus getStatus(String nodeId) {
            if (cachedResults.containsKey(nodeId)) {
                return cachedResults.get(nodeId);
            }
            
            if (computing.contains(nodeId)) {
                // Cycle détecté
                return NodeStatus.UNKNOWN;
            }
            
            computing.add(nodeId);
            
            try {
                Supplier<NodeStatus> computation = lazyComputations.get(nodeId);
                if (computation != null) {
                    NodeStatus result = computation.get();
                    cachedResults.put(nodeId, result);
                    return result;
                }
                
                return NodeStatus.UNKNOWN;
            } finally {
                computing.remove(nodeId);
            }
        }
        
        public void invalidateCache(String nodeId) {
            cachedResults.remove(nodeId);
            
            // Invalider récursivement les dépendants
            // (implémentation simplifiée)
        }
    }
}
```

---

## 8. Ressources et Références

### 8.1 Bibliographie Fondamentale

#### 8.1.1 Ouvrages de Référence

1. **Doyle, J. (1979)**  
   *A Truth Maintenance System*  
   Artificial Intelligence, 12(3), 231-272  
   - Article fondateur des TMS
   - Introduction du JTMS original
   - Concepts de base de la maintenance de vérité

2. **de Kleer, J. (1986)**  
   *An Assumption-based TMS*  
   Artificial Intelligence, 28(2), 127-162  
   - Introduction de l'ATMS
   - Gestion explicite des hypothèses
   - Environnements multiples

3. **Alchourrón, C. E., Gärdenfors, P., & Makinson, D. (1985)**  
   *On the Logic of Theory Change: Partial Meet Contraction and Revision Functions*  
   Journal of Symbolic Logic, 50(2), 510-530  
   - Postulats AGM fondamentaux
   - Théorie formelle de la révision de croyances

4. **Reiter, R. (1980)**  
   *A Logic for Default Reasoning*  
   Artificial Intelligence, 13(1-2), 81-132  
   - Logique de défaut
   - Raisonnement non-monotone
   - Extensions de défaut

#### 8.1.2 Articles Récents

5. **Thimm, M. (2016)**  
   *Stream-based inconsistency measurement*  
   International Journal of Approximate Reasoning, 68, 68-87  
   - Mesures d'incohérence modernes
   - Algorithmes efficaces
   - Applications pratiques

6. **Booth, R., & Meyer, T. (2006)**  
   *Admissible and restrained revision*  
   Journal of Artificial Intelligence Research, 26, 127-151  
   - Révision contrainte
   - Postulats étendus
   - Applications aux TMS

### 8.2 Ressources TweetyProject

#### 8.2.1 Documentation Officielle

- **Site principal :** [https://tweetyproject.org/](https://tweetyproject.org/)
- **Documentation API :** [https://tweetyproject.org/doc/](https://tweetyproject.org/doc/)
- **Code source :** [https://github.com/TweetyProjectTeam/TweetyProject](https://github.com/TweetyProjectTeam/TweetyProject)

#### 8.2.2 Modules Pertinents

1. **org.tweetyproject.beliefdynamics**
   - Classes principales pour la révision de croyances
   - Opérateurs AGM (Levi, kernel, etc.)
   - Exemples : [`CrMasExample.java`](https://github.com/TweetyProjectTeam/TweetyProject/blob/main/org-tweetyproject-beliefdynamics/src/main/java/org/tweetyproject/beliefdynamics/examples/CrMasExample.java)

2. **org.tweetyproject.beliefdynamics.mas**
   - Révision multi-agents
   - Gestion de la crédibilité
   - Opérateurs spécialisés

3. **org.tweetyproject.logics.pl.analysis**
   - Mesures d'incohérence
   - Énumération MUS
   - Analyses de cohérence

4. **org.tweetyproject.arg.dung**
   - Frameworks d'argumentation abstraite
   - Sémantiques argumentatives
   - Intégration avec TMS

#### 8.2.3 Configuration Maven

```xml
<dependencies>
    <!-- Core TweetyProject -->
    <dependency>
        <groupId>org.tweetyproject</groupId>
        <artifactId>tweetyproject-commons</artifactId>
        <version>1.19</version>
    </dependency>
    
    <!-- Belief Dynamics -->
    <dependency>
        <groupId>org.tweetyproject</groupId>
        <artifactId>tweetyproject-beliefdynamics</artifactId>
        <version>1.19</version>
    </dependency>
    
    <!-- Propositional Logic -->
    <dependency>
        <groupId>org.tweetyproject</groupId>
        <artifactId>tweetyproject-logics-pl</artifactId>
        <version>1.19</version>
    </dependency>
    
    <!-- Argumentation -->
    <dependency>
        <groupId>org.tweetyproject</groupId>
        <artifactId>tweetyproject-arg-dung</artifactId>
        <version>1.19</version>
    </dependency>
    
    <!-- Agents -->
    <dependency>
        <groupId>org.tweetyproject</groupId>
        <artifactId>tweetyproject-agents</artifactId>
        <version>1.19</version>
    </dependency>
</dependencies>
```

### 8.3 Outils et Plateformes

#### 8.3.1 Environnements de Développement

1. **IntelliJ IDEA**
   - Plugin TweetyProject (si disponible)
   - Support Maven intégré
   - Débogage avancé

2. **Eclipse**
   - Support Maven/Gradle
   - Plugins de visualisation
   - Intégration Git

#### 8.3.2 Outils de Visualisation

1. **Graphviz**
   ```java
   public class GraphvizExporter {
       public void exportTMS(SimpleTMS tms, String filename) {
           StringBuilder dot = new StringBuilder();
           dot.append("digraph TMS {\n");
           dot.append("  rankdir=TB;\n");
           
           // Nœuds
           for (String nodeId : tms.getNodes().keySet()) {
               TMSNode node = tms.getNode(nodeId);
               String color = getNodeColor(node.getStatus());
               String shape = getNodeShape(node.getType());
               
               dot.append(String.format("  \"%s\" [color=%s, shape=%s];\n", 
                   nodeId, color, shape));
           }
           
           // Arêtes
           for (TMSJustification just : tms.getJustifications()) {
               String consequent = just.getConsequent().getName();
               
               for (TMSNode antecedent : just.getInList()) {
                   dot.append(String.format("  \"%s\" -> \"%s\" [color=blue];\n", 
                       antecedent.getName(), consequent));
               }
               
               for (TMSNode inhibitor : just.getOutList()) {
                   dot.append(String.format("  \"%s\" -> \"%s\" [color=red, style=dashed];\n", 
                       inhibitor.getName(), consequent));
               }
           }
           
           dot.append("}\n");
           
           // Écrire le fichier
           try (FileWriter writer = new FileWriter(filename)) {
               writer.write(dot.toString());
           } catch (IOException e) {
               System.err.println("Erreur d'écriture: " + e.getMessage());
           }
       }
       
       private String getNodeColor(NodeStatus status) {
           switch (status) {
               case IN: return "green";
               case OUT: return "red";
               default: return "gray";
           }
       }
       
       private String getNodeShape(NodeType type) {
           switch (type) {
               case ASSUMPTION: return "box";
               case CONTRADICTION: return "diamond";
               default: return "ellipse";
           }
       }
   }
   ```

### 8.4 Exercices Pratiques

#### 8.4.1 Exercice 1 : TMS de Base

**Objectif :** Implémenter un TMS simple pour le problème de Tweety.

**Énoncé :**
1. Créer un TMS avec les nœuds : `bird(tweety)`, `flies(tweety)`, `penguin(tweety)`, `abnormal(tweety)`
2. Ajouter les règles :
   - `bird(X) ∧ ¬abnormal(X) → flies(X)`
   - `penguin(X) → abnormal(X)`
   - `penguin(X) → ¬flies(X)`
3. Tester différents scénarios d'hypothèses

**Code de départ :**
```java
public class TweetyTMSExercise {
    public static void main(String[] args) {
        SimpleTMS tms = new SimpleTMS();
        
        // TODO: Créer les nœuds
        // TODO: Ajouter les justifications
        // TODO: Tester les scénarios
    }
}
```

#### 8.4.2 Exercice 2 : Intégration TweetyProject

**Objectif :** Utiliser TweetyProject pour la révision de croyances.

**Énoncé :**
1. Créer une base de croyances avec des formules contradictoires
2. Implémenter différents opérateurs de révision
3. Comparer les résultats
4. Mesurer les performances

**Métriques à calculer :**
- Temps de révision
- Taille de la base révisée
- Mesures d'incohérence avant/après

#### 8.4.3 Exercice 3 : Système Expert avec TMS

**Objectif :** Développer un système expert médical simple.

**Domaine :** Diagnostic de maladies respiratoires

**Règles exemple :**
- `fièvre ∧ toux → grippe (0.7)`
- `toux ∧ essoufflement → asthme (0.8)`
- `grippe ∧ asthme → complications (0.9)`

**Fonctionnalités requises :**
- Ajout de symptômes
- Inférence automatique
- Explication des conclusions
- Gestion de l'incertitude

#### 8.4.4 Exercice 4 : Visualiseur Interactif

**Objectif :** Créer une interface graphique pour visualiser un TMS.

**Fonctionnalités :**
- Affichage du graphe de dépendances
- Modification interactive des hypothèses
- Animation de la propagation
- Export des résultats

### 8.5 Projets Avancés

#### 8.5.1 Projet 1 : TMS Distribué

**Description :** Implémenter un TMS distribué sur plusieurs machines.

**Défis techniques :**
- Synchronisation des états
- Gestion des pannes
- Optimisation des communications
- Cohérence globale

**Technologies suggérées :**
- Apache Kafka pour la messagerie
- Redis pour le cache distribué
- Docker pour le déploiement

#### 8.5.2 Projet 2 : TMS pour IoT

**Description :** Adapter les TMS pour les réseaux de capteurs IoT.

**Contraintes :**
- Ressources limitées
- Communications intermittentes
- Données incertaines
- Temps réel

**Applications :**
- Surveillance environnementale
- Maisons intelligentes
- Véhicules autonomes

#### 8.5.3 Projet 3 : TMS Quantique

**Description :** Explorer l'utilisation de l'informatique quantique pour les TMS.

**Aspects théoriques :**
- Superposition d'états de croyance
- Intrication entre propositions
- Algorithmes quantiques pour la révision

### 8.6 Évaluation et Critères de Réussite

#### 8.6.1 Critères d'Évaluation

**Compréhension Théorique (30%)**
- Maîtrise des concepts TMS (JTMS, ATMS, LTMS)
- Compréhension des postulats AGM
- Connaissance des logiques non-monotones

**Implémentation Technique (40%)**
- Qualité du code Java/TweetyProject
- Respect des bonnes pratiques
- Fonctionnalité et robustesse
- Optimisations implémentées

**Innovation et Créativité (20%)**
- Originalité des solutions
- Intégration de concepts avancés
- Amélioration des algorithmes existants

**Documentation et Présentation (10%)**
- Clarté de la documentation
- Qualité des diagrammes
- Reproductibilité des résultats

#### 8.6.2 Livrables Attendus

1. **Code Source Complet**
   - Implémentation TMS de base
   - Intégration TweetyProject
   - Tests unitaires et d'intégration
   - **Documentation technique détaillée :** Une documentation claire et complète est cruciale. Cela inclut la documentation du code (docstrings, commentaires pertinents), une description de l'API de chaque agent (comment l'utiliser, les paramètres, les retours), et potentiellement des exemples d'utilisation ou un petit guide de démarrage. Cette documentation facilitera grandement la mise en œuvre, l'utilisation et la maintenance des agents développés.

2. **Rapport Technique (30-40 pages)**
   - Analyse théorique (8-10 pages)
   - Description de l'implémentation (15-20 pages)
   - Évaluation expérimentale (8-10 pages)
   - Conclusion et perspectives (3-5 pages)

3. **Présentation Orale**
   - Durée : 25 minutes + 10 minutes de questions
   - Démonstration du système
   - Discussion des résultats
   - Perspectives d'amélioration

#### 8.6.3 Planning Suggéré

**Semaines 1-3 : Fondements Théoriques**
- Étude de la littérature TMS
- Compréhension des postulats AGM
- Familiarisation avec TweetyProject

**Semaines 4-6 : Implémentation de Base**
- TMS simple en Java
- Intégration TweetyProject
- Tests sur exemples classiques

**Semaines 7-10 : Développement Avancé**
- Optimisations et améliorations
- Interface de visualisation
- Cas d'usage complexes

**Semaines 11-12 : Évaluation et Documentation**
- Tests de performance
- Rédaction du rapport
- Préparation de la présentation

---

## Conclusion

Les Systèmes de Maintenance de la Vérité représentent un domaine fondamental de l'intelligence artificielle, offrant des solutions élégantes aux problèmes de cohérence et de révision de croyances. Ce guide vous a fourni :

1. **Les fondements théoriques** nécessaires pour comprendre les différentes architectures TMS
2. **Les outils pratiques** avec TweetyProject pour implémenter des solutions robustes
3. **Les techniques avancées** pour optimiser et étendre les systèmes de base
4. **Les applications concrètes** dans des domaines variés

L'intégration avec TweetyProject ouvre de nombreuses possibilités :
- Utilisation des opérateurs de révision AGM
- Mesures d'incohérence sophistiquées
- Intégration avec les frameworks d'argumentation
- Support pour les systèmes multi-agents

Les défis futurs incluent :
- Passage à l'échelle pour de grandes bases de connaissances
- Gestion de l'incertitude et des probabilités
- Intégration avec l'apprentissage automatique
- Applications en temps réel et systèmes distribués

Nous espérons que ce guide vous donnera les clés pour maîtriser les TMS et contribuer aux développements futurs de ce domaine passionnant.

---

**Dernière mise à jour :** Janvier 2025  
**Version :** 1.0  
**Auteurs :** Guide pédagogique pour julien.zebic, thomas.leguere