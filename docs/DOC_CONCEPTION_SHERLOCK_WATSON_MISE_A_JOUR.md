# Document de Conception Mis √† Jour : Workflow Agentique "Sherlock & Watson"

## √âtat d'Impl√©mentation Actuel (Janvier 2025)

### R√©sum√© Ex√©cutif
Le syst√®me Sherlock/Watson a √©t√© largement impl√©ment√© avec succ√®s, d√©passant m√™me les objectifs initiaux de la conception. L'architecture pr√©vue fonctionne et a √©t√© √©tendue avec des capacit√©s de logique formelle avanc√©es.

## Section 1: Analyse Comparative - Conception vs Impl√©mentation

### ‚úÖ **Fonctionnalit√©s Compl√®tement Impl√©ment√©es**

#### 1.1 Agents Principaux
- **SherlockEnqueteAgent** : ‚úÖ Impl√©ment√© avec ChatCompletionAgent
  - Utilise les outils `faire_suggestion()`, `propose_final_solution()`, `get_case_description()`
  - Prompt sp√©cialis√© pour strat√©gie Cluedo avec suggestion/r√©futation
  - Int√©gration compl√®te avec StateManagerPlugin

- **WatsonLogicAssistant** : ‚úÖ Impl√©ment√© avec ChatCompletionAgent
  - Outils logiques via `validate_formula()`, `execute_query()`
  - TweetyBridge op√©rationnel pour logique propositionnelle
  - Normalisation des formules et gestion des constantes

#### 1.2 Hi√©rarchie d'√âtats
- **BaseWorkflowState** : ‚úÖ Classe de base avec gestion tasks/results/logs
- **EnquetePoliciereState** : ‚úÖ Extension avec belief_sets, query_log, hypoth√®ses
- **EnqueteCluedoState** : ‚úÖ Sp√©cialisation avec g√©n√©ration solution al√©atoire, indices initiaux

#### 1.3 Orchestration
- **CluedoOrchestrator** : ‚úÖ Impl√©ment√© avec AgentGroupChat
  - `CluedoTerminationStrategy` personnalis√©e
  - Gestion des tours et validation des solutions
  - Logging avanc√© avec filtres

#### 1.4 Infrastructure
- **StateManagerPlugin** : ‚úÖ Plugin d'exposition des m√©thodes d'√©tat
- **TweetyBridge** : ‚úÖ Int√©gration JVM pour logique propositionnelle
- **Logging** : ‚úÖ Syst√®me de filtres pour tra√ßabilit√©

### üöß **Extensions R√©alis√©es Au-Del√† de la Conception**

#### 1.5 √âtats Avanc√©s (Nouveaut√©)
- **EinsteinsRiddleState** : ‚ûï Logique formelle complexe pour √©nigme √† 5 maisons
  - Contraintes complexes n√©cessitant formalisation obligatoire
  - Validation progression logique (minimum 10 clauses + 5 requ√™tes)
  - G√©n√©ration d'indices logiques complexes

- **LogiqueBridgeState** : ‚ûï Probl√®mes de travers√©e avec exploration d'√©tats
  - Cannibales/Missionnaires avec 5+5 personnes
  - Validation d'√©tats et g√©n√©ration d'actions possibles

#### 1.6 Capacit√©s Logiques Avanc√©es
- **Normalisation de formules** : ‚ûï Conversion automatique pour parser Tweety
- **Gestion des constantes** : ‚ûï Support des domaines ferm√©s
- **Validation syntaxique** : ‚ûï V√©rification BNF stricte

### ‚ùå **Gaps Identifi√©s**

#### 1.7 Documentation Manquante
- **analyse_orchestrations_sherlock_watson.md** : ‚ùå Fichier mentionn√© mais absent
- **Tests d'int√©gration** : ‚ùå Pas de tests sp√©cifiques Sherlock/Watson
- **Guide utilisateur** : ‚ùå Documentation d'utilisation manquante

#### 1.8 Fonctionnalit√©s Non Impl√©ment√©es
- **Agent Oracle/Interrogateur** : ‚ùå Extension future non r√©alis√©e ‚Üí üéØ **NOUVELLE PRIORIT√â PHASE 1**
- **Interface utilisateur** : ‚ùå UI de visualisation des enqu√™tes
- **Orchestrateur logique complexe** : ‚ùå D√©di√© √† EinsteinsRiddleState
- **Persistance avanc√©e** : ‚ùå Sauvegarde/chargement des √©tats

#### 1.9 Optimisations Manquantes
- **Strat√©gies d'orchestration adaptatives** : ‚ùå S√©lection dynamique bas√©e sur l'√©tat
- **Gestion d'incertitude** : ‚ùå Scores de confiance dans la logique
- **Apprentissage** : ‚ùå Am√©lioration des strat√©gies par historique

## Section 2: Roadmap d'√âvolution

### üéØ **Phase 1: Consolidation et Stabilisation (Court terme - 1-2 mois)**

#### 2.1 Documentation Critique
- [ ] **Cr√©er analyse_orchestrations_sherlock_watson.md**
  - Analyse d√©taill√©e des patterns d'orchestration
  - M√©triques de performance des agents
  - Comparaison efficacit√© Cluedo vs Einstein

- [ ] **Tests d'int√©gration complets**
  - Tests end-to-end pour workflow Cluedo
  - Tests pour EinsteinsRiddleState
  - Validation des interactions Sherlock-Watson

- [ ] **Guide utilisateur**
  - Documentation d'installation et configuration
  - Exemples d'utilisation pour chaque type d'enqu√™te
  - Troubleshooting des probl√®mes courants

#### 2.2 Corrections Techniques
- [ ] **Orchestrateur pour logique complexe**
  - `LogiqueComplexeOrchestrator` d√©di√© √† EinsteinsRiddleState
  - Strat√©gies de terminaison adapt√©es aux probl√®mes formels
  - Gestion des timeouts pour requ√™tes complexes

- [ ] **Am√©lioration gestion d'erreurs**
  - Validation robuste des entr√©es utilisateur
  - Recovery automatique en cas d'√©chec JVM
  - Messages d'erreur plus informatifs

### üöÄ **Phase 2: Extensions Fonctionnelles (Moyen terme - 2-4 mois)**

#### 2.3 Agent Oracle et Interrogateur - **ARCHITECTURE √âTENDUE**

##### 2.3.1 Agent Oracle de Base
- [ ] **Impl√©mentation OracleBaseAgent**
  - **Classe de base** : Nouvelle classe fondamentale `OracleBaseAgent`
  - **Interface dataset** : Acc√®s contr√¥l√© aux donn√©es selon permissions
  - **Syst√®me ACL** : Access Control List pour autoriser requ√™tes par agent
  - **R√®gles d'interrogation** : Framework de validation des requ√™tes autoris√©es
  - **API standardis√©e** : Interface r√©utilisable pour diff√©rents types de datasets

##### 2.3.2 Agent Interrogateur Sp√©cialis√© - **NOUVEAU PATTERN D'H√âRITAGE**
- [ ] **Impl√©mentation [Nom]InterrogatorAgent**
  - **H√©ritage** : `[Nom]InterrogatorAgent(OracleBaseAgent)`
  - **Pattern coh√©rent** : Watson (logic) ‚Üí Sherlock (enqu√™te) ‚Üí **[Nouveau]** (donn√©es)
  - **Sp√©cialisation Sherlock/Watson** : D√©tient dataset sp√©cifique aux enqu√™tes
  - **Donn√©es Cluedo** : Poss√®de cartes distribu√©es, solution secr√®te, indices
  - **Workflow int√©gr√©** : Extension naturelle de l'√©quipe existante

##### 2.3.3 Propositions de Nomenclature
- [ ] **Option 1 : "MoriartyInterrogatorAgent"**
  - R√©f√©rence litt√©raire forte (n√©mesis de Sherlock)
  - √âvoque le d√©tenteur de secrets/informations cach√©es
  - Coh√©rent avec l'univers Holmes
  
- [ ] **Option 2 : "LestradeDateInterrogatorAgent"**
  - Inspecteur Lestrade = autorit√© polici√®re d√©tenant dossiers
  - √âvoque l'acc√®s officiel aux donn√©es d'enqu√™te
  
- [ ] **Option 3 : "BakerStreetOracleAgent"**
  - R√©f√©rence au 221B Baker Street (adresse Holmes)
  - Oracle = d√©tenteur de v√©rit√©s et proph√©ties
  - Fusion des concepts Oracle + univers Sherlock

##### 2.3.4 Int√©gration Architecture Existante
- [ ] **Extension EnqueteCluedoState**
  - Nouvelles m√©thodes pour gestion cartes distribu√©es
  - Tracking des r√©v√©lations progressives d'information
  - Logging sp√©cialis√© Oracle-Sherlock interactions
  
- [ ] **Nouveau workflow Cluedo √©tendu :**
```
Sherlock ‚Üî Watson ‚Üî [Agent Interrogateur]
    ‚Üì         ‚Üì              ‚Üì
Suggestions  Logique    Dataset/V√©rifications
    ‚Üì         ‚Üì              ‚Üì
  Analyse   Validation   R√©v√©lation contr√¥l√©e
```

#### 2.4 Interface Utilisateur
- [ ] **Dashboard web de visualisation**
  - Vue en temps r√©el de l'√©tat des enqu√™tes
  - Graphiques de progression des d√©ductions
  - Interface pour interventions manuelles

- [ ] **Mode interactif**
  - Permettre √† un humain de jouer le r√¥le de Sherlock
  - Interface pour saisir des suggestions/hypoth√®ses
  - Feedback en temps r√©el de Watson

#### 2.5 Nouveaux Types d'Enqu√™tes
- [ ] **Enqu√™tes polici√®res textuelles**
  - Parser de t√©moignages et indices textuels
  - Extraction d'entit√©s et relations
  - G√©n√©ration automatique de contraintes logiques

- [ ] **√ânigmes math√©matiques**
  - Support des probl√®mes arithm√©tiques complexes
  - Int√©gration avec solveurs math√©matiques
  - Validation de preuves formelles

### ‚ö° **Phase 3: Optimisations et Nouvelle G√©n√©ration (Long terme - 4-6 mois)**

#### 2.6 Orchestration Intelligente
- [ ] **Strat√©gies adaptatives**
  - S√©lection dynamique Sherlock/Watson selon complexit√©
  - M√©triques de performance en temps r√©el
  - Auto-ajustement des param√®tres d'orchestration

- [ ] **Orchestration par √©v√©nements**
  - R√©action √† des changements critiques d'√©tat
  - Notifications push pour d√©couvertes importantes
  - Orchestration asynchrone pour t√¢ches longues

#### 2.7 Capacit√©s Logiques Avanc√©es
- [ ] **Logiques expressives**
  - Support logique modale pour modalit√©s (possible/n√©cessaire)
  - Logique temporelle pour s√©quences d'√©v√©nements
  - Logique non-monotone pour r√©vision de croyances

- [ ] **Gestion d'incertitude**
  - Probabilit√©s dans les d√©ductions
  - Fusion d'informations contradictoires
  - Quantification de la confiance

#### 2.8 Apprentissage et Adaptation
- [ ] **M√©moire des performances**
  - Historique des strat√©gies efficaces
  - Patterns de succ√®s/√©chec par type de probl√®me
  - Optimisation automatique des prompts

- [ ] **Am√©lioration continue**
  - Fine-tuning des agents selon les retours
  - √âvolution des strat√©gies de d√©duction
  - Adaptation aux nouveaux types de probl√®mes

### üî¨ **Phase 4: Recherche et Innovation (6+ mois)**

#### 2.9 Capacit√©s √âmergentes
- [ ] **Raisonnement causal**
  - Inf√©rence de relations cause-effet
  - Mod√®les causaux pour enqu√™tes complexes
  - Validation d'hypoth√®ses causales

- [ ] **M√©ta-raisonnement**
  - Raisonnement sur le processus de raisonnement
  - Auto-√©valuation des strat√©gies de d√©duction
  - Optimisation m√©ta-cognitive

#### 2.10 Int√©grations Avanc√©es
- [ ] **IA g√©n√©rative**
  - G√©n√©ration automatique de sc√©narios d'enqu√™te
  - Cr√©ation de nouvelles √©nigmes logiques
  - Narration automatique des d√©ductions

- [ ] **Syst√®mes multi-agents**
  - √âquipes d'enqu√™teurs sp√©cialis√©s
  - N√©gociation entre agents avec opinions divergentes
  - Consensus distribu√© sur les conclusions

## Section 3: Actions Prioritaires Imm√©diates

### üéØ **Top 7 des Actions Concr√®tes (Prochaines 2 semaines)**

1. **üÜï PRIORIT√â #1 : Agents Oracle et Interrogateur**
   - Impl√©menter `OracleBaseAgent` avec syst√®me ACL
   - Cr√©er `MoriartyInterrogatorAgent` sp√©cialis√© Cluedo
   - D√©velopper `DatasetAccessManager` pour permissions
   - Extension `CluedoOracleState` avec cartes distribu√©es

2. **üÜï PRIORIT√â #2 : Workflow Cluedo avec Oracle**
   - Impl√©menter `CluedoExtendedOrchestrator` (3 agents)
   - Strat√©gie de s√©lection Sherlock ‚Üí Watson ‚Üí Moriarty
   - Tests d'int√©gration workflow Oracle complet
   - Validation r√©v√©lations progressives d'information

3. **Cr√©er la documentation d'analyse manquante**
   - Fichier `docs/analyse_orchestrations_sherlock_watson.md` ‚úÖ **TERMIN√â**
   - Mise √† jour avec nouveaux agents Oracle
   - M√©triques performance workflow 3 agents

4. **Impl√©menter LogiqueComplexeOrchestrator**
   - Copie adapt√©e de CluedoOrchestrator pour EinsteinsRiddleState
   - Strat√©gie de terminaison bas√©e sur progression logique
   - Tests d'int√©gration avec l'√©nigme d'Einstein

5. **Cr√©er suite de tests d'int√©gration**
   - Tests end-to-end workflow Cluedo 2-agents (existant)
   - **üÜï Tests end-to-end workflow Cluedo 3-agents (Oracle)**
   - Tests de robustesse pour cas d'erreur
   - Validation des interactions multi-tours

6. **Am√©liorer gestion d'erreurs**
   - Messages d'erreur plus informatifs pour utilisateurs
   - Recovery automatique des √©checs de TweetyBridge
   - Validation stricte des formats de solution

7. **√âcrire guide utilisateur √©tendu**
   - Installation step-by-step
   - **üÜï Exemples d'utilisation avec agents Oracle**
   - Configuration recommand√©e pour diff√©rents cas d'usage

### üìä **M√©triques de Succ√®s**

#### Quantitatives
- Temps moyen de r√©solution d'un Cluedo : < 10 tours
- Taux de succ√®s Einstein's Riddle avec logique formelle : > 90%
- Couverture de tests : > 85% pour modules Sherlock/Watson
- Temps de response moyen par interaction : < 5 secondes

#### Qualitatives
- Documentation compl√®te et √† jour
- Code maintenable et extensible
- UX fluide pour nouveaux utilisateurs
## Section 5: **EXTENSION CONCEPTION - AGENTS ORACLE ET INTERROGATEUR**

### 5.1 Vue d'Ensemble de l'Extension

Cette section d√©taille l'int√©gration des nouveaux agents Oracle et Interrogateur dans l'√©cosyst√®me Sherlock/Watson, cr√©ant une architecture √©tendue pour la gestion des datasets et l'interrogation contr√¥l√©e.

#### 5.1.1 Objectifs de Conception
- **Gestion centralis√©e des datasets** : Agent Oracle comme point d'acc√®s unique aux donn√©es
- **Contr√¥le d'acc√®s granulaire** : Syst√®me de permissions par agent et par type de requ√™te
- **Extension naturelle de l'√©quipe** : Int√©gration seamless avec Sherlock/Watson existant
- **Variante Cluedo enrichie** : Simulation multi-joueurs avec r√©v√©lations progressives

#### 5.1.2 Architecture Conceptuelle √âtendue

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    √âCOSYST√àME SHERLOCK/WATSON √âTENDU            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   SHERLOCK  ‚îÇ    ‚îÇ   WATSON    ‚îÇ    ‚îÇ  [AGENT ORACLE]      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ    ‚îÇ             ‚îÇ    ‚îÇ                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Enqu√™te   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ ‚Ä¢ Logique   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ ‚Ä¢ Dataset Access     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Leadership‚îÇ    ‚îÇ ‚Ä¢ Validation‚îÇ    ‚îÇ ‚Ä¢ Permissions        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Synth√®se  ‚îÇ    ‚îÇ ‚Ä¢ D√©duction ‚îÇ    ‚îÇ ‚Ä¢ R√©v√©lations        ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ         ‚ñ≤                    ‚ñ≤                     ‚ñ≤            ‚îÇ
‚îÇ         ‚îÇ                    ‚îÇ                     ‚îÇ            ‚îÇ
‚îÇ         ‚ñº                    ‚ñº                     ‚ñº            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ           ORCHESTRATEUR √âTENDU (3 AGENTS)                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Strat√©gie cyclique Sherlock‚ÜíWatson‚ÜíOracle               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Terminaison sur solution compl√®te + valid√©e             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Gestion des r√©v√©lations progressives                    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                ‚ñ≤                               ‚îÇ
‚îÇ                                ‚îÇ                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ              √âTAT PARTAG√â √âTENDU                          ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ CluedoOracleState (extension EnqueteCluedoState)       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Cartes distribu√©es + permissions par agent            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Historique r√©v√©lations + tracking acc√®s               ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.2 Conception Agent Oracle de Base

#### 5.2.1 Classe `OracleBaseAgent`

```python
class OracleBaseAgent(ChatCompletionAgent):
    """
    Agent de base pour la gestion d'acc√®s aux datasets avec contr√¥le de permissions.
    
    Responsabilit√©s:
    - D√©tient l'acc√®s exclusif √† un dataset sp√©cifique
    - G√®re les permissions d'acc√®s par agent et par type de requ√™te
    - Valide et filtre les requ√™tes selon les r√®gles d√©finies
    - Log toutes les interactions pour auditabilit√©
    """
    
    def __init__(self, dataset_manager: DatasetAccessManager, 
                 permission_rules: Dict[str, Any]):
        self.dataset_manager = dataset_manager
        self.permission_rules = permission_rules
        self.access_log = []
        self.revealed_information = set()
        
        # Outils expos√©s
        self.tools = [
            "validate_query_permission",
            "execute_authorized_query", 
            "get_available_query_types",
            "reveal_information_controlled"
        ]
```

#### 5.2.2 Syst√®me de Permissions ACL

```python
class PermissionRule:
    """R√®gle de permission pour l'acc√®s aux donn√©es"""
    
    def __init__(self, agent_name: str, query_types: List[str], 
                 conditions: Dict[str, Any] = None):
        self.agent_name = agent_name
        self.allowed_query_types = query_types  
        self.conditions = conditions or {}
        self.max_daily_queries = conditions.get("max_daily", 50)
        self.forbidden_data_fields = conditions.get("forbidden_fields", [])

# Exemple de configuration Cluedo
CLUEDO_PERMISSION_RULES = {
    "SherlockEnqueteAgent": PermissionRule(
        agent_name="SherlockEnqueteAgent",
        query_types=["card_inquiry", "suggestion_validation", "clue_request"],
        conditions={
            "max_daily": 30,
            "forbidden_fields": ["solution_secrete"],
            "reveal_policy": "progressive"
        }
    ),
    "WatsonLogicAssistant": PermissionRule(
        agent_name="WatsonLogicAssistant", 
        query_types=["logical_validation", "constraint_check"],
        conditions={
            "max_daily": 100,
            "logical_queries_only": True
        }
    )
}
```

#### 5.2.3 Interface DatasetAccessManager

```python
class DatasetAccessManager:
    """Gestionnaire d'acc√®s centralis√© aux datasets"""
    
    def __init__(self, dataset: Any, permission_manager: PermissionManager):
        self.dataset = dataset
        self.permission_manager = permission_manager
        self.query_cache = LRUCache(maxsize=1000)
        
    def execute_query(self, agent_name: str, query_type: str, 
                     query_params: Dict[str, Any]) -> QueryResult:
        """
        Ex√©cute une requ√™te apr√®s validation des permissions
        
        Args:
            agent_name: Nom de l'agent demandeur
            query_type: Type de requ√™te (card_inquiry, suggestion_validation, etc.)
            query_params: Param√®tres sp√©cifiques √† la requ√™te
            
        Returns:
            QueryResult avec donn√©es filtr√©es selon permissions
            
        Raises:
            PermissionDeniedError: Si l'agent n'a pas les permissions
            InvalidQueryError: Si les param√®tres sont invalides
        """
        
        # Validation des permissions
        if not self.permission_manager.is_authorized(agent_name, query_type):
            raise PermissionDeniedError(f"{agent_name} not authorized for {query_type}")
            
        # Ex√©cution s√©curis√©e de la requ√™te
        return self._execute_filtered_query(agent_name, query_type, query_params)
```

### 5.3 Conception Agent Interrogateur Sp√©cialis√©

#### 5.3.1 Nomenclature - Option Recommand√©e : **"MoriartyInterrogatorAgent"**

**Justification du choix :**
- **Coh√©rence litt√©raire** : Professor Moriarty = n√©mesis intellectuel de Sherlock Holmes
- **Symbolisme appropri√©** : D√©tenteur de secrets et d'informations cach√©es
- **Pattern d'h√©ritage coh√©rent** : 
  - `Watson` (Logic) ‚Üí Support technique
  - `Sherlock` (Enqu√™te) ‚Üí Leadership investigation  
  - `Moriarty` (Data) ‚Üí D√©tenteur des secrets/datasets
- **Dynamique narrative** : Tension cr√©ative entre enqu√™teur et d√©tenteur d'information

#### 5.3.2 Classe `MoriartyInterrogatorAgent`

```python
class MoriartyInterrogatorAgent(OracleBaseAgent):
    """
    Agent sp√©cialis√© pour les enqu√™tes Sherlock/Watson.
    H√©rite d'OracleBaseAgent pour la gestion des datasets d'enqu√™te.
    
    Sp√©cialisations:
    - Dataset Cluedo (cartes, solution secr√®te, r√©v√©lations)
    - Simulation comportement autres joueurs
    - R√©v√©lations progressives selon strat√©gie de jeu
    - Validation des suggestions selon r√®gles Cluedo
    """
    
    def __init__(self, cluedo_dataset: CluedoDataset, game_strategy: str = "balanced"):
        super().__init__(
            dataset_manager=CluedoDatasetManager(cluedo_dataset),
            permission_rules=CLUEDO_PERMISSION_RULES
        )
        
        self.game_strategy = game_strategy  # "cooperative", "competitive", "balanced"
        self.cards_revealed = {}  # Track des cartes r√©v√©l√©es par agent
        self.suggestion_history = []
        
        # Outils sp√©cialis√©s Cluedo
        self.specialized_tools = [
            "validate_cluedo_suggestion",
            "reveal_card_if_owned", 
            "provide_game_clue",
            "simulate_other_player_response"
        ]

    def validate_cluedo_suggestion(self, suggestion: Dict[str, str], 
                                  requesting_agent: str) -> ValidationResult:
        """
        Valide une suggestion Cluedo selon les r√®gles du jeu
        
        Args:
            suggestion: {"suspect": "X", "arme": "Y", "lieu": "Z"}
            requesting_agent: Agent qui fait la suggestion
            
        Returns:
            ValidationResult avec cartes r√©v√©l√©es si Moriarty peut r√©futer
        """
        
        # V√©rification permissions
        if not self._can_respond_to_suggestion(requesting_agent):
            return ValidationResult(authorized=False, reason="Permission denied")
            
        # Logique de jeu Cluedo
        owned_cards = self._get_owned_cards()
        refuting_cards = []
        
        for element_type, element_value in suggestion.items():
            if element_value in owned_cards:
                refuting_cards.append({
                    "type": element_type,
                    "value": element_value,
                    "revealed_to": requesting_agent
                })
                
        # Strat√©gie de r√©v√©lation selon game_strategy
        cards_to_reveal = self._apply_revelation_strategy(refuting_cards)
        
        return ValidationResult(
            can_refute=len(cards_to_reveal) > 0,
            revealed_cards=cards_to_reveal,
            suggestion_valid=len(cards_to_reveal) == 0
        )
```

#### 5.3.3 CluedoDataset - Extension de Donn√©es

```python
class CluedoDataset:
    """Dataset sp√©cialis√© pour jeux Cluedo avec r√©v√©lations contr√¥l√©es"""
    
    def __init__(self, solution_secrete: Dict[str, str], 
                 cartes_distribuees: Dict[str, List[str]]):
        self.solution_secrete = solution_secrete  # La vraie solution
        self.cartes_distribuees = cartes_distribuees  # Cartes par "joueur"
        self.revelations_historique = []
        self.access_restrictions = {
            "solution_secrete": ["orchestrator_only"],  # Jamais accessible aux agents
            "cartes_moriarty": ["MoriartyInterrogatorAgent"],
            "cartes_autres_joueurs": ["simulation_only"]
        }
        
    def get_moriarty_cards(self) -> List[str]:
        """Retourne les cartes que poss√®de Moriarty"""
        return self.cartes_distribuees.get("Moriarty", [])
        
    def can_refute_suggestion(self, suggestion: Dict[str, str]) -> List[str]:
        """V√©rifie quelles cartes Moriarty peut r√©v√©ler pour r√©futer"""
        moriarty_cards = self.get_moriarty_cards()
        refutable = []
        
        for element in suggestion.values():
            if element in moriarty_cards:
                refutable.append(element)
                
        return refutable
        
    def reveal_card(self, card: str, to_agent: str, reason: str):
        """Enregistre une r√©v√©lation de carte"""
        revelation = {
            "timestamp": datetime.now(),
            "card_revealed": card,
            "revealed_to": to_agent,
            "revealed_by": "MoriartyInterrogatorAgent", 
            "reason": reason
        }
        self.revelations_historique.append(revelation)
```

### 5.4 √âtat √âtendu - CluedoOracleState

#### 5.4.1 Extension d'EnqueteCluedoState

```python
class CluedoOracleState(EnqueteCluedoState):
    """
    Extension d'EnqueteCluedoState pour supporter le workflow √† 3 agents
    avec agent Oracle (Moriarty) g√©rant les r√©v√©lations de cartes.
    """
    
    def __init__(self, nom_enquete_cluedo: str, elements_jeu_cluedo: dict,
                 description_cas: str, initial_context: dict, 
                 cartes_distribuees: Dict[str, List[str]] = None,
                 workflow_id: str = None):
        super().__init__(nom_enquete_cluedo, elements_jeu_cluedo, 
                        description_cas, initial_context, workflow_id)
        
        # Extensions Oracle
        self.cartes_distribuees = cartes_distribuees or self._distribute_cards()
        self.cluedo_dataset = CluedoDataset(
            solution_secrete=self.solution_secrete_cluedo,
            cartes_distribuees=self.cartes_distribuees
        )
        self.moriarty_agent_id = f"moriarty_agent_{self.workflow_id}"
        self.revelations_log = []
        self.agent_permissions = self._initialize_permissions()
        
        # Tracking interactions 3-agents
        self.interaction_pattern = []  # ["Sherlock", "Watson", "Moriarty", ...]
        self.oracle_queries_count = 0
        self.suggestions_validated_by_oracle = []

    def _distribute_cards(self) -> Dict[str, List[str]]:
        """
        Distribue les cartes entre Moriarty et joueurs simul√©s
        en excluant la solution secr√®te
        """
        all_elements = (
            self.elements_jeu_cluedo["suspects"] + 
            self.elements_jeu_cluedo["armes"] + 
            self.elements_jeu_cluedo["lieux"]
        )
        
        # Exclure la solution secr√®te  
        available_cards = [
            card for card in all_elements 
            if card not in self.solution_secrete_cluedo.values()
        ]
        
        # Distribution simul√©e (ici simplifi√©e)
        moriarty_cards = random.sample(available_cards, len(available_cards) // 3)
        autres_joueurs = list(set(available_cards) - set(moriarty_cards))
        
        return {
            "Moriarty": moriarty_cards,
            "AutresJoueurs": autres_joueurs
        }
        
    def _initialize_permissions(self) -> Dict[str, Any]:
        """Configure les permissions d'acc√®s pour chaque agent"""
        return {
            "SherlockEnqueteAgent": {
                "can_query_oracle": True,
                "max_oracle_queries_per_turn": 3,
                "allowed_query_types": ["suggestion_validation", "clue_request"]
            },
            "WatsonLogicAssistant": {
                "can_query_oracle": True, 
                "max_oracle_queries_per_turn": 1,
                "allowed_query_types": ["logical_validation"]
            },
            "MoriartyInterrogatorAgent": {
                "can_access_dataset": True,
                "revelation_strategy": "balanced",
                "can_simulate_other_players": True
            }
        }

    # M√©thodes Oracle sp√©cialis√©es
    def query_oracle(self, agent_name: str, query_type: str, 
                    query_params: Dict[str, Any]) -> OracleResponse:
        """Interface pour interroger l'agent Oracle"""
        
        # V√©rification permissions
        if not self._agent_can_query_oracle(agent_name, query_type):
            return OracleResponse(authorized=False, reason="Permission denied")
            
        # D√©l√©gation √† Moriarty via dataset
        response = self.cluedo_dataset.process_query(agent_name, query_type, query_params)
        
        # Logging de l'interaction
        self.revelations_log.append({
            "timestamp": datetime.now(),
            "querying_agent": agent_name,
            "query_type": query_type,
            "oracle_response": response,
            "turn_number": len(self.interaction_pattern)
        })
        
        self.oracle_queries_count += 1
        return response
```

### 5.5 Orchestration √âtendue - CluedoExtendedOrchestrator

#### 5.5.1 Workflow √† 3 Agents

```python
class CluedoExtendedOrchestrator:
    """
    Orchestrateur pour workflow Cluedo √©tendu avec 3 agents:
    Sherlock ‚Üí Watson ‚Üí Moriarty ‚Üí cycle
    """
    
    def __init__(self, sherlock_agent: SherlockEnqueteAgent,
                 watson_agent: WatsonLogicAssistant,
                 moriarty_agent: MoriartyInterrogatorAgent,
                 state: CluedoOracleState):
        
        self.agents = {
            "sherlock": sherlock_agent,
            "watson": watson_agent, 
            "moriarty": moriarty_agent
        }
        self.state = state
        self.turn_order = ["sherlock", "watson", "moriarty"]
        self.current_turn_index = 0
        self.max_total_turns = 15  # 5 cycles complets
        
        # Strat√©gies sp√©cialis√©es
        self.selection_strategy = CyclicSelectionStrategy(self.turn_order)
        self.termination_strategy = OracleTerminationStrategy()

    def execute_workflow(self) -> WorkflowResult:
        """
        Ex√©cute le workflow complet avec les 3 agents
        
        Pattern d'interaction:
        1. Sherlock: Analyse, hypoth√®se ou suggestion
        2. Watson: Validation logique, formalisation  
        3. Moriarty: R√©v√©lation contr√¥l√©e, validation suggestion
        4. R√©p√©tition jusqu'√† solution ou timeout
        """
        
        workflow_result = WorkflowResult()
        turn_count = 0
        
        while not self.termination_strategy.should_terminate(self.state) and \
              turn_count < self.max_total_turns:
            
            # S√©lection agent pour ce tour
            current_agent_key = self.selection_strategy.select_next_agent(
                self.state, turn_count
            )
            current_agent = self.agents[current_agent_key]
            
            # Ex√©cution tour agent
            agent_result = self._execute_agent_turn(current_agent, current_agent_key)
            
            # Mise √† jour √©tat
            self.state.interaction_pattern.append(current_agent_key)
            workflow_result.add_turn_result(agent_result)
            
            turn_count += 1
            
        # √âvaluation finale
        final_solution = self.state.get_proposed_solution()
        solution_correcte = self._validate_final_solution(final_solution)
        
        workflow_result.finalize(
            solution_found=solution_correcte,
            total_turns=turn_count,
            oracle_interactions=self.state.oracle_queries_count
        )
        
        return workflow_result

class CyclicSelectionStrategy:
    """Strat√©gie de s√©lection cyclique adapt√©e au workflow Oracle"""
    
    def __init__(self, turn_order: List[str]):
        self.turn_order = turn_order
        self.current_index = 0
        
    def select_next_agent(self, state: CluedoOracleState, turn_count: int) -> str:
        """
        S√©lection cyclique avec adaptations contextuelles
        
        Adaptations possibles:
        - Si Sherlock fait une suggestion ‚Üí priorit√© √† Moriarty
        - Si Watson d√©tecte contradiction ‚Üí retour √† Sherlock
        - Si Moriarty r√©v√®le information cruciale ‚Üí priorit√© √† Watson
        """
        
        # S√©lection de base (cyclique)
        selected_agent = self.turn_order[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.turn_order)
        
        # Adaptations contextuelles (optionelles pour Phase 1)
        # selected_agent = self._apply_contextual_adaptations(selected_agent, state)
        
        return selected_agent

class OracleTerminationStrategy:
    """Strat√©gie de terminaison adapt√©e au workflow avec Oracle"""
    
    def should_terminate(self, state: CluedoOracleState) -> bool:
        """
        Crit√®res de terminaison pour workflow Oracle:
        1. Solution correcte propos√©e ET valid√©e par Oracle
        2. Toutes les cartes r√©v√©l√©es (solution par √©limination)
        3. Consensus des 3 agents sur une solution
        4. Timeout (max_turns atteint)
        """
        
        # Crit√®re 1: Solution propos√©e et correcte
        if state.is_solution_proposed:
            return self._validate_solution_with_oracle(state)
            
        # Crit√®re 2: Solution par √©limination compl√®te
        if self._all_non_solution_cards_revealed(state):
            return True
            
        # Crit√®re 3: Consensus entre agents (futur)
        # if self._consensus_reached(state):
        #     return True
            
        return False
```

### 5.6 Roadmap d'Impl√©mentation Agents Oracle

#### 5.6.1 Phase 1 - Impl√©mentation de Base (2-3 semaines)

**Semaine 1:**
- [ ] Cr√©ation `OracleBaseAgent` avec syst√®me ACL de base
- [ ] Impl√©mentation `DatasetAccessManager` et `PermissionManager`
- [ ] D√©veloppement `CluedoDataset` avec cartes distribu√©es
- [ ] Tests unitaires des composants de base

**Semaine 2:**
- [ ] Cr√©ation `MoriartyInterrogatorAgent` h√©ritant d'OracleBaseAgent
- [ ] Extension `CluedoOracleState` avec support 3 agents
- [ ] Impl√©mentation logique de r√©v√©lation de cartes
- [ ] Tests d'int√©gration Agent Oracle + √âtat

**Semaine 3:**
- [ ] D√©veloppement `CluedoExtendedOrchestrator` avec strat√©gies cycliques
- [ ] Int√©gration compl√®te des 3 agents dans workflow
- [ ] Tests end-to-end workflow Cluedo √©tendu
- [ ] Documentation et exemples d'utilisation

#### 5.6.2 Phase 1.5 - Optimisations (1 semaine)

- [ ] Performance tuning des requ√™tes Oracle
- [ ] Am√©lioration strat√©gies de r√©v√©lation (cooperative/competitive/balanced)
- [ ] Logging et m√©triques sp√©cialis√©s workflow 3-agents
- [ ] Tests de robustesse et cas d'erreur

#### 5.6.3 Phase 2 - Extensions Avanc√©es (Phase 2 globale)

- [ ] Support multi-datasets (diff√©rents types d'enqu√™tes)
- [ ] Agent Oracle g√©n√©rique pour probl√®mes non-Cluedo
- [ ] Strat√©gies d'orchestration adaptatives (ML-driven selection)
- [ ] Interface utilisateur pour visualisation interactions Oracle

### 5.7 M√©triques de Succ√®s Agents Oracle

#### 5.7.1 KPIs Techniques

**Performance :**
- Temps de r√©ponse Oracle : < 2 secondes par requ√™te
- D√©bit maximal : 50 requ√™tes/minute sans d√©gradation
- Taux de succ√®s validation permissions : 100%
- Memory footprint : < 100MB par instance Oracle

**Efficacit√© Workflow :**
- R√©duction tours de jeu : 20-30% vs workflow 2-agents
- Taux de succ√®s solutions : > 90% (am√©lioration par r√©v√©lations Oracle)
- Diversit√© strat√©gies : 3 modes (cooperative/competitive/balanced) op√©rationnels

#### 5.7.2 KPIs Fonctionnels  

**Qualit√© des R√©v√©lations :**
- Pertinence r√©v√©lations : Score subjectif > 8/10
- Progression vers solution : Mesurable √† chaque r√©v√©lation Oracle
- √âquilibre gameplay : Pas de dominance excessive d'un agent

**Robustesse :**
- Gestion cas d'erreur : 100% des sc√©narios d'√©chec g√©r√©s gracieusement
- Coh√©rence donn√©es : Z√©ro contradiction dans les r√©v√©lations
- Auditabilit√© : 100% des interactions Oracle trac√©es et v√©rifiables

**Prochaine r√©vision recommand√©e** : Mars 2025, apr√®s l'impl√©mentation des Agents Oracle Phase 1.
- Robustesse face aux cas d'erreur

## Section 4: Architecture √âvolu√©e Recommand√©e

### 4.1 Structure Modulaire Propos√©e

```
argumentation_analysis/
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pm/sherlock_enquete_agent.py              ‚úÖ Existant
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logic/watson_logic_assistant.py           ‚úÖ Existant
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ oracle/                                   üéØ **NOUVEAU MODULE**
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ oracle_base_agent.py                  ‚ùå √Ä cr√©er (Phase 1)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ moriarty_interrogator_agent.py        ‚ùå √Ä cr√©er (Phase 1)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ dataset_access_manager.py             ‚ùå √Ä cr√©er (Phase 1)
‚îÇ   ‚îî‚îÄ‚îÄ specialized/                                   ‚ûï Phase 2
‚îÇ       ‚îú‚îÄ‚îÄ forensic_analyst_agent.py
‚îÇ       ‚îî‚îÄ‚îÄ witness_interviewer_agent.py
‚îú‚îÄ‚îÄ orchestration/
‚îÇ   ‚îú‚îÄ‚îÄ cluedo_orchestrator.py                        ‚úÖ Existant
‚îÇ   ‚îú‚îÄ‚îÄ cluedo_extended_orchestrator.py               üéØ **VARIANTE ORACLE** (Phase 1)
‚îÇ   ‚îú‚îÄ‚îÄ logique_complexe_orchestrator.py              ‚ùå √Ä cr√©er (Phase 1)
‚îÇ   ‚îî‚îÄ‚îÄ adaptive_orchestrator.py                      ‚ûï Phase 3
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ enquete_states.py                             ‚úÖ Existant
‚îÇ   ‚îú‚îÄ‚îÄ cluedo_oracle_state.py                        üéØ **DATASET EXTENSION** (Phase 1)
‚îÇ   ‚îú‚îÄ‚îÄ logique_complexe_states.py                    ‚úÖ Existant
‚îÇ   ‚îî‚îÄ‚îÄ forensic_states.py                            ‚ûï Phase 2
‚îú‚îÄ‚îÄ datasets/                                          üéØ **NOUVEAU MODULE**
‚îÇ   ‚îú‚îÄ‚îÄ dataset_interface.py                          ‚ùå √Ä cr√©er (Phase 1)
‚îÇ   ‚îú‚îÄ‚îÄ cluedo_dataset.py                             ‚ùå √Ä cr√©er (Phase 1)
‚îÇ   ‚îî‚îÄ‚îÄ permissions_manager.py                        ‚ùå √Ä cr√©er (Phase 1)
‚îú‚îÄ‚îÄ ui/                                                ‚ùå Phase 2
‚îÇ   ‚îú‚îÄ‚îÄ web_dashboard/
‚îÇ   ‚îî‚îÄ‚îÄ cli_interface/
‚îî‚îÄ‚îÄ evaluation/                                        ‚ùå Phase 1
    ‚îú‚îÄ‚îÄ metrics_collector.py
    ‚îî‚îÄ‚îÄ performance_analyzer.py
```

### 4.2 Patterns d'√âvolution

#### Pattern State-Strategy-Observer
- **States** : Encapsulent la logique m√©tier des enqu√™tes
- **Strategies** : Orchestration adaptative selon le contexte
- **Observers** : Monitoring et m√©triques en temps r√©el

#### Pattern Plugin Architecture
- Agents comme plugins interchangeables
- Extension facile pour nouveaux types d'enqu√™tes
- Configuration dynamique des capacit√©s

## Conclusion

Le syst√®me Sherlock/Watson a d√©pass√© les attentes initiales avec une impl√©mentation robuste et des extensions innovantes. Les prochaines √©tapes se concentrent sur la consolidation, l'am√©lioration de l'exp√©rience utilisateur, et l'exploration de capacit√©s de raisonnement avanc√©es.

La roadmap propos√©e √©quilibre stabilisation technique et innovation, avec des jalons clairs et des m√©triques de succ√®s mesurables. L'architecture modulaire permet une √©volution progressive sans disruption des fonctionnalit√©s existantes.

**Prochaine r√©vision recommand√©e** : Mars 2025, apr√®s l'impl√©mentation de la Phase 1.