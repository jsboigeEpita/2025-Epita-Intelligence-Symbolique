#!/usr/bin/env python3
"""
Test unitaire pour diagnostiquer le probl√®me JPype dans DependencyValidator
du unified_production_analyzer.py

Ce test valide que JPype1 est correctement install√© et peut √™tre import√©
par le DependencyValidator, reproduisant l'erreur exacte.
"""

import pytest
import sys
from pathlib import Path
from unittest.mock import patch, MagicMock

# Ajouter le r√©pertoire racine au sys.path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

class TestJPypeDependencyValidator:
    """Tests pour diagnostiquer le probl√®me JPype dans DependencyValidator"""
    
    def test_jpype_import_direct(self):
        """Test 1: V√©rifier que jpype peut √™tre import√© directement"""
        try:
            import jpype
            assert hasattr(jpype, '__version__'), "jpype n'a pas d'attribut __version__"
            assert hasattr(jpype, 'isJVMStarted'), "jpype n'a pas de m√©thode isJVMStarted"
            assert hasattr(jpype, 'getDefaultJVMPath'), "jpype n'a pas de m√©thode getDefaultJVMPath"
            print(f"‚úÖ JPype version: {jpype.__version__}")
        except ImportError as e:
            pytest.fail(f"Impossible d'importer jpype: {e}")
    
    def test_jpype_import_alternative(self):
        """Test 2: V√©rifier l'import jpype alternatif"""
        try:
            import jpype
            assert hasattr(jpype, '__version__'), "jpype n'a pas d'attribut __version__"
            print(f"‚úÖ JPype version (import direct): {jpype.__version__}")
        except ImportError:
            print("‚ÑπÔ∏è  Import jpype direct non disponible (normal)")
    
    def test_dependency_validator_jpype_check(self):
        """Test 3: Reproduire exactement le code du DependencyValidator"""
        
        # Simuler la m√©thode _validate_tweety_dependencies
        errors = []
        
        try:
            # Code exact de la ligne 490 du unified_production_analyzer.py
            import jpype
            
            # V√©rifications suppl√©mentaires comme dans le validateur
            if not jpype.isJVMStarted():
                try:
                    # On ne d√©marre pas r√©ellement la JVM dans le test
                    print("‚ÑπÔ∏è  JVM non d√©marr√©e (normal en test)")
                except Exception as e:
                    errors.append(f"Impossible de d√©marrer la JVM pour TweetyProject: {e}")
            
        except ImportError:
            errors.append("jpype non install√© - requis pour TweetyProject")
        
        # Assertion: pas d'erreurs d'import
        assert not any("jpype non install√©" in err for err in errors), \
            f"Erreur d'import jpype d√©tect√©e: {errors}"
    
    def test_unified_production_analyzer_import(self):
        """Test 4: V√©rifier que le module unified_production_analyzer peut √™tre import√©"""
        try:
            from argumentation_analysis.rhetorical_analysis.unified_production_analyzer import DependencyValidator
            print("‚úÖ DependencyValidator import√© avec succ√®s")
        except ImportError as e:
            pytest.fail(f"Impossible d'importer DependencyValidator: {e}")
    
    @patch('jpype.isJVMStarted', return_value=False)
    @patch('jpype.startJVM')
    def test_dependency_validator_instance(self, mock_start_jvm, mock_is_started):
        """Test 5: Tester une instance r√©elle de DependencyValidator avec mocks"""
        
        # Configuration mock pour √©viter les d√©pendances lourdes
        from argumentation_analysis.rhetorical_analysis.unified_production_analyzer import (
            DependencyValidator, 
            UnifiedProductionConfig
        )
        
        # Configuration minimale
        config = UnifiedProductionConfig()
        
        # Cr√©er le validateur
        validator = DependencyValidator(config)
        
        # Tester la validation tweety (method priv√©e, on teste via validate_all)
        try:
            # Cette m√©thode est async, on teste juste l'instantiation
            assert validator is not None
            assert hasattr(validator, '_validate_tweety_dependencies')
            print("‚úÖ DependencyValidator instanci√© avec succ√®s")
        except Exception as e:
            pytest.fail(f"Erreur lors de l'instantiation du DependencyValidator: {e}")
    
    def test_environment_diagnostics(self):
        """Test 6: Diagnostics d√©taill√©s de l'environnement"""
        import pkg_resources
        
        # Rechercher tous les packages JPype
        jpype_packages = [
            pkg for pkg in pkg_resources.working_set 
            if 'jpype' in pkg.project_name.lower()
        ]
        
        print(f"\nüì¶ Packages JPype trouv√©s: {len(jpype_packages)}")
        for pkg in jpype_packages:
            print(f"   - {pkg.project_name} {pkg.version} ({pkg.location})")
        
        # V√©rifier l'environnement Python
        print(f"\nüêç Environnement Python:")
        print(f"   - Ex√©cutable: {sys.executable}")
        print(f"   - Version: {sys.version}")
        print(f"   - Pr√©fixe: {sys.prefix}")
        
        # Au moins un package JPype doit √™tre pr√©sent
        assert len(jpype_packages) > 0, "Aucun package JPype trouv√© dans l'environnement"
    
    def test_auto_env_activation(self):
        """Test 7: V√©rifier que auto_env fonctionne correctement"""
        try:
            from project_core.core_from_scripts.auto_env import ensure_env
            # Ne pas appeler ensure_env() dans les tests pour √©viter les effets de bord
            print("‚úÖ Module auto_env import√© avec succ√®s")
        except ImportError as e:
            pytest.fail(f"Impossible d'importer auto_env: {e}")

if __name__ == "__main__":
    # Permettre l'ex√©cution directe du test pour d√©bogage
    pytest.main([__file__, "-v", "-s"])