import pytest
import argparse
import yaml
from unittest.mock import patch, MagicMock
from pathlib import Path

# On s'assure que le chemin est correct pour importer l'orchestrateur
import sys

sys.path.insert(0, ".")

from argumentation_analysis.webapp.orchestrator import UnifiedWebOrchestrator


# This patch will apply to all tests in this module
@pytest.fixture(autouse=True)
def mock_signal_handlers():
    with patch(
        "argumentation_analysis.webapp.orchestrator.UnifiedWebOrchestrator._setup_signal_handlers"
    ) as mock_setup:
        yield mock_setup


def test_load_valid_config(webapp_config, test_config_path):
    """
    Tests loading a valid configuration file.
    """
    mock_args = MagicMock(spec=argparse.Namespace)
    mock_args.config = str(test_config_path)
    mock_args.log_level = "INFO"
    mock_args.headless = True
    mock_args.visible = False
    mock_args.timeout = 20
    mock_args.no_trace = False

    with open(test_config_path, "w", encoding="utf-8") as f:
        yaml.dump(webapp_config, f)

    # Patch _load_config to ensure it uses the fixture's content for this test
    with patch(
        "argumentation_analysis.webapp.orchestrator.UnifiedWebOrchestrator._load_config",
        return_value=webapp_config,
    ):
        orchestrator = UnifiedWebOrchestrator(args=mock_args)
        assert orchestrator.config is not None


@patch(
    "argumentation_analysis.webapp.orchestrator.CENTRAL_PORT_MANAGER_AVAILABLE", False
)
def test_create_default_config_if_not_exists(tmp_path):
    """
    Tests that a default configuration is created if the file does not exist.
    The mock ensures we test the fallback mechanism.
    """
    config_path = tmp_path / "default_config.yml"
    assert not config_path.exists()

    mock_args = MagicMock(spec=argparse.Namespace)
    mock_args.config = str(config_path)
    mock_args.log_level = "INFO"
    mock_args.headless = True
    mock_args.visible = False
    mock_args.timeout = 20
    mock_args.no_trace = False
    orchestrator = UnifiedWebOrchestrator(args=mock_args)

    assert config_path.exists()

    with open(config_path, "r") as f:
        config = yaml.safe_load(f)

    assert config is not None
    assert config["webapp"]["name"] == "Argumentation Analysis Web App"
    assert config["backend"]["start_port"] == 5003  # Default port without manager


@patch(
    "argumentation_analysis.webapp.orchestrator.CENTRAL_PORT_MANAGER_AVAILABLE", True
)
def test_create_default_config_with_port_manager(tmp_path, mocker):
    """
    Tests default config creation when the central port manager is available.
    """
    # Mock the port manager and its functions
    mock_port_manager = MagicMock()
    mock_port_manager.get_port.side_effect = lambda x: 8100 if x == "backend" else 3100
    mock_port_manager.config = {"ports": {"backend": {"fallback": [8101, 8102]}}}

    mocker.patch(
        "argumentation_analysis.webapp.orchestrator.get_port_manager",
        return_value=mock_port_manager,
    )
    mocker.patch("argumentation_analysis.webapp.orchestrator.set_environment_variables")

    config_path = tmp_path / "default_config_with_pm.yml"
    mock_args = MagicMock(spec=argparse.Namespace)
    mock_args.config = str(config_path)
    mock_args.log_level = "INFO"
    mock_args.headless = True
    mock_args.visible = False
    mock_args.timeout = 20
    mock_args.no_trace = False
    orchestrator = UnifiedWebOrchestrator(args=mock_args)

    with open(config_path, "r") as f:
        config = yaml.safe_load(f)

    assert config["backend"]["start_port"] == 8100
    assert config["frontend"]["port"] == 3100
    assert config["backend"]["fallback_ports"] == [8101, 8102]


@patch(
    "argumentation_analysis.webapp.orchestrator.CENTRAL_PORT_MANAGER_AVAILABLE", False
)
def test_handle_invalid_yaml_config(tmp_path, capsys):
    """
    Tests that the orchestrator handles a corrupted YAML file by loading default config.
    """
    config_path = tmp_path / "invalid_config.yml"
    config_path.write_text("backend: { port: 8000\\nfrontend: [")  # Invalid YAML

    mock_args = MagicMock(spec=argparse.Namespace)
    mock_args.config = str(config_path)
    mock_args.log_level = "INFO"
    mock_args.headless = True
    mock_args.visible = False
    mock_args.timeout = 20
    mock_args.no_trace = False
    orchestrator = UnifiedWebOrchestrator(args=mock_args)

    # Should fall back to default config without port manager
    assert orchestrator.config["backend"]["start_port"] == 5003

    captured = capsys.readouterr()
    # In some CI environments, stderr might be captured instead of stdout
    log_output = captured.out + captured.err
    # Rendre l'assertion plus souple en cherchant les parties cl√©s du message
    assert "Erreur lors du chargement de la configuration" in log_output
    assert str(config_path) in log_output
