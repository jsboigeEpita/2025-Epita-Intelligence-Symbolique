# -*- coding: utf-8 -*-
"""
Script de correction automatique des erreurs F821 - Missing Imports
Mission D-CI-06 Phase 1A.2 - Batch 1

Ce script corrige automatiquement les imports manquants les plus fr√©quents
d√©tect√©s dans l'analyse F821.

Corrections appliqu√©es :
- logger ‚Üí import logging + logger = logging.getLogger(__name__)
- MagicMock, Mock, patch ‚Üí from unittest.mock import ...
- Path ‚Üí from pathlib import Path
- json ‚Üí import json
- datetime ‚Üí from datetime import datetime

Usage:
    python scripts/fix_f821_missing_imports.py [--dry-run] [--file FILE]

Options:
    --dry-run   : Afficher les changements sans les appliquer
    --file FILE : Corriger un fichier sp√©cifique (sinon traite tous)
"""
import argparse
import json as json_module
import os
import re
from pathlib import Path
from typing import List, Dict, Set, Tuple


# Patterns d'imports √† ajouter par nom non d√©fini
IMPORT_FIXES = {
    'logger': {
        'import_line': 'import logging',
        'setup_line': 'logger = logging.getLogger(__name__)',
        'confidence': 'high'
    },
    'MagicMock': {
        'import_line': 'from unittest.mock import MagicMock',
        'setup_line': None,
        'confidence': 'high'
    },
    'Mock': {
        'import_line': 'from unittest.mock import Mock',
        'setup_line': None,
        'confidence': 'high'
    },
    'patch': {
        'import_line': 'from unittest.mock import patch',
        'setup_line': None,
        'confidence': 'high'
    },
    'Path': {
        'import_line': 'from pathlib import Path',
        'setup_line': None,
        'confidence': 'high'
    },
    'json': {
        'import_line': 'import json',
        'setup_line': None,
        'confidence': 'high'
    },
    'datetime': {
        'import_line': 'from datetime import datetime',
        'setup_line': None,
        'confidence': 'medium'
    },
    'isawaitable': {
        'import_line': 'from inspect import isawaitable',
        'setup_line': None,
        'confidence': 'high'
    },
}


def load_f821_analysis(analysis_path: str) -> Dict:
    """Charge l'analyse F821 depuis le fichier JSON."""
    with open(analysis_path, 'r', encoding='utf-8') as f:
        return json_module.load(f)


def get_files_to_fix(analysis_data: Dict, target_file: str = None) -> Dict[str, List[Dict]]:
    """
    Retourne un dictionnaire {file_path: [errors]} pour les erreurs corrigeables.
    
    Args:
        analysis_data: Donn√©es d'analyse F821
        target_file: Fichier sp√©cifique √† traiter (optionnel)
        
    Returns:
        Dict mapping file paths to list of correctable errors
    """
    files_to_fix = {}
    
    # Extraire les erreurs missing_imports
    missing_imports = analysis_data.get('by_category', {}).get('missing_imports', {}).get('errors', [])
    
    for error in missing_imports:
        file_path = error['file'].replace('.\\', '').replace('\\', '/')
        
        # Si un fichier cible est sp√©cifi√©, filtrer
        if target_file and file_path != target_file:
            continue
        
        undefined_name = error.get('undefined_name')
        
        # V√©rifier si on peut corriger automatiquement
        if undefined_name in IMPORT_FIXES:
            if file_path not in files_to_fix:
                files_to_fix[file_path] = []
            files_to_fix[file_path].append(error)
    
    return files_to_fix


def file_has_import(content: str, import_line: str) -> bool:
    """V√©rifie si un import existe d√©j√† dans le fichier."""
    # Normaliser les espaces
    import_normalized = ' '.join(import_line.split())
    
    for line in content.split('\n'):
        line_normalized = ' '.join(line.strip().split())
        if import_normalized in line_normalized:
            return True
    
    return False


def find_import_insertion_point(lines: List[str]) -> int:
    """
    Trouve le point d'insertion optimal pour un nouvel import.
    
    Retourne l'index de ligne o√π ins√©rer (apr√®s les imports existants).
    """
    last_import_idx = -1
    in_docstring = False
    docstring_delimiter = None
    
    for idx, line in enumerate(lines):
        stripped = line.strip()
        
        # G√©rer docstrings multi-lignes
        if stripped.startswith('"""') or stripped.startswith("'''"):
            if not in_docstring:
                in_docstring = True
                docstring_delimiter = stripped[:3]
                if stripped.endswith(docstring_delimiter) and len(stripped) > 3:
                    in_docstring = False
            elif stripped.endswith(docstring_delimiter):
                in_docstring = False
            continue
        
        if in_docstring:
            continue
        
        # Ignorer commentaires et lignes vides
        if not stripped or stripped.startswith('#'):
            continue
        
        # D√©tection d'imports
        if stripped.startswith('import ') or stripped.startswith('from '):
            last_import_idx = idx
    
    # Ins√©rer apr√®s le dernier import, ou au d√©but si aucun import
    return last_import_idx + 1 if last_import_idx >= 0 else 0


def add_import_to_file(file_path: str, import_line: str, setup_line: str = None, dry_run: bool = False) -> bool:
    """
    Ajoute un import √† un fichier Python.
    
    Args:
        file_path: Chemin du fichier
        import_line: Ligne d'import √† ajouter
        setup_line: Ligne de setup optionnelle (ex: logger = ...)
        dry_run: Si True, n'applique pas les changements
        
    Returns:
        True si modification effectu√©e, False sinon
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            lines = content.split('\n')
        
        # V√©rifier si l'import existe d√©j√†
        if file_has_import(content, import_line):
            print(f"  ‚è≠Ô∏è  Import d√©j√† pr√©sent: {import_line}")
            return False
        
        # Trouver point d'insertion
        insert_idx = find_import_insertion_point(lines)
        
        # Ins√©rer l'import
        lines.insert(insert_idx, import_line)
        
        # Si setup_line fourni, l'ins√©rer apr√®s les imports
        if setup_line:
            # Trouver la fin de la section imports apr√®s insertion
            new_insert_idx = find_import_insertion_point(lines)
            # Ajouter ligne vide puis setup
            lines.insert(new_insert_idx, '')
            lines.insert(new_insert_idx + 1, setup_line)
        
        if dry_run:
            print(f"  [DRY-RUN] Ajouterait: {import_line}")
            if setup_line:
                print(f"  [DRY-RUN] Ajouterait: {setup_line}")
            return True
        
        # √âcrire le fichier modifi√©
        with open(file_path, 'w', encoding='utf-8', newline='\n') as f:
            f.write('\n'.join(lines))
        
        print(f"  ‚úÖ Ajout√©: {import_line}")
        if setup_line:
            print(f"  ‚úÖ Ajout√©: {setup_line}")
        return True
    
    except Exception as e:
        print(f"  ‚ùå Erreur lors de la modification de {file_path}: {e}")
        return False


def fix_file_imports(file_path: str, errors: List[Dict], dry_run: bool = False) -> int:
    """
    Corrige les imports manquants dans un fichier.
    
    Returns:
        Nombre de corrections appliqu√©es
    """
    print(f"\nüìù Traitement: {file_path}")
    
    # Collecter les imports uniques n√©cessaires
    needed_imports = {}
    for error in errors:
        undefined_name = error.get('undefined_name')
        if undefined_name in IMPORT_FIXES and undefined_name not in needed_imports:
            needed_imports[undefined_name] = IMPORT_FIXES[undefined_name]
    
    if not needed_imports:
        print(f"  ‚ö†Ô∏è  Aucun import automatique disponible")
        return 0
    
    # Appliquer les corrections
    fixes_applied = 0
    for name, fix_info in needed_imports.items():
        if add_import_to_file(
            file_path,
            fix_info['import_line'],
            fix_info.get('setup_line'),
            dry_run
        ):
            fixes_applied += 1
    
    return fixes_applied


def main():
    """Point d'entr√©e principal."""
    parser = argparse.ArgumentParser(
        description='Correction automatique des imports manquants (F821)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Afficher les changements sans les appliquer'
    )
    parser.add_argument(
        '--file',
        type=str,
        help='Fichier sp√©cifique √† corriger (chemin relatif)'
    )
    parser.add_argument(
        '--analysis',
        type=str,
        default='reports/f821_analysis.json',
        help='Chemin du fichier d\'analyse F821'
    )
    
    args = parser.parse_args()
    
    print("üöÄ Script de correction F821 - Missing Imports")
    print("=" * 60)
    
    if args.dry_run:
        print("‚ö†Ô∏è  MODE DRY-RUN : Aucune modification ne sera appliqu√©e\n")
    
    # Charger l'analyse
    if not os.path.exists(args.analysis):
        print(f"‚ùå Fichier d'analyse introuvable: {args.analysis}")
        return 1
    
    print(f"üìä Chargement de l'analyse: {args.analysis}")
    analysis_data = load_f821_analysis(args.analysis)
    
    # Obtenir les fichiers √† corriger
    files_to_fix = get_files_to_fix(analysis_data, args.file)
    
    if not files_to_fix:
        print("‚ÑπÔ∏è  Aucun fichier n√©cessitant des corrections automatiques")
        return 0
    
    print(f"\nüì¶ Fichiers √† traiter: {len(files_to_fix)}")
    print("=" * 60)
    
    # Statistiques
    total_fixes = 0
    files_modified = 0
    
    # Traiter chaque fichier
    for file_path, errors in files_to_fix.items():
        fixes = fix_file_imports(file_path, errors, args.dry_run)
        if fixes > 0:
            total_fixes += fixes
            files_modified += 1
    
    # R√©sum√©
    print("\n" + "=" * 60)
    print("üìä R√âSUM√â")
    print("=" * 60)
    print(f"Fichiers trait√©s:  {len(files_to_fix)}")
    print(f"Fichiers modifi√©s: {files_modified}")
    print(f"Imports ajout√©s:   {total_fixes}")
    
    if args.dry_run:
        print("\n‚ö†Ô∏è  Mode DRY-RUN : Aucune modification appliqu√©e")
        print("Relancez sans --dry-run pour appliquer les changements")
    else:
        print("\n‚úÖ Corrections appliqu√©es avec succ√®s!")
        print("\nüìã Prochaines √©tapes:")
        print("  1. V√©rifier les modifications: git diff")
        print("  2. Tester: pytest tests/ -v --tb=short -x")
        print("  3. V√©rifier F821: flake8 --select=F821 --count")
        print("  4. Commit: git add . && git commit -m 'fix(linting): Add missing imports - Phase 1A Batch 1'")
    
    return 0


if __name__ == '__main__':
    exit(main())