"""
Analyseur des r√©sultats de documentation obsol√®te pour priorisation des corrections
Oracle Enhanced v2.1.0 - Mise √† jour Documentation
"""

import project_core.core_from_scripts.auto_env
import json
import re
from pathlib import Path
from collections import defaultdict, Counter
from typing import Dict, List, Tuple

class DocumentationUpdatePrioritizer:
    """Priorise les corrections de documentation bas√©es sur l'analyse"""
    
    def __init__(self, analysis_file: str):
        with open(analysis_file, 'r', encoding='utf-8') as f:
            self.analysis_data = json.load(f)
        
        self.priority_files = [
            'README.md',
            'docs/',
            'CHANGELOG',
            'INSTALL',
            'CONTRIBUTING'
        ]
        
    def categorize_broken_links(self) -> Dict:
        """Cat√©gorise les liens bris√©s par type de probl√®me"""
        categories = {
            'moved_files': [],
            'deleted_files': [],
            'typos': [],
            'external_links': [],
            'priority_docs': [],
            'low_priority': []
        }
        
        for broken_link in self.analysis_data['broken_links']:
            link = broken_link['link']
            source_file = broken_link['source_file']
            
            # Prioriser les fichiers critiques
            if any(priority in source_file for priority in self.priority_files):
                categories['priority_docs'].append(broken_link)
            
            # D√©tecter les fichiers potentiellement d√©plac√©s
            elif self.detect_moved_file(link):
                categories['moved_files'].append(broken_link)
            
            # D√©tecter les typos probables
            elif self.detect_typo(link):
                categories['typos'].append(broken_link)
            
            else:
                categories['low_priority'].append(broken_link)
        
        return categories
    
    def detect_moved_file(self, link: str) -> bool:
        """D√©tecte si un fichier a probablement √©t√© d√©plac√©"""
        # Rechercher des fichiers similaires dans le projet
        filename = Path(link).name
        if filename and '.' in filename:
            try:
                # Nettoyer le nom de fichier pour √©viter les erreurs de pattern
                clean_filename = re.escape(filename)
                # Rechercher le fichier dans tout le projet
                for file_path in Path('.').rglob('*'):
                    if file_path.is_file() and file_path.name == filename:
                        return True
            except (ValueError, OSError):
                # En cas d'erreur, ignorer silencieusement
                pass
        return False
    
    def detect_typo(self, link: str) -> bool:
        """D√©tecte les typos probables dans les liens"""
        # Rechercher des fichiers avec noms similaires
        filename = Path(link).name
        if filename:
            try:
                # Simple heuristique pour d√©tecter les typos
                for file_path in Path('.').rglob('*'):
                    if file_path.is_file() and self.similar_names(filename, file_path.name):
                        return True
            except (ValueError, OSError):
                # En cas d'erreur, ignorer silencieusement
                pass
        return False
    
    def similar_names(self, name1: str, name2: str) -> bool:
        """Compare la similarit√© de deux noms de fichiers"""
        # Calcul simple de distance d'√©dition
        if abs(len(name1) - len(name2)) > 3:
            return False
        
        # V√©rifier les caract√®res communs
        common_chars = set(name1.lower()) & set(name2.lower())
        return len(common_chars) > len(name1) * 0.7
    
    def find_replacement_files(self, broken_links: List[Dict]) -> Dict:
        """Trouve les fichiers de remplacement pour les liens bris√©s"""
        replacements = {}
        
        for broken_link in broken_links:
            link = broken_link['link']
            filename = Path(link).name
            
            if filename:
                try:
                    # Rechercher des fichiers similaires
                    candidates = []
                    for file_path in Path('.').rglob('*'):
                        if file_path.is_file() and filename.lower() in file_path.name.lower():
                            candidates.append(str(file_path))
                    
                    if candidates:
                        # Prendre le candidat le plus probable
                        best_candidate = min(candidates, key=lambda x: len(x))
                        replacements[link] = best_candidate
                except (ValueError, OSError):
                    # En cas d'erreur, ignorer silencieusement
                    continue
        
        return replacements
    
    def generate_correction_plan(self) -> Dict:
        """G√©n√®re un plan de correction prioritaire"""
        categories = self.categorize_broken_links()
        replacements = self.find_replacement_files(categories['moved_files'])
        
        plan = {
            'summary': {
                'total_broken': len(self.analysis_data['broken_links']),
                'priority_docs': len(categories['priority_docs']),
                'moved_files': len(categories['moved_files']),
                'auto_correctable': len(replacements),
                'manual_review_needed': len(categories['priority_docs']) + len(categories['typos'])
            },
            'automatic_corrections': replacements,
            'priority_corrections': categories['priority_docs'][:20],  # Top 20
            'categories': categories
        }
        
        return plan


def main():
    """Ex√©cute l'analyse des r√©sultats et g√©n√®re le plan de correction"""
    analyzer = DocumentationUpdatePrioritizer('logs/documentation_analysis_data.json')
    correction_plan = analyzer.generate_correction_plan()
    
    # Sauvegarder le plan de correction
    with open('logs/documentation_correction_plan.json', 'w', encoding='utf-8') as f:
        json.dump(correction_plan, f, indent=2, ensure_ascii=False)
    
    print(f"üìä Plan de correction g√©n√©r√©:")
    print(f"   üîó Total liens bris√©s: {correction_plan['summary']['total_broken']}")
    print(f"   üèÜ Documents prioritaires: {correction_plan['summary']['priority_docs']}")
    print(f"   ü§ñ Corrections automatiques: {correction_plan['summary']['auto_correctable']}")
    print(f"   üëÅÔ∏è R√©vision manuelle requise: {correction_plan['summary']['manual_review_needed']}")
    
    return correction_plan

if __name__ == "__main__":
    main()