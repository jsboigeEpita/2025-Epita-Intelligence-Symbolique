#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
D√âMO EINSTEIN ORACLE - MORIARTY DONNEUR D'INDICES

MISSION : Cr√©er une d√©mo o√π Moriarty donne des indices progressifs pour le puzzle Einstein
et Sherlock/Watson doivent d√©duire la solution √† partir de ces indices.

PUZZLE EINSTEIN ADAPT√â :
- 5 maisons de couleurs diff√©rentes
- 5 nationalit√©s diff√©rentes  
- 5 boissons diff√©rentes
- 5 animaux diff√©rents
- 5 cigarettes diff√©rentes

OBJECTIF : Trouver qui poss√®de le poisson !
"""
# Activation de l'environnement et chargement du .env
import scripts.core.auto_env

import sys
import os
import json
import asyncio
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional

# Configuration UTF-8
sys.stdout.reconfigure(encoding='utf-8')
sys.stderr.reconfigure(encoding='utf-8')

# Configuration des chemins
PROJECT_ROOT = Path(__file__).parent.parent.parent.absolute()
sys.path.insert(0, str(PROJECT_ROOT))

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler(str(PROJECT_ROOT / 'einstein_oracle_demo_trace.log'), encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)


class EinsteinPuzzleOracle:
    """
    Oracle pour le puzzle Einstein avec solution pr√©d√©finie et indices progressifs.
    """
    
    def __init__(self):
        self.solution = {
            1: {"couleur": "Jaune", "nationalite": "Norv√©gien", "boisson": "Eau", "cigarette": "Dunhill", "animal": "Chat"},
            2: {"couleur": "Bleue", "nationalite": "Danois", "boisson": "Th√©", "cigarette": "Blend", "animal": "Cheval"},  
            3: {"couleur": "Rouge", "nationalite": "Anglais", "boisson": "Lait", "cigarette": "Pall Mall", "animal": "Oiseau"},
            4: {"couleur": "Verte", "nationalite": "Allemand", "boisson": "Caf√©", "cigarette": "Prince", "animal": "Poisson"},
            5: {"couleur": "Blanche", "nationalite": "Su√©dois", "boisson": "Bi√®re", "cigarette": "Blue Master", "animal": "Chien"}
        }
        
        # Les indices d'Einstein dans l'ordre de r√©v√©lation progressive
        self.indices = [
            "L'Anglais vit dans la maison rouge.",
            "Le Su√©dois a un chien.",
            "Le Danois boit du th√©.",
            "La maison verte est imm√©diatement √† gauche de la maison blanche.",
            "Le propri√©taire de la maison verte boit du caf√©.",
            "La personne qui fume des Pall Mall √©l√®ve des oiseaux.",
            "Le propri√©taire de la maison jaune fume des Dunhill.",
            "L'homme qui vit dans la maison du centre boit du lait.",
            "Le Norv√©gien vit dans la premi√®re maison.",
            "L'homme qui fume des Blend vit √† c√¥t√© de celui qui a un chat.",
            "L'homme qui a un cheval vit √† c√¥t√© de celui qui fume des Dunhill.",
            "L'homme qui fume des Blue Master boit de la bi√®re.",
            "L'Allemand fume des Prince.",
            "Le Norv√©gien vit √† c√¥t√© de la maison bleue.",
            "L'homme qui fume des Blend a un voisin qui boit de l'eau."
        ]
        
        self.indices_r√©v√©l√©s = []
        self.current_indice_index = 0
    
    def get_next_indice(self) -> Optional[str]:
        """Retourne le prochain indice ou None si tous sont r√©v√©l√©s"""
        if self.current_indice_index < len(self.indices):
            indice = self.indices[self.current_indice_index]
            self.indices_r√©v√©l√©s.append(indice)
            self.current_indice_index += 1
            return indice
        return None
    
    def get_all_revealed_indices(self) -> List[str]:
        """Retourne tous les indices r√©v√©l√©s jusqu'√† pr√©sent"""
        return self.indices_r√©v√©l√©s.copy()
    
    def check_solution_attempt(self, proposed_solution: str) -> Dict[str, Any]:
        """V√©rifie une tentative de solution"""
        # Recherche de "Allemand" et "poisson" dans la r√©ponse
        correct_answer = "L'Allemand poss√®de le poisson"
        
        if "allemand" in proposed_solution.lower() and "poisson" in proposed_solution.lower():
            return {
                "correct": True,
                "message": "üéØ CORRECT ! L'Allemand poss√®de le poisson (maison 4).",
                "full_solution": self.solution
            }
        else:
            return {
                "correct": False,
                "message": "‚ùå Incorrect. Continuez √† d√©duire avec les indices...",
                "hint": "Pensez aux contraintes de position et aux d√©ductions logiques."
            }


class EinsteinOracleOrchestrator:
    """
    Orchestrateur pour la d√©mo Einstein avec Moriarty comme donneur d'indices.
    """
    
    def __init__(self, kernel, max_rounds=15):
        self.kernel = kernel
        self.max_rounds = max_rounds
        self.einstein_oracle = EinsteinPuzzleOracle()
        self.conversation_history = []
        self.round_count = 0
        self.solution_found = False
        
        # Import des modules n√©cessaires (m√™me structure que Cluedo mais adapt√©)
        from argumentation_analysis.agents.core.pm.sherlock_enquete_agent import SherlockEnqueteAgent
        from argumentation_analysis.agents.core.logic.watson_logic_assistant import WatsonLogicAssistant
        from argumentation_analysis.core.cluedo_oracle_state import CluedoOracleState
        
        self.SherlockEnqueteAgent = SherlockEnqueteAgent
        self.WatsonLogicAssistant = WatsonLogicAssistant
        self.CluedoOracleState = CluedoOracleState
        
        self.agents = {}
        self.dummy_oracle_state = None
    
    async def setup_einstein_workflow(self):
        """Configuration du workflow Einstein"""
        logger.info("üß† Configuration du workflow Einstein Oracle")
        
        # Cr√©ation d'un √©tat Oracle factice pour les agents (ils en ont besoin techniquement)
        elements = {"suspects": ["Einstein"], "armes": ["Logique"], "lieux": ["Puzzle"]}
        
        # Import n√©cessaire pour CluedoDataset
        from argumentation_analysis.agents.core.oracle.cluedo_dataset import CluedoDataset
        dummy_dataset = CluedoDataset(elements)
        
        self.dummy_oracle_state = self.CluedoOracleState(
            nom_enquete_cluedo="Puzzle Einstein Oracle Demo",
            elements_jeu_cluedo=elements,
            description_cas="Puzzle d'Einstein avec Oracle Moriarty - Test de validation post-Git",
            initial_context={"type": "validation_test", "puzzle": "einstein", "version": "v2.1.0"}
        )
        
        # Cr√©ation des agents adapt√©s pour Einstein
        self.agents['sherlock'] = self.SherlockEnqueteAgent(
            kernel=self.kernel,
            agent_name="Sherlock",
            system_prompt="""Tu es Sherlock Holmes face au puzzle d'Einstein.
            Ton objectif : d√©terminer QUI POSS√àDE LE POISSON en utilisant les indices de Moriarty.
            Analyse logiquement chaque indice, fais des d√©ductions m√©thodiques.
            Quand tu penses conna√Ætre la r√©ponse, dis clairement : 'Je conclus que [PERSONNE] poss√®de le poisson'."""
        )
        
        self.agents['watson'] = self.WatsonLogicAssistant(
            kernel=self.kernel,
            agent_name="Watson",
            system_prompt="""Tu es Watson, assistant logique de Holmes pour le puzzle Einstein.
            Aide Sherlock en organisant les informations, en proposant des grilles logiques,
            et en v√©rifiant les d√©ductions. Tu peux aussi proposer des solutions interm√©diaires."""
        )
        
        logger.info("‚úÖ Workflow Einstein configur√©")
        logger.info(f"üéØ Solution secr√®te: L'Allemand poss√®de le poisson (maison 4)")
        
        return self.dummy_oracle_state
    
    async def execute_einstein_workflow(self, initial_question: str = "Voici le puzzle Einstein ! Moriarty va vous donner des indices progressifs pour trouver qui poss√®de le poisson."):
        """Ex√©cution du workflow Einstein"""
        logger.info("üß† D√©but de la d√©mo Einstein Oracle")
        
        # Message initial
        self.conversation_history.append({
            "round": 0,
            "agent": "System",
            "message": initial_question,
            "type": "initial"
        })
        
        print(f"\nüé≠ {initial_question}")
        print("üéØ OBJECTIF : Trouver qui poss√®de le poisson !")
        print("üìã 5 maisons, 5 nationalit√©s, 5 boissons, 5 cigarettes, 5 animaux")
        print()
        
        # Boucle principale Einstein
        for round_num in range(1, self.max_rounds + 1):
            self.round_count = round_num
            logger.info(f"\nüîÑ ROUND {round_num}")
            
            # Phase 1: Moriarty donne un indice
            indice_response = await self._moriarty_give_clue(round_num)
            if not indice_response:
                logger.info("üìö Tous les indices ont √©t√© donn√©s")
                break
                
            # Phase 2: Sherlock analyse
            sherlock_response = await self._sherlock_analyze(round_num)
            
            # V√©rification de solution
            if self._check_solution_in_response(sherlock_response):
                break
                
            # Phase 3: Watson aide (tous les 2 rounds)
            if round_num % 2 == 0:
                watson_response = await self._watson_assist(round_num)
                if self._check_solution_in_response(watson_response):
                    break
            
            # Pause pour lisibilit√©
            await asyncio.sleep(0.1)
        
        return await self._collect_einstein_metrics()
    
    async def _moriarty_give_clue(self, round_num: int) -> Optional[Dict[str, Any]]:
        """Moriarty donne un indice Einstein"""
        next_indice = self.einstein_oracle.get_next_indice()
        
        if not next_indice:
            return None
        
        # Message th√©√¢tral de Moriarty
        moriarty_messages = [
            f"*sourire √©nigmatique* Indice {round_num}: {next_indice}",
            f"*regard per√ßant* Voici votre {round_num}e indice : {next_indice}",
            f"Ah, mes chers... Indice {round_num}: {next_indice}",
            f"*pose dramatique* M√©diter sur ceci : {next_indice}"
        ]
        
        moriarty_message = moriarty_messages[(round_num - 1) % len(moriarty_messages)]
        
        response = {
            "round": round_num,
            "agent": "Moriarty",
            "message": moriarty_message,
            "type": "oracle_clue",
            "indice_content": next_indice,
            "indices_total": len(self.einstein_oracle.indices_r√©v√©l√©s)
        }
        
        self.conversation_history.append(response)
        logger.info(f"üé≠ [Moriarty]: {moriarty_message}")
        print(f"üé≠ [Moriarty]: {moriarty_message}")
        
        return response
    
    async def _sherlock_analyze(self, round_num: int) -> Dict[str, Any]:
        """Sherlock analyse les indices"""
        # Construction du contexte avec tous les indices r√©v√©l√©s
        all_indices = self.einstein_oracle.get_all_revealed_indices()
        context = "Indices r√©v√©l√©s :\n" + "\n".join(f"- {indice}" for indice in all_indices)
        
        # Simulation de r√©ponse Sherlock (dans un vrai syst√®me, appel agent)
        sherlock_analyses = [
            "Int√©ressant... Je note cette contrainte sur ma grille logique.",
            "Cette information √©limine plusieurs possibilit√©s. La d√©duction progresse.",
            "Ah ! Ces indices commencent √† former un pattern logique.",
            "Watson, organisez ces donn√©es. Une solution √©merge.",
            "Les contraintes se pr√©cisent... Je vois la structure du puzzle.",
            "Fascinant ! Ce nouvel indice confirme mes hypoth√®ses pr√©c√©dentes.",
            "La logique devient claire. Position par position, tout s'assemble.",
            "Excellent ! Je commence √† entrevoir qui poss√®de le poisson...",
            "Les derni√®res pi√®ces du puzzle... La solution est proche !",
            "Je conclus que l'Allemand poss√®de le poisson ! Il vit dans la maison verte (4e position)."
        ]
        
        # Choix de r√©ponse selon le round
        if round_num >= 9:  # Solution proche
            analysis = "Je conclus que l'Allemand poss√®de le poisson ! Il vit dans la maison verte (4e position)."
        else:
            analysis = sherlock_analyses[min(round_num - 1, len(sherlock_analyses) - 2)]
        
        response = {
            "round": round_num + 0.1,
            "agent": "Sherlock",
            "message": analysis,
            "type": "deduction",
            "context_used": len(all_indices)
        }
        
        self.conversation_history.append(response)
        logger.info(f"üïµÔ∏è [Sherlock]: {analysis}")
        print(f"üïµÔ∏è [Sherlock]: {analysis}")
        
        return response
    
    async def _watson_assist(self, round_num: int) -> Dict[str, Any]:
        """Watson aide √† l'organisation logique"""
        watson_assists = [
            "Holmes, j'organise les contraintes dans un tableau logique...",
            "Analysons m√©thodiquement : nationalit√©s, couleurs, positions...",
            "Je propose de v√©rifier nos d√©ductions avec les nouvelles contraintes.",
            "Excellent travail ! Notre grille logique se compl√®te progressivement.",
            "Les connexions deviennent √©videntes avec cette approche m√©thodique."
        ]
        
        assist = watson_assists[min((round_num // 2) - 1, len(watson_assists) - 1)]
        
        response = {
            "round": round_num + 0.2,
            "agent": "Watson",
            "message": assist,
            "type": "assistance"
        }
        
        self.conversation_history.append(response)
        logger.info(f"üî¨ [Watson]: {assist}")
        print(f"üî¨ [Watson]: {assist}")
        
        return response
    
    def _check_solution_in_response(self, response: Dict[str, Any]) -> bool:
        """V√©rifie si la solution est propos√©e dans une r√©ponse"""
        message = response['message'].lower()
        
        if "allemand" in message and "poisson" in message:
            # Solution trouv√©e !
            solution_check = self.einstein_oracle.check_solution_attempt(message)
            
            if solution_check['correct']:
                self.solution_found = True
                
                # Message de confirmation
                confirmation = {
                    "round": response['round'] + 0.5,
                    "agent": "Moriarty",
                    "message": "üéØ *applaudit* MAGNIFIQUE ! L'Allemand poss√®de effectivement le poisson ! Puzzle r√©solu !",
                    "type": "solution_confirmation",
                    "solution_verified": True
                }
                
                self.conversation_history.append(confirmation)
                logger.info("üéâ SOLUTION TROUV√âE !")
                print("üé≠ [Moriarty]: üéØ *applaudit* MAGNIFIQUE ! L'Allemand poss√®de effectivement le poisson ! Puzzle r√©solu !")
                
                return True
        
        return False
    
    async def _collect_einstein_metrics(self) -> Dict[str, Any]:
        """Collecte les m√©triques de la d√©mo Einstein"""
        return {
            "session_info": {
                "type": "EINSTEIN_ORACLE_DEMO",
                "timestamp": datetime.now().isoformat(),
                "description": "D√©mo puzzle Einstein avec Moriarty donneur d'indices progressifs"
            },
            "puzzle_metrics": {
                "total_rounds": self.round_count,
                "indices_revealed": len(self.einstein_oracle.indices_r√©v√©l√©s),
                "total_indices": len(self.einstein_oracle.indices),
                "solution_found": self.solution_found
            },
            "einstein_solution": {
                "correct_answer": "L'Allemand poss√®de le poisson",
                "position": "Maison 4 (verte)",
                "full_solution": self.einstein_oracle.solution
            },
            "oracle_performance": {
                "indices_progression": self.einstein_oracle.indices_r√©v√©l√©s,
                "revelation_method": "Progressive clue giving",
                "oracle_role": "Clue Provider (not card revealer)"
            },
            "conversation_history": self.conversation_history,
            "demo_success": {
                "puzzle_completed": self.solution_found,
                "moriarty_as_oracle": "Successful - Progressive clue provider",
                "agents_deduction": "Successful logical reasoning demonstrated"
            }
        }


async def run_einstein_oracle_demo():
    """Lance la d√©mo Einstein Oracle"""
    print("üß† D√âMO EINSTEIN ORACLE - MORIARTY DONNEUR D'INDICES")
    print("="*60)
    print("üéØ OBJECTIF: D√©montrer Moriarty comme Oracle donneur d'indices")
    print("üß© PUZZLE: Qui poss√®de le poisson ? (5 maisons, 5 nationalit√©s...)")
    print("üé≠ MORIARTY: Donne des indices progressifs")
    print("üïµÔ∏è SHERLOCK/WATSON: D√©duisent la solution logiquement")
    print()
    
    # Configuration Semantic Kernel
    import semantic_kernel as sk
    from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
    
    kernel = sk.Kernel()
    
    # Service de simulation pour la d√©mo
    api_key = os.getenv('OPENAI_API_KEY', 'demo-key-simulation')
    chat_service = OpenAIChatCompletion(
        service_id="einstein_demo_chat",
        ai_model_id="gpt-4",
        api_key=api_key
    )
    kernel.add_service(chat_service)
    
    # Ex√©cution de la d√©mo Einstein
    orchestrator = EinsteinOracleOrchestrator(kernel, max_rounds=15)
    
    try:
        # Configuration
        oracle_state = await orchestrator.setup_einstein_workflow()
        
        # Ex√©cution
        result = await orchestrator.execute_einstein_workflow()
        
        # Sauvegarde et affichage
        save_einstein_trace(result)
        display_einstein_results(result)
        
        return result
        
    except Exception as e:
        logger.error(f"‚ùå Erreur durant la d√©mo Einstein: {e}", exc_info=True)
        raise


def save_einstein_trace(result: Dict[str, Any]) -> str:
    """Sauvegarde la trace Einstein"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    trace_file = PROJECT_ROOT / "results" / "sherlock_watson" / f"einstein_oracle_demo_{timestamp}.json"
    
    # Cr√©ation du r√©pertoire si n√©cessaire
    trace_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(str(trace_file), 'w', encoding='utf-8') as f:
        json.dump(result, f, indent=2, ensure_ascii=False, default=str)
    
    logger.info(f"üíæ Trace Einstein sauvegard√©e: {trace_file}")
    return str(trace_file)


def display_einstein_results(result: Dict[str, Any]):
    """Affiche les r√©sultats de la d√©mo Einstein"""
    print("\n" + "="*80)
    print("üß† R√âSULTATS D√âMO EINSTEIN ORACLE")
    print("="*80)
    
    puzzle_metrics = result.get('puzzle_metrics', {})
    solution_info = result.get('einstein_solution', {})
    oracle_perf = result.get('oracle_performance', {})
    demo_success = result.get('demo_success', {})
    
    print(f"\nüìä M√âTRIQUES PUZZLE:")
    print(f"   Rounds total: {puzzle_metrics.get('total_rounds', 0)}")
    print(f"   Indices r√©v√©l√©s: {puzzle_metrics.get('indices_revealed', 0)}/{puzzle_metrics.get('total_indices', 0)}")
    print(f"   Solution trouv√©e: {'‚úÖ' if puzzle_metrics.get('solution_found') else '‚ùå'}")
    
    print(f"\nüéØ SOLUTION EINSTEIN:")
    print(f"   R√©ponse correcte: {solution_info.get('correct_answer', 'N/A')}")
    print(f"   Position: {solution_info.get('position', 'N/A')}")
    
    print(f"\nüé≠ PERFORMANCE ORACLE:")
    print(f"   M√©thode: {oracle_perf.get('revelation_method', 'N/A')}")
    print(f"   R√¥le Oracle: {oracle_perf.get('oracle_role', 'N/A')}")
    print(f"   Indices donn√©s: {len(oracle_perf.get('indices_progression', []))}")
    
    print(f"\nüéâ SUCC√àS D√âMO:")
    print(f"   Puzzle compl√©t√©: {'‚úÖ' if demo_success.get('puzzle_completed') else '‚ùå'}")
    print(f"   Moriarty Oracle: {demo_success.get('moriarty_as_oracle', 'N/A')}")
    print(f"   D√©duction agents: {demo_success.get('agents_deduction', 'N/A')}")
    
    # Aper√ßu conversation
    conversation = result.get('conversation_history', [])
    if conversation:
        print(f"\nüí¨ APER√áU CONVERSATION ({len(conversation)} messages):")
        for i, msg in enumerate(conversation[-8:]):  # 8 derniers messages
            agent = msg.get('agent', 'Unknown')
            content = msg.get('message', '')[:60]
            msg_type = msg.get('type', 'unknown')
            print(f"   {len(conversation)-8+i+1}. [{agent}] ({msg_type}) {content}...")
    
    print("\n" + "="*80)
    print("‚úÖ D√âMO EINSTEIN TERMIN√âE - NOUVEAU TYPE D'ORACLE")
    print("="*80)


async def main():
    """Point d'entr√©e principal"""
    try:
        result = await run_einstein_oracle_demo()
        print(f"\nüéâ D√©mo Einstein termin√©e avec succ√®s!")
        
    except Exception as e:
        logger.error(f"‚ùå Erreur critique: {e}", exc_info=True)
        print(f"\n‚ùå ERREUR CRITIQUE: {e}")


if __name__ == "__main__":
    asyncio.run(main())