#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
SCRIPT WRAPPER R√âEL POUR SYST√àME AGENTIQUE SHERLOCK-WATSON-MORIARTY

MISSION CRITIQUE : Ex√©cuter le VRAI syst√®me agentique sans simulation.
Ce script utilise l'environnement d√©di√© projet-is et lance les vrais agents.
"""

import sys
import os
import json
import asyncio
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, Any

# Configuration UTF-8 pour √©viter les probl√®mes d'encodage
sys.stdout.reconfigure(encoding='utf-8')
sys.stderr.reconfigure(encoding='utf-8')

# Configuration des chemins pour l'environnement projet
PROJECT_ROOT = Path(__file__).parent.parent.parent.absolute()  # Remonte vers la racine du projet
sys.path.insert(0, str(PROJECT_ROOT))

# Configuration du logging avec UTF-8 (avant tout autre import)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler(str(PROJECT_ROOT / 'sherlock_watson_moriarty_real_trace.log'), encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement depuis .env
try:
    from dotenv import load_dotenv
    load_dotenv(PROJECT_ROOT / '.env')
    logger.info("‚úÖ Variables d'environnement charg√©es depuis .env")
except ImportError:
    logger.warning("‚ö†Ô∏è python-dotenv non disponible, utilisation variables syst√®me")
except Exception as e:
    logger.warning(f"‚ö†Ô∏è Erreur chargement .env : {e}")


async def setup_real_agents_and_run():
    """Configuration et ex√©cution du vrai syst√®me agentique"""
    logger.info("üöÄ LANCEMENT DU VRAI SYST√àME AGENTIQUE SHERLOCK-WATSON-MORIARTY")
    
    # Import du vrai orchestrateur avec gestion des erreurs d'imports relatifs
    try:
        # Import en mode module pour √©viter les probl√®mes d'imports relatifs
        import argumentation_analysis.core.cluedo_oracle_state as cluedo_state_module
        import argumentation_analysis.orchestration.plugins.enquete_state_manager_plugin as state_plugin_module
        import argumentation_analysis.agents.core.pm.sherlock_enquete_agent as sherlock_module
        import argumentation_analysis.agents.core.logic.watson_logic_assistant as watson_module
        import argumentation_analysis.agents.core.oracle.moriarty_interrogator_agent as moriarty_module
        
        CluedoOracleState = cluedo_state_module.CluedoOracleState
        EnqueteStateManagerPlugin = state_plugin_module.EnqueteStateManagerPlugin
        SherlockEnqueteAgent = sherlock_module.SherlockEnqueteAgent
        WatsonLogicAssistant = watson_module.WatsonLogicAssistant
        MoriartyInterrogatorAgent = moriarty_module.MoriartyInterrogatorAgent
        
        logger.info("‚úÖ Imports des vrais agents r√©ussis (mode module)")
    except ImportError as e:
        logger.error(f"‚ùå Erreur d'import des agents : {e}")
        logger.info("üí° Tentative d'import direct depuis l'orchestrateur...")
        try:
            import argumentation_analysis.orchestration.cluedo_extended_orchestrator as orchestrator_module
            # L'orchestrateur a d√©j√† toutes les d√©pendances, on l'utilise directement
            return await run_with_orchestrator_module(orchestrator_module)
        except ImportError as e2:
            logger.error(f"‚ùå Erreur d'import de l'orchestrateur √©galement : {e2}")
            raise

    # Import du vrai orchestrateur
    try:
        import argumentation_analysis.orchestration.cluedo_extended_orchestrator as orchestrator_module
        CluedoExtendedOrchestrator = orchestrator_module.CluedoExtendedOrchestrator
        logger.info("‚úÖ Import du vrai orchestrateur r√©ussi")
    except ImportError as e:
        logger.error(f"‚ùå Erreur d'import de l'orchestrateur : {e}")
        raise

    # Configuration Semantic Kernel avec service LLM r√©el
    try:
        import semantic_kernel as sk
        from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
        
        kernel = sk.Kernel()
        
        # Configuration du service OpenAI r√©el
        api_key = os.getenv('OPENAI_API_KEY')
        if not api_key:
            logger.warning("‚ö†Ô∏è OPENAI_API_KEY non trouv√©e dans les variables d'environnement")
            logger.info("üìù Veuillez configurer votre cl√© API OpenAI")
            return None
        
        # Service ChatGPT r√©el - utilise gpt-4o-mini comme configur√© dans .env
        model_id = os.getenv('OPENAI_CHAT_MODEL_ID', 'gpt-4o-mini')
        chat_service = OpenAIChatCompletion(
            service_id="openai_chat",
            ai_model_id=model_id,
            api_key=api_key
        )
        kernel.add_service(chat_service)
        logger.info("‚úÖ Service ChatGPT r√©el configur√©")
        
    except Exception as e:
        logger.error(f"‚ùå Erreur configuration Semantic Kernel : {e}")
        raise

    # V√©rification et configuration JVM pour Tweety (Watson)
    try:
        from argumentation_analysis.service_setup.analysis_services import initialize_analysis_services
        
        services = initialize_analysis_services({
            "LIBS_DIR_PATH": str(PROJECT_ROOT / "libs")
        })
        
        if services.get("jvm_ready"):
            logger.info("‚úÖ JVM Tweety pr√™te pour Watson")
        else:
            logger.warning("‚ö†Ô∏è JVM Tweety non disponible - Watson fonctionnera en mode d√©grad√©")
            
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Configuration JVM : {e}")

    # Cr√©ation et ex√©cution du vrai orchestrateur
    try:
        logger.info("üé≠ Initialisation du vrai orchestrateur 3-agents")
        
        orchestrator = CluedoExtendedOrchestrator(
            kernel=kernel,
            max_turns=12,  # Session courte mais compl√®te
            max_cycles=4,
            oracle_strategy="balanced",
            adaptive_selection=False
        )
        
        # Configuration du workflow r√©el
        logger.info("‚öôÔ∏è Configuration du workflow avec vrais agents")
        oracle_state = await orchestrator.setup_workflow(
            nom_enquete="Le Myst√®re du Manoir Tudor - Session R√©elle",
            elements_jeu={
                "suspects": ["Colonel Moutarde", "Professeur Violet", "Mademoiselle Rose", "Docteur Orchid√©e"],
                "armes": ["Poignard", "Chandelier", "Revolver", "Corde"],
                "lieux": ["Salon", "Cuisine", "Bureau", "Biblioth√®que"]
            }
        )
        
        logger.info(f"üéØ Solution secr√®te g√©n√©r√©e : {oracle_state.get_solution_secrete()}")
        logger.info(f"üÉè Cartes Moriarty : {oracle_state.get_moriarty_cards()}")
        
        # EX√âCUTION R√âELLE DU WORKFLOW
        logger.info("üé¨ D√âBUT DE LA SESSION R√âELLE - AUCUNE SIMULATION")
        
        result = await orchestrator.execute_workflow(
            initial_question="L'enqu√™te commence. Sherlock, menez l'investigation avec vos vrais d√©ductions !"
        )
        
        logger.info("‚úÖ Session r√©elle termin√©e avec succ√®s")
        
        return result
        
    except Exception as e:
        logger.error(f"‚ùå Erreur durant l'ex√©cution r√©elle : {e}", exc_info=True)
        raise


async def run_with_orchestrator_module(orchestrator_module):
    """Fonction alternative qui utilise directement le module orchestrateur"""
    logger.info("üé≠ Utilisation directe du module orchestrateur")
    
    # Configuration Semantic Kernel avec service LLM r√©el
    try:
        import semantic_kernel as sk
        from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
        
        kernel = sk.Kernel()
        
        # Configuration du service OpenAI r√©el
        api_key = os.getenv('OPENAI_API_KEY')
        if not api_key:
            logger.warning("‚ö†Ô∏è OPENAI_API_KEY non trouv√©e dans les variables d'environnement")
            logger.info("üìù Continuons avec l'ex√©cution pour tester l'environnement...")
            # On continue quand m√™me pour tester les imports
        else:
            # Service ChatGPT r√©el - utilise gpt-4o-mini comme configur√© dans .env
            model_id = os.getenv('OPENAI_CHAT_MODEL_ID', 'gpt-4o-mini')
            chat_service = OpenAIChatCompletion(
                service_id="openai_chat",
                ai_model_id=model_id,
                api_key=api_key
            )
            kernel.add_service(chat_service)
            logger.info("‚úÖ Service ChatGPT r√©el configur√©")
        
    except Exception as e:
        logger.error(f"‚ùå Erreur configuration Semantic Kernel : {e}")
        raise

    # Ex√©cution avec l'orchestrateur
    try:
        CluedoExtendedOrchestrator = orchestrator_module.CluedoExtendedOrchestrator
        run_cluedo_oracle_game = orchestrator_module.run_cluedo_oracle_game
        
        logger.info("üé¨ D√âBUT DE LA SESSION R√âELLE VIA ORCHESTRATEUR")
        
        result = await run_cluedo_oracle_game(
            kernel=kernel,
            initial_question="L'enqu√™te commence. Sherlock, menez l'investigation avec vos vrais d√©ductions !",
            max_turns=12,
            max_cycles=4,
            oracle_strategy="balanced"
        )
        
        logger.info("‚úÖ Session r√©elle termin√©e avec succ√®s")
        return result
        
    except Exception as e:
        logger.error(f"‚ùå Erreur durant l'ex√©cution r√©elle via orchestrateur : {e}", exc_info=True)
        raise


def save_real_trace(result: Dict[str, Any]) -> str:
    """Sauvegarde la trace conversationnelle r√©elle"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    trace_file = PROJECT_ROOT / "results" / "sherlock_watson" / f"trace_reelle_sherlock_watson_moriarty_{timestamp}.json"
    
    # Enrichissement des m√©tadonn√©es
    enriched_result = {
        "session_info": {
            "timestamp": datetime.now().isoformat(),
            "type": "REAL_AGENTS_SESSION",
            "description": "Trace conversationnelle authentique avec vrais agents ChatGPT et Tweety",
            "no_simulation": True,
            "agents": ["Sherlock (ChatGPT)", "Watson (Tweety JVM)", "Moriarty (ChatGPT + Oracle)"]
        },
        "real_execution_data": result,
        "verification": {
            "agents_used": "OpenAI ChatGPT + Tweety JVM",
            "oracle_system": "Authentique CluedoOracleState",
            "conversation_authentic": True
        }
    }
    
    with open(str(trace_file), 'w', encoding='utf-8') as f:
        json.dump(enriched_result, f, indent=2, ensure_ascii=False, default=str)
    
    logger.info(f"üíæ Trace r√©elle sauvegard√©e : {trace_file}")
    return str(trace_file)


def print_real_session_summary(result: Dict[str, Any]):
    """Affiche le r√©sum√© de la session r√©elle"""
    print("\n" + "="*80)
    print("üé≠ R√âSULTAT SESSION R√âELLE SHERLOCK-WATSON-MORIARTY")
    print("="*80)
    
    workflow_info = result.get('workflow_info', {})
    solution_analysis = result.get('solution_analysis', {})
    oracle_stats = result.get('oracle_statistics', {})
    final_state = result.get('final_state', {})
    
    print(f"\nüïê Dur√©e d'ex√©cution : {workflow_info.get('execution_time_seconds', 0):.2f} secondes")
    print(f"üîÑ Tours total : {oracle_stats.get('agent_interactions', {}).get('total_turns', 0)}")
    print(f"üîÆ Requ√™tes Oracle : {oracle_stats.get('workflow_metrics', {}).get('oracle_interactions', 0)}")
    print(f"üíé Cartes r√©v√©l√©es : {oracle_stats.get('workflow_metrics', {}).get('cards_revealed', 0)}")
    
    print(f"\nüéØ SUCC√àS : {solution_analysis.get('success', False)}")
    if solution_analysis.get('success'):
        print(f"‚úÖ Solution trouv√©e : {final_state.get('final_solution', 'N/A')}")
    else:
        print(f"‚ùå Solution propos√©e : {final_state.get('final_solution', 'Aucune')}")
        print(f"üéØ Solution correcte : {final_state.get('secret_solution', 'N/A')}")
    
    # Affichage de la conversation r√©elle (extraits)
    conversation = result.get('conversation_history', [])
    if conversation:
        print(f"\nüí¨ EXTRAITS CONVERSATION R√âELLE ({len(conversation)} messages) :")
        for i, msg in enumerate(conversation[:6]):  # Premiers 6 messages
            sender = msg.get('sender', 'Unknown')
            content = msg.get('message', '')[:100]
            print(f"  {i+1}. [{sender}] {content}...")
        
        if len(conversation) > 6:
            print(f"  ... et {len(conversation) - 6} autres messages")
    
    print("\n" + "="*80)
    print("‚úÖ SESSION R√âELLE TERMIN√âE - AUCUNE SIMULATION UTILIS√âE")
    print("="*80)


async def main():
    """Point d'entr√©e principal"""
    try:
        print("üöÄ LANCEMENT DU SYST√àME AGENTIQUE R√âEL SHERLOCK-WATSON-MORIARTY")
        print("üìã MISSION : Ex√©cuter une session authentique avec vrais agents")
        print("üö´ AUCUNE SIMULATION - TOUT EST R√âEL")
        print()
        
        # V√©rification des pr√©requis
        if not os.getenv('OPENAI_API_KEY'):
            print("‚ùå ERREUR : Variable OPENAI_API_KEY non configur√©e")
            print("üìù Veuillez configurer votre cl√© API OpenAI dans les variables d'environnement")
            return
        
        # Ex√©cution de la session r√©elle
        result = await setup_real_agents_and_run()
        
        if result:
            # Sauvegarde de la trace r√©elle
            trace_file = save_real_trace(result)
            
            # Affichage du r√©sum√©
            print_real_session_summary(result)
            
            print(f"\nüìÅ Trace compl√®te sauvegard√©e dans : {trace_file}")
            print("üîç V√©rifiez le fichier JSON pour la trace conversationnelle compl√®te")
            
        else:
            print("‚ùå √âchec de l'ex√©cution de la session r√©elle")
            
    except Exception as e:
        logger.error(f"‚ùå Erreur critique : {e}", exc_info=True)
        print(f"\n‚ùå ERREUR CRITIQUE : {e}")
        print("üìã V√©rifiez les logs dans sherlock_watson_moriarty_real_trace.log")


if __name__ == "__main__":
    asyncio.run(main())