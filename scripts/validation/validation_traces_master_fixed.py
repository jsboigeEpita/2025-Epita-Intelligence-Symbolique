#!/usr/bin/env python3
# scripts/validation_traces_master_fixed.py

"""
Script ma√Ætre de validation des d√©mos Sherlock, Watson et Moriarty avec traces compl√®tes.
Version corrig√©e avec auto_env compatible.
"""

# ===== INT√âGRATION AUTO_ENV - M√äME APPROCHE QUE CONFTEST.PY =====
import sys
import os
from pathlib import Path

# D√©terminer le r√©pertoire racine du projet
project_root = Path(__file__).parent.parent.absolute()

try:
    # Import direct par chemin absolu pour √©viter les probl√®mes d'import
    scripts_core_path = project_root / "scripts" / "core"
    if str(scripts_core_path) not in sys.path:
        sys.path.insert(0, str(scripts_core_path))
    
    from auto_env import ensure_env
    success = ensure_env(silent=False)
    
    if success:
        print("[OK AUTO_ENV] Environnement projet activ√© avec succ√®s")
    else:
        print("[WARN AUTO_ENV] Activation en mode d√©grad√©")
        
except ImportError as e:
    print(f"[ERROR AUTO_ENV] Module auto_env non disponible: {e}")
except Exception as e:
    print(f"[ERROR AUTO_ENV] Erreur d'activation: {e}")

# ===== IMPORTS PRINCIPAUX =====
import asyncio
import json
import logging
import datetime
from typing import Dict, List, Any, Optional

from dotenv import load_dotenv
from semantic_kernel import Kernel
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion

# Imports sp√©cifiques au projet
from argumentation_analysis.orchestration.cluedo_extended_orchestrator import run_cluedo_oracle_game
from argumentation_analysis.orchestration.logique_complexe_orchestrator import LogiqueComplexeOrchestrator
from argumentation_analysis.agents.core.pm.sherlock_enquete_agent import SherlockEnqueteAgent, SherlockTools
from argumentation_analysis.agents.core.logic.watson_logic_assistant import WatsonLogicAssistant
from argumentation_analysis.utils.core_utils.logging_utils import setup_logging

class MasterTraceValidator:
    """Validateur ma√Ætre orchestrant toutes les validations avec traces."""
    
    def __init__(self, output_dir: str = ".temp"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.logger = logging.getLogger(__name__)
        
        # Cr√©ation des r√©pertoires de traces
        self.cluedo_dir = self.output_dir / "traces_cluedo"
        self.einstein_dir = self.output_dir / "traces_einstein"
        self.cluedo_dir.mkdir(parents=True, exist_ok=True)
        self.einstein_dir.mkdir(parents=True, exist_ok=True)
        
    def validate_environment(self) -> Dict[str, Any]:
        """Valide l'environnement avant d'ex√©cuter les tests."""
        
        print("üîç VALIDATION DE L'ENVIRONNEMENT")
        print("="*50)
        
        validation_results = {
            "openai_api_key": bool(os.getenv("OPENAI_API_KEY")),
            "directories_created": True,
            "python_imports": True,
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        # V√©rification cl√© API
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            print("‚ùå OPENAI_API_KEY non d√©finie")
            validation_results["openai_api_key"] = False
        else:
            print(f"‚úÖ OPENAI_API_KEY d√©finie (longueur: {len(api_key)})")
            
        # V√©rification des r√©pertoires
        if self.cluedo_dir.exists() and self.einstein_dir.exists():
            print("‚úÖ R√©pertoires de traces cr√©√©s")
        else:
            print("‚ùå R√©pertoires de traces manquants")
            validation_results["directories_created"] = False
            
        # Test d'imports
        try:
            print("‚úÖ Imports des orchestrateurs r√©ussis")
        except ImportError as e:
            print(f"‚ùå Erreur d'import: {e}")
            validation_results["python_imports"] = False
            
        # R√©sum√©
        all_ok = all(validation_results[k] for k in ["openai_api_key", "directories_created", "python_imports"])
        validation_results["environment_ready"] = all_ok
        
        if all_ok:
            print("\nüéâ ENVIRONNEMENT PR√äT POUR LA VALIDATION")
        else:
            print("\n‚ö†Ô∏è  PROBL√àMES D√âTECT√âS - CORRECTION N√âCESSAIRE")
            
        return validation_results

    def create_kernel(self, model_name: str = "gpt-4o-mini") -> Kernel:
        """Cr√©ation du kernel Semantic Kernel avec service OpenAI."""
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY non d√©finie dans l'environnement")
            
        kernel = Kernel()
        chat_service = OpenAIChatCompletion(
            service_id="openai_chat",
            api_key=api_key,
            ai_model_id=model_name
        )
        kernel.add_service(chat_service)
        return kernel

    def generate_simple_cluedo_case(self) -> str:
        """G√©n√®re un cas de Cluedo simple (3-4 indices)."""
        return """Enqu√™te Cluedo simple: 
        - T√©moin A: 'J'ai vu Mme Peacock dans la biblioth√®que vers 21h00'
        - T√©moin B: 'Le chandelier manquait dans le salon apr√®s 21h30'
        - T√©moin C: 'Professor Plum √©tait dans la cuisine √† 21h15'
        - Indice physique: Traces de cire dans la biblioth√®que
        
        Question: Qui a commis le meurtre, avec quelle arme et dans quel lieu ?"""

    def generate_complex_cluedo_case(self) -> str:
        """G√©n√®re un cas de Cluedo complexe avec contradictions."""
        return """Enqu√™te Cluedo complexe avec contradictions:
        - T√©moin A: 'Mme Peacock √©tait dans la biblioth√®que vers 21h00'
        - T√©moin B: 'Mme Peacock √©tait dans le salon √† 21h00' (CONTRADICTION)
        - T√©moin C: 'J'ai entendu un bruit dans la biblioth√®que vers 21h15'
        - T√©moin D: 'Professor Plum avait le chandelier √† 20h45'
        - T√©moin E: 'Professor Plum n'avait pas d'arme √† 20h45' (CONTRADICTION)
        - Indice: Empreintes de Mme Peacock sur le chandelier
        - Indice: Traces de cire dans la biblioth√®que et le salon
        - Indice: Alibi partiel de Professor Plum en cuisine (20h30-21h00)
        - Indice: Porte de la biblioth√®que ferm√©e √† cl√© apr√®s 21h30
        
        Question: R√©solvez cette enqu√™te en g√©rant les contradictions."""

    def generate_simple_einstein_case(self) -> str:
        """G√©n√®re un cas Einstein simple (5 contraintes)."""
        return """√ânigme Einstein simple - 5 maisons:
        
        Il y a 5 maisons de couleurs diff√©rentes align√©es.
        Dans chaque maison vit une personne de nationalit√© diff√©rente.
        Chaque personne boit une boisson diff√©rente, fume une marque diff√©rente et poss√®de un animal diff√©rent.
        
        Contraintes:
        1. L'Anglais vit dans la maison rouge
        2. Le Su√©dois poss√®de un chien  
        3. Le Danois boit du th√©
        4. La maison verte est √† gauche de la maison blanche
        5. Le propri√©taire de la maison verte boit du caf√©
        
        Question: Qui poss√®de le poisson ?
        
        ATTENTION: Cette √©nigme DOIT √™tre r√©solue avec la logique formelle TweetyProject par Watson."""

    def generate_complex_einstein_case(self) -> str:
        """G√©n√®re un cas Einstein complexe (10+ contraintes)."""
        return """√ânigme Einstein complexe - 5 maisons:
        
        Il y a 5 maisons de couleurs diff√©rentes align√©es.
        Dans chaque maison vit une personne de nationalit√© diff√©rente.
        Chaque personne boit une boisson diff√©rente, fume une marque diff√©rente et poss√®de un animal diff√©rent.
        
        Contraintes complexes:
        1. L'Anglais vit dans la maison rouge
        2. Le Su√©dois poss√®de un chien
        3. Le Danois boit du th√©
        4. La maison verte est imm√©diatement √† gauche de la maison blanche
        5. Le propri√©taire de la maison verte boit du caf√©
        6. La personne qui fume des Pall Mall poss√®de des oiseaux
        7. Le propri√©taire de la maison jaune fume des Dunhill
        8. La personne qui vit dans la maison du milieu boit du lait
        9. Le Norv√©gien vit dans la premi√®re maison
        10. La personne qui fume des Blend vit √† c√¥t√© de celle qui poss√®de des chats
        11. La personne qui poss√®de un cheval vit √† c√¥t√© de celle qui fume des Dunhill
        12. La personne qui fume des Blue Master boit de la bi√®re
        13. L'Allemand fume des Prince
        14. Le Norv√©gien vit √† c√¥t√© de la maison bleue
        15. La personne qui fume des Blend a un voisin qui boit de l'eau
        
        Question: Qui poss√®de le poisson ?
        
        ATTENTION: Cette √©nigme EXIGE l'utilisation intensive de TweetyProject par Watson.
        Minimum OBLIGATOIRE: 10+ clauses logiques + 5+ requ√™tes TweetyProject."""

    async def run_cluedo_validation(self) -> List[Dict[str, Any]]:
        """Ex√©cute la validation Cluedo avec les cas simple et complexe."""
        
        print("üïµÔ∏è D√©marrage validation Cluedo...")
        
        results = []
        
        # Cas simple
        print("\nüü¢ CAS CLUEDO SIMPLE")
        print("="*40)
        simple_case = self.generate_simple_cluedo_case()
        simple_results = await self.run_cluedo_with_traces(simple_case, "simple")
        results.append(simple_results)
        
        # Cas complexe
        print("\nüî¥ CAS CLUEDO COMPLEXE")
        print("="*40)
        complex_case = self.generate_complex_cluedo_case()
        complex_results = await self.run_cluedo_with_traces(complex_case, "complexe")
        results.append(complex_results)
        
        return results

    async def run_cluedo_with_traces(self, case_description: str, case_name: str) -> Dict[str, Any]:
        """Ex√©cute un cas Cluedo avec capture compl√®te des traces."""
        
        try:
            # Cr√©ation du kernel
            kernel = self.create_kernel()
            
            # Capture du timestamp de d√©but
            start_time = datetime.datetime.now()
            
            # Ex√©cution du jeu Cluedo
            print(f"üìã Sc√©nario: {case_description[:100]}...")
            final_history, final_state = await run_cluedo_oracle_game(kernel, case_description)
            
            # Capture du timestamp de fin
            end_time = datetime.datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            # Construction des r√©sultats complets
            results = {
                "metadata": {
                    "case_name": case_name,
                    "timestamp": self.timestamp,
                    "start_time": start_time.isoformat(),
                    "end_time": end_time.isoformat(),
                    "duration_seconds": duration,
                    "model_used": "gpt-4o-mini"
                },
                "input": {
                    "case_description": case_description
                },
                "conversation_history": final_history,
                "final_state": {
                    "final_solution": getattr(final_state, 'final_solution', None),
                    "solution_secrete": getattr(final_state, 'solution_secrete_cluedo', None),
                    "hypotheses": getattr(final_state, 'hypotheses_enquete', []),
                    "tasks": getattr(final_state, 'tasks', {})
                },
                "analysis": {
                    "conversation_length": len(final_history) if final_history else 0,
                    "success": getattr(final_state, 'final_solution', None) is not None
                }
            }
            
            # Sauvegarde des traces
            trace_file = self.cluedo_dir / f"trace_{case_name}_{self.timestamp}.json"
            with open(trace_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False, default=str)
                
            print(f"‚úÖ Traces Cluedo sauvegard√©es: {trace_file}")
            
            return results
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'ex√©cution de {case_name}: {e}")
            raise

    async def run_einstein_validation(self) -> List[Dict[str, Any]]:
        """Ex√©cute la validation Einstein avec les cas simple et complexe."""
        
        print("üß© D√©marrage validation Einstein...")
        
        results = []
        
        # Cas simple (5 contraintes)
        print("\nüü¢ CAS EINSTEIN SIMPLE")
        print("="*40)
        simple_case = self.generate_simple_einstein_case()
        simple_results = await self.run_einstein_with_traces(simple_case, "simple")
        results.append(simple_results)
        
        # Cas complexe (10+ contraintes)
        print("\nüî¥ CAS EINSTEIN COMPLEXE")
        print("="*40)
        complex_case = self.generate_complex_einstein_case()
        complex_results = await self.run_einstein_with_traces(complex_case, "complexe")
        results.append(complex_results)
        
        return results

    async def run_einstein_with_traces(self, case_description: str, case_name: str) -> Dict[str, Any]:
        """Ex√©cute un cas Einstein avec capture compl√®te des traces."""
        
        try:
            # Cr√©ation du kernel
            kernel = self.create_kernel()
            
            # Capture du timestamp de d√©but
            start_time = datetime.datetime.now()
            
            # Cr√©ation de l'orchestrateur logique complexe
            orchestrateur = LogiqueComplexeOrchestrator(kernel)
            
            # Cr√©ation des agents sp√©cialis√©s avec outils
            sherlock_tools = SherlockTools(kernel)
            kernel.add_plugin(sherlock_tools, plugin_name="SherlockTools")
            
            sherlock_agent = SherlockEnqueteAgent(
                kernel=kernel,
                agent_name="Sherlock",
                service_id="openai_chat"
            )
            
            watson_agent = WatsonLogicAssistant(
                kernel=kernel,
                agent_name="Watson", 
                service_id="openai_chat"
            )
            
            # Ex√©cution de l'√©nigme Einstein
            print(f"üìã √ânigme: {case_description[:150]}...")
            
            resultats = await orchestrateur.resoudre_enigme_complexe(sherlock_agent, watson_agent)
            
            # Capture du timestamp de fin
            end_time = datetime.datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            # Construction des r√©sultats complets
            results = {
                "metadata": {
                    "case_name": case_name,
                    "timestamp": self.timestamp,
                    "start_time": start_time.isoformat(),
                    "end_time": end_time.isoformat(),
                    "duration_seconds": duration,
                    "model_used": "gpt-4o-mini"
                },
                "input": {
                    "case_description": case_description
                },
                "execution_results": resultats,
                "analysis": {
                    "enigme_resolue": resultats.get('enigme_resolue', False),
                    "tours_utilises": resultats.get('tours_utilises', 0)
                }
            }
            
            # Sauvegarde des traces
            trace_file = self.einstein_dir / f"trace_einstein_{case_name}_{self.timestamp}.json"
            with open(trace_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False, default=str)
                
            print(f"‚úÖ Traces Einstein sauvegard√©es: {trace_file}")
            
            return results
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'ex√©cution de {case_name}: {e}")
            raise

    async def run_full_validation(self) -> Dict[str, Any]:
        """Ex√©cute la validation compl√®te des d√©mos avec traces."""
        
        print("\nüöÄ LANCEMENT VALIDATION COMPL√àTE AVEC TRACES")
        print("="*80)
        
        # Validation de l'environnement
        env_validation = self.validate_environment()
        if not env_validation["environment_ready"]:
            raise RuntimeError("Environnement non pr√™t pour la validation")
            
        start_time = datetime.datetime.now()
        all_results = {
            "metadata": {
                "validation_start": start_time.isoformat(),
                "timestamp": self.timestamp,
                "environment_validation": env_validation
            },
            "cluedo_results": None,
            "einstein_results": None
        }
        
        try:
            # √âTAPE 1: Validation Cluedo
            print(f"\nüìã √âTAPE 1/2: VALIDATION CLUEDO")
            print(f"{'='*50}")
            
            cluedo_results = await self.run_cluedo_validation()
            all_results["cluedo_results"] = cluedo_results
            
            # √âTAPE 2: Validation Einstein
            print(f"\nüß© √âTAPE 2/2: VALIDATION EINSTEIN")
            print(f"{'='*50}")
            
            einstein_results = await self.run_einstein_validation()
            all_results["einstein_results"] = einstein_results
            
            # Finalisation
            end_time = datetime.datetime.now()
            total_duration = (end_time - start_time).total_seconds()
            
            all_results["metadata"]["validation_end"] = end_time.isoformat()
            all_results["metadata"]["total_duration"] = total_duration
            
            # Sauvegarde du rapport global
            report_file = self.output_dir / f"global_validation_report_{self.timestamp}.json"
            
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(all_results, f, indent=2, ensure_ascii=False, default=str)
                
            # Affichage du r√©sum√© final
            self.display_final_summary(all_results)
            
            return all_results
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de la validation compl√®te: {e}")
            raise

    def display_final_summary(self, all_results: Dict[str, Any]):
        """Affiche le r√©sum√© final de la validation."""
        
        print(f"\n{'='*80}")
        print(f"üéâ VALIDATION COMPL√àTE TERMIN√âE")
        print(f"{'='*80}")
        
        metadata = all_results['metadata']
        cluedo_results = all_results['cluedo_results']
        einstein_results = all_results['einstein_results']
        
        print(f"‚è±Ô∏è  Dur√©e totale: {metadata['total_duration']:.2f}s")
        print(f"üß™ Tests Cluedo: {len(cluedo_results) if cluedo_results else 0}")
        print(f"üß™ Tests Einstein: {len(einstein_results) if einstein_results else 0}")
        
        print(f"\nüìÅ TRACES G√âN√âR√âES:")
        print(f"   - Cluedo: {self.cluedo_dir}/")
        print(f"   - Einstein: {self.einstein_dir}/")
        print(f"   - Rapport global: global_validation_report_{self.timestamp}.json")
        
        print(f"\n‚úÖ Validation des d√©mos Sherlock, Watson et Moriarty termin√©e avec succ√®s!")

async def main():
    """Fonction principale de validation compl√®te avec traces."""
    
    print("üöÄ VALIDATION MA√éTRE - D√âMOS SHERLOCK, WATSON ET MORIARTY")
    print("="*80)
    print("üéØ Objectif: Valider les d√©mos avec traces agentiques compl√®tes")
    print("üîß Tests: Cluedo (informel) + Einstein (formel avec TweetyProject)")
    print("üìä Livrables: Traces JSON + Rapports d'analyse + Validation qualit√©")
    
    # Configuration du logging
    setup_logging()
    
    # Chargement de l'environnement
    load_dotenv()
    
    try:
        # Cr√©ation et lancement du validateur ma√Ætre
        master_validator = MasterTraceValidator()
        
        # Ex√©cution de la validation compl√®te
        results = await master_validator.run_full_validation()
        
        return results
        
    except Exception as e:
        print(f"\n‚ùå ERREUR CRITIQUE: {e}")
        logging.error(f"Erreur validation ma√Ætre: {e}", exc_info=True)
        raise

if __name__ == "__main__":
    asyncio.run(main())